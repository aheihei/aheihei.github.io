<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APP使用接口获取网图</title>
    <url>/2022/03/14/APP%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%BD%91%E5%9B%BE/</url>
    <content><![CDATA[<p>怎么从网络接口中获取数据，需要用到哪些框架，传哪些参数</p>
<span id="more"></span>

<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="okhttp"><a href="#okhttp" class="headerlink" title="okhttp"></a>okhttp</h2><p>网络请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * param1：请求地址</span></span><br><span class="line"><span class="comment">    * param2: 传输数据类型（此请求是键值对）</span></span><br><span class="line"><span class="comment">    * &#123;&quot;id&quot;:11,&quot;name&quot;:&quot;5bc01a39e7bce75ea7b2fb40&quot;,&quot;classify&quot;:&quot;yzmn&quot;,&quot;smallPic&quot;:</span></span><br><span class="line"><span class="comment">    * param3: 异步请求参数，回调</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(String url, Map&lt;String, String&gt; params, Callback callback)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//form表单形式传数据（其他有json）</span></span><br><span class="line">        FormBody.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder();</span><br><span class="line">        <span class="comment">//遍历数据</span></span><br><span class="line">        <span class="keyword">for</span> (String key : params.keySet())&#123;</span><br><span class="line">            builder.add(key,params.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">FormBody</span> <span class="variable">body</span> <span class="operator">=</span> builder.build();</span><br><span class="line"></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .post(body)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//enqueue异步请求</span></span><br><span class="line">        <span class="comment">//需要callback回调</span></span><br><span class="line">        client.newCall(request).enqueue(callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*请求数据*/</span></span><br><span class="line">        <span class="keyword">if</span> (isLoading)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isLoading = <span class="literal">true</span>;</span><br><span class="line">        Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;classify&quot;</span>,<span class="string">&quot;dmdh&quot;</span>);</span><br><span class="line">        params.put(<span class="string">&quot;pageNum&quot;</span>,page+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        params.put(<span class="string">&quot;limit&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">        OkHttpUtil.post(<span class="string">&quot;http://www.dtasecurity.cn:18080/demo01/getWallpaper&quot;</span>,</span><br><span class="line">                params,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> IOException e)</span> &#123;</span><br><span class="line">                        isLoading = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">responseText</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">                        <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;ResponseEntity&lt;WallPaperEntity&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">                        <span class="comment">//匿名内部类</span></span><br><span class="line">                        ResponseEntity&lt;WallPaperEntity&gt; data = <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(responseText, responseType);</span><br><span class="line">                        wallPaperEntityList.addAll(data.getData());</span><br><span class="line">                        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">                        msg.what = <span class="number">1</span>;</span><br><span class="line">                        handler.sendMessage(msg);</span><br><span class="line">                        isLoading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        page++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h2><p>解析Json</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">responseText</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">                        <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;ResponseEntity&lt;WallPaperEntity&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">                        ResponseEntity&lt;WallPaperEntity&gt; data = <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(responseText, responseType);</span><br><span class="line">                        wallPaperEntityList.addAll(data.getData());</span><br><span class="line">                        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">                        msg.what = <span class="number">1</span>;</span><br><span class="line">                        handler.sendMessage(msg);</span><br><span class="line">                        isLoading = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>Gson解析返回的对象类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.wallpaper.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseEntity</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//请求数据参数</span></span><br><span class="line">    Integer pageNum;</span><br><span class="line">    Boolean hasNext;</span><br><span class="line">    Integer limit;</span><br><span class="line">    String classify;</span><br><span class="line">    String message;</span><br><span class="line">    List&lt;T&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getPageNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPageNum</span><span class="params">(Integer pageNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pageNum = pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">getHasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasNext</span><span class="params">(Boolean hasNext)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hasNext = hasNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getLimit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLimit</span><span class="params">(Integer limit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClassify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> classify;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassify</span><span class="params">(String classify)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classify = classify;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(List&lt;T&gt; data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h2><p>图像加载框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把从网络上获取的图片放到img_wallpaper</span></span><br><span class="line">       Glide.with(img_wallpaper).load(smallPicUrl).into(img_wallpaper);</span><br></pre></td></tr></table></figure>

<h1 id="项目："><a href="#项目：" class="headerlink" title="项目："></a>项目：</h1><h2 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h2><p>网格试图</p>
<p>属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android:columnWidth：设置列的宽度</span><br><span class="line">android:gravity：组件对其方式</span><br><span class="line">android:horizontalSpacing：水平方向每个单元格的间距</span><br><span class="line">android:verticalSpacing：垂直方向每个单元格的间距</span><br><span class="line">android:numColumns：设置列数</span><br><span class="line">android:stretchMode：设置拉伸模式，可选值如下： none：不拉伸；spacingWidth：拉伸元素间的间隔空隙 columnWidth：仅仅拉伸表格元素自身 spacingWidthUniform：既拉元素间距又拉伸他们之间的间隔空袭</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<p>1, 创建Item的布局：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/img_item_wallpaper&quot;</span></span><br><span class="line">        android:scaleType=<span class="string">&quot;fitXY&quot;</span></span><br><span class="line">        android:padding=<span class="string">&quot;5dp&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;120dp&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;200dp&quot;</span>/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>2, 写entity实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.wallpaper.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WallPaperEntity</span> &#123;</span><br><span class="line">    <span class="comment">//要获取的资源的各种属性</span></span><br><span class="line">    String id;</span><br><span class="line">    String name;</span><br><span class="line">    String smallPic;</span><br><span class="line">    String bigPic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSmallPic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> smallPic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSmallPic</span><span class="params">(String smallPic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smallPic = smallPic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBigPic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bigPic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBigPic</span><span class="params">(String bigPic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bigPic = bigPic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3，MainActivity的布局和Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;GridView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/gv_main&quot;</span></span><br><span class="line">        android:numColumns=<span class="string">&quot;3&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initViews</span><span class="params">()</span> &#123;</span><br><span class="line">        gv_main = findViewById(R.id.gv_main);</span><br><span class="line">        <span class="comment">//初始化adapater</span></span><br><span class="line">        adapter = <span class="keyword">new</span> <span class="title class_">WallpaperAdapter</span>(<span class="built_in">this</span>,wallPaperEntityList);</span><br><span class="line">        <span class="comment">//使用适配器展示图片</span></span><br><span class="line">        gv_main.setAdapter(adapter);</span><br><span class="line">        <span class="comment">//监听是否到底部</span></span><br><span class="line">        gv_main.setOnScrollChangeListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnScrollChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onScrollChange</span><span class="params">(View v, <span class="type">int</span> scrollX, <span class="type">int</span> scrollY, <span class="type">int</span> oldScrollX, <span class="type">int</span> oldScrollY)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (((GridView)v).getLastVisiblePosition() &gt; wallPaperEntityList.size() - <span class="number">6</span>)&#123;</span><br><span class="line">                    getData();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        getData();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>adapater数据适配器，数据想要怎样展示到屏幕上时用，拿到数据后怎么去展示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WallpaperAdapter</span> <span class="keyword">extends</span> <span class="title class_">BaseAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//UI传递消息使用</span></span><br><span class="line">    Context context;</span><br><span class="line">    <span class="comment">//存储数据,解析时可以使用</span></span><br><span class="line">    List&lt;WallPaperEntity&gt;wallPaperEntityList;</span><br><span class="line">    <span class="comment">//添加构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WallpaperAdapter</span><span class="params">(Context context, List&lt;WallPaperEntity&gt; wallPaperEntityList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">        <span class="built_in">this</span>.wallPaperEntityList = wallPaperEntityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//数量</span></span><br><span class="line">        <span class="keyword">return</span> wallPaperEntityList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getItem</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wallPaperEntityList.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getItemId</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="type">int</span> position, View convertView, ViewGroup parent)</span> &#123;</span><br><span class="line">        <span class="comment">// 每拿到一个图片初始化一个</span></span><br><span class="line">        <span class="comment">//初始化xml的view</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">inflate</span> <span class="operator">=</span> View.inflate(context, R.layout.item_wallpaper,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置图片的view</span></span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">img_wallpaper</span> <span class="operator">=</span> inflate.findViewById(R.id.img_item_wallpaper);</span><br><span class="line">        <span class="comment">//设置数据，最后返回就行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">smallPicUrl</span> <span class="operator">=</span> wallPaperEntityList.get(position).getSmallPic();</span><br><span class="line">        <span class="comment">//把从网络上获取的图片放到img_wallpaper</span></span><br><span class="line">        Glide.with(img_wallpaper).load(smallPicUrl).into(img_wallpaper);</span><br><span class="line">        <span class="keyword">return</span> inflate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/14/APP%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%BD%91%E5%9B%BE/bTzp1e.md-1647221046750.png" alt="bTzp1e.md"></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>1，怎么从网络上获取</p>
<p>2，怎么在界面上显示</p>
<p>3，显示在界面上过程中怎么处理</p>
<h1 id="API接口的保护"><a href="#API接口的保护" class="headerlink" title="API接口的保护"></a>API接口的保护</h1><h2 id="消息摘要算法"><a href="#消息摘要算法" class="headerlink" title="消息摘要算法"></a>消息摘要算法</h2><p>它通过对所有数据提取指纹信息以实现数据签名、数据完整性校验等功能，由于其不可逆性，有时候会被用做敏感信息的加密。数据摘要算法也被称为哈希（Hash）算法或散列算法。</p>
<p>消息摘要算法的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。（摘要可以比方为指纹，消息摘要算法就是要得到文件的唯一职位）</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。</li>
<li>一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出</li>
<li>只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息</li>
<li>好的摘要算法，没有人能从中找到 “碰撞” 或者说极度难找到，虽然 “碰撞” 是肯定存在的</li>
</ul>
<h3 id="常用的消息摘要算法"><a href="#常用的消息摘要算法" class="headerlink" title="常用的消息摘要算法"></a>常用的消息摘要算法</h3><p>CRC32（<code>Cyclic redundancy check</code>：循环冗余检验码）</p>
<p>MD5（<code>Message Digest algorithm 5</code>：消息摘要算法版本5)</p>
<p>SHA1,SHA256,SHA512 （<code>Secure Hash Algorithm</code>：安全散列算法)</p>
<h3 id="摘要目的"><a href="#摘要目的" class="headerlink" title="摘要目的"></a>摘要目的</h3><p>数据完整性，是否在传输过程中被修改。</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>信息从一种形式或格式转换为另一种形式的过程，方便在不同系统之中传输，例如最常见的ASCII字符编码。由于网络上只能传输二进制数据，任何数据如果想要经由网络传输，就必须先转化成二进制，ASCII 提供了一个将A、B、C等字母转化为二进制的规则。信息—&gt;编码—&gt;二进制—&gt;解码—&gt;信息</p>
<h3 id="常见的编码"><a href="#常见的编码" class="headerlink" title="常见的编码"></a>常见的编码</h3><p>ASCII</p>
<p>Base64</p>
<p>URL</p>
<h3 id="编码目的"><a href="#编码目的" class="headerlink" title="编码目的"></a>编码目的</h3><p>压缩空间，便于传输，减少带宽。</p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>加密是为了保证数据安全传输，使得其他人不能获取的具体信息内容。加密是可逆的，明文 + 秘钥 &#x3D; 加密信息。加密又分为对称加密和非对称加密，区别在于在加密和解密信息时秘钥是不是同一个。</p>
<p>1、对称加密：DES, AES，3DES</p>
<p>对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。</p>
<p>不足之处是，交易双方都使用同样钥匙，安全性得不到保证。</p>
<p>2、非对称加密： RSA，ESA</p>
<p>密钥是成对出现。使用一对“私钥-公钥”，用私钥加密的内容只有对应公钥才能解开</p>
<ul>
<li>公钥：公开给所有人。不能通过公钥反推出私钥；public key</li>
<li>自己留存，不公开。有且只有一个对应的私钥；secret key</li>
<li>通过私钥加密的密文只能通过公钥能解密，通过公钥加密的密文也只能通过私钥能解密。</li>
</ul>
<p>但由于算法强度比对称加密复杂，加解密的速度比对称加解密的速度要慢。</p>
<h3 id="加密目的"><a href="#加密目的" class="headerlink" title="加密目的"></a>加密目的</h3><p>传输过程中既是被截取也无法查看原文，因为没有秘钥。</p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>是对摘要后的数据进行加密</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>自己服务器公钥给权威机构（CA），权威机构对服务器的公钥和其他信息进行hash摘要再用权威机构的公钥进行加密后给客户服务器，客户把这个公钥给浏览器。</p>
<p>1、数据第一步编码（base64等）</p>
<p>2、第二步进行摘要（md5，sha256）</p>
<p>3、第三步对摘要后的数据进行加密（对称和非对称加密）</p>
<h2 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">            <span class="comment">// 待加密字符</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalStr</span> <span class="operator">=</span> <span class="string">&quot;111111&quot;</span>;</span><br><span class="line">            String[] hexs = &#123;<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;F&quot;</span>,&#125;;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md5</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] digest = md5.digest(originalStr.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(digest.toString());</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">byte</span> b:digest)&#123;</span><br><span class="line">                sb.append(hexs[b &gt;&gt; <span class="number">4</span> &amp; <span class="number">0xF</span>]);</span><br><span class="line">                sb.append(hexs[b &amp; <span class="number">0xF</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sb.toString());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/14/APP%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%BD%91%E5%9B%BE/2022-03-20-22-18-55.png" alt="2022-03-20-22-18-55"></p>
<p>没加sign<br><img src="/2022/03/14/APP%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%BD%91%E5%9B%BE/2022-03-21-21-47-01.png" alt="2022-03-21-21-47-01"><br>加sign和时间戳</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isLoading)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       isLoading = <span class="literal">true</span>;</span><br><span class="line">       Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="type">String</span> <span class="variable">classify</span> <span class="operator">=</span> <span class="string">&quot;yzmn&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis()+<span class="string">&quot;&quot;</span>;</span><br><span class="line">       params.put(<span class="string">&quot;classify&quot;</span>,classify);</span><br><span class="line">       params.put(<span class="string">&quot;pageNum&quot;</span>,page+<span class="string">&quot;&quot;</span>);</span><br><span class="line">       params.put(<span class="string">&quot;limit&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">       params.put(<span class="string">&quot;timestamp&quot;</span>,timestamp);</span><br><span class="line">       <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> md5(classify+page+timestamp);</span><br><span class="line">       params.put(<span class="string">&quot;sign&quot;</span>,sign);</span><br><span class="line">       OkHttpUtil.post(<span class="string">&quot;http://www.dtasecurity.cn:18080/demo02/getWallpaper&quot;</span>,</span><br><span class="line">               params,</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> IOException e)</span> &#123;</span><br><span class="line">                       isLoading = <span class="literal">false</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                       <span class="type">String</span> <span class="variable">responseText</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">                       <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;ResponseEntity&lt;WallPaperEntity&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">                       ResponseEntity&lt;WallPaperEntity&gt; data = <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(responseText, responseType);</span><br><span class="line">                       wallPaperEntities.addAll(data.getData());</span><br><span class="line">                       <span class="comment">//adapter.notifyDataSetChanged();</span></span><br><span class="line">                       <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">                       msg.what = <span class="number">1</span>;</span><br><span class="line">                       handler.sendMessage(msg);</span><br><span class="line">                       isLoading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">       page++;</span><br><span class="line">   &#125;</span><br><span class="line">   String[] hexs = &#123;<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;F&quot;</span>,&#125;;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">md5</span><span class="params">(String data)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">MessageDigest</span> <span class="variable">md5</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">           <span class="type">byte</span>[] digest = md5.digest(data.getBytes());</span><br><span class="line">           <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">byte</span> b : digest)&#123;</span><br><span class="line">               sb.append(hexs[b &gt;&gt; <span class="number">4</span> &amp; <span class="number">0xF</span>]);</span><br><span class="line">               sb.append(hexs[b &amp; <span class="number">0xF</span>]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>  sb.toString();</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/14/APP%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%BD%91%E5%9B%BE/2022-03-26-14-37-50.png" alt="2022-03-26-14-37-50"></p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>APP抓包</title>
    <url>/2022/03/14/APP%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/ecd76310d9e45803ce329fb61db870eb.jpg" alt="ecd76310d9e45803ce329fb61db870eb" style="zoom:200%;">

<span id="more"></span>

<p>代理的原理：</p>
<p>它是网络信息的中转站。在我们正常请求一个网站时，是发送了请求给Web服务器，Web服务器把响应传回给我们。如果设置了代理服务器，实际上就是在本机和服务器之间搭建了一个桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发出请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机。这样我们同样可以正常访问网页，但这个过程中Web服务器识别出的真实IP就不再是我们本机的IP了，就成功实现了IP伪装，这就是代理的基本原理。</p>
<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/web_proxy-1647220738454.jpg" alt="web_proxy"></p>
<p><strong>mac地址</strong>：发送端和接收端的地址便是指网卡的地址</p>
<p>每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）</p>
<p><strong>IP地址</strong>：由于mac地址很难记忆，所以又出现了IP地址</p>
<p>身份证（mac地址）和名字（IP地址）</p>
<p><strong>arp协议功能</strong>：广播的方式发送数据包，获取目标主机的mac地址</p>
<p>网络通信流程图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://images2018.cnblogs.com/blog/988061/201809/988061-20180909111944359-1323196399.png</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/988061-20180909111944359-1323196399.png" alt="988061-20180909111944359-1323196399"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://images2018.cnblogs.com/blog/988061/201809/988061-20180909112504683-1737949469.png</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/988061-20180909112504683-1737949469.png" alt="988061-20180909112504683-1737949469"></p>
<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII形式给出；而消息内容则具有一个类似MIME的格式</p>
<h2 id="怎么通信"><a href="#怎么通信" class="headerlink" title="怎么通信"></a>怎么通信</h2><p>HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。请求报文格式如下： </p>
<p>请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体</p>
<p>请求行以方法字段开始，后面分别是URL字段和HTTP协议版本字段，并以CRLF结尾。SP是分隔符。除了在最后的CRLF序列中CF和LF是必需的之外，其他都可以不要。有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。</p>
<p>应答报文格式如下：</p>
<p>状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体</p>
<h1 id="netcat模拟http协议"><a href="#netcat模拟http协议" class="headerlink" title="netcat模拟http协议"></a>netcat模拟http协议</h1><p>Get:</p>
<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220313155434123.png" alt="image-20220313155434123"></p>
<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220313160049200.png" alt="image-20220313160049200"></p>
<p>POST:</p>
<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220313161517748.png" alt="image-20220313161517748"></p>
<h1 id="telnet模拟http协议"><a href="#telnet模拟http协议" class="headerlink" title="telnet模拟http协议"></a>telnet模拟http协议</h1><p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220313161900522.png" alt="image-20220313161900522"></p>
<h1 id="r0capture的使用"><a href="#r0capture的使用" class="headerlink" title="r0capture的使用"></a>r0capture的使用</h1><p>拉跨</p>
<h1 id="HTTPS核心原理"><a href="#HTTPS核心原理" class="headerlink" title="HTTPS核心原理"></a>HTTPS核心原理</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>加解密使用同一个密钥，加解密速度快，相对不安全，拿到私钥就能解密传输的内容，使用的主要算法有：DES、3DES、AES等</p>
<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220404212308671.png" alt="image-20220404212308671"></p>
<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220404212604804.png" alt="image-20220404212604804"></p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>甲方把自己的公钥发放出去，乙方使用公钥进行加密，然后把加密内容发送的甲方，甲方再使用自己的私钥进行解密，然后甲方把要返回的数据使用已方的公钥进行加密，乙方拿到数据后使用自己的私钥进行解密。由于私钥不对外开放，因此安全性大大提高。也因此加解密需要的时间更久，速度相对较慢，适合少量数据使用。常用的加密算法有：RSA、ECC（椭圆曲线）、背包算法</p>
<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220404214048678.png" alt="image-20220404214048678"></p>
<h2 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h2><p>HTTPS使用了非对称加密，然而非对称加密只作用在证书验证阶段，在内容传输的过程中使用的是非对称加密</p>
<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220404220002133.png" alt="image-20220404220002133"></p>
<p>① 证书验证阶段</p>
<ol>
<li>浏览器发起 HTTPS 请求</li>
<li>服务端返回 HTTPS 证书</li>
<li>客户端验证证书是否合法，如果不合法则提示告警</li>
</ol>
<p>② 数据传输阶段</p>
<p>1.当证书验证合法后，在本地生成随机数</p>
<p>2.通过公钥加密随机数，并把加密后的随机数传输到服务端</p>
<p>3.服务端通过私钥对随机数进行解密</p>
<p>4.服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输</p>
<p>为什么内容使用对称加密，因为非对称加解密在效率上非常低，而http的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。</p>
<p>另外，在HTTPS的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以HTTPS中内容传输加密采取的是对称加密，而不是非对称加密。</p>
<h2 id="用了-HTTPS-会被抓包吗"><a href="#用了-HTTPS-会被抓包吗" class="headerlink" title="用了 HTTPS 会被抓包吗"></a><strong>用了 HTTPS 会被抓包吗</strong></h2><p>HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。关注微信公众号：Java技术栈，在后台回复：工具，可以获取我整理的 N 篇最新开发工具教程，都是干货。</p>
<p>但是，正如前文所说，浏览器只会提示安全风险，如果用户授权仍然可以继续访问网站，完成请求。因此，只要客户端是我们自己的终端，我们授权的情况下，便可以组建中间人网络，而抓包工具便是作为中间人的代理。</p>
<p>通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。</p>
<h2 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h2><h3 id="什么是CA"><a href="#什么是CA" class="headerlink" title="什么是CA"></a>什么是CA</h3><p>CA（数字证书颁发机构）是值得信赖的第三方实体颁发数字证书机构并管理为最终用户数据加密的公共密钥和证书。CA的责任是确保公司或用户收到有效的身份认证是唯一证书。</p>
<p>  数字证书采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。每个用户自己设定一把特定的仅为本人所知的私有密钥(私钥)，用它进行解密和 签名;同时设定一把公共密钥(公钥)并由本人公开，为一组用户所共享，用于加密和验证签名。当发送一份保密文件时，发送方使用接收方的公钥对数据加密，而 接收方则使用自己的私钥解密，这样信息就可以安全无误地到达目的地了。通过数字的手段保证加密过程是一个不可逆过程，即只有用私有密钥才能解密。在公开密 钥密码体制中，常用的一种是RSA体制。其数学原理是将一个大数分解成两个质数的乘积，加密和解密用的是两个不同的密钥。即使已知明文、密文和加密密钥 (公开密钥)，想要推导出解密密钥(私密密钥)，在计算上是不可能的。按现在的计算机技术水平，要破解目前采用的1024位RSA密钥，需要上千年的计算 时间。公开密钥技术解决了密钥发布的管理问题，商户可以公开其公开密钥，而保留其私有密钥。购物者可以用人人皆知的公开密钥对发送的信息进行加密，安全地 传送给商户，然后由商户用自己的私有密钥进行解密。</p>
<p>用户也可以采用自己的私钥对信息加以处理，由于密钥仅为本人所有，这样就产生了别人无法生成的文件，也就形成了数字签名。采用数字签名，能够确认以下两点：</p>
<p>(1)保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。</p>
<p>(2)保证信息自签发后到收到为止未曾作过任何修改，签发的文件是真实文件。</p>
<p>数字签名具体做法是:</p>
<p>(1)将报文按双方约定的HASH算法计算得到一个固定位数的报文摘要。在数学上保证:只要改动报文中任何一位，重新计算出的报文摘要值就会与原先的值不相符。这样就保证了报文的不可更改性。</p>
<p>(2)将该报文摘要值用发送者的私人密钥加密，然后连同原报文一起发送给接收者，而产生的报文即称数字签名。</p>
<p>(3)接收方收到数字签名后，用同样的HASH算法对报文计算摘要值，然后与用发送者的公开密钥进行解密解开的报文摘要值相比较。如相等则说明报文确实来自所称的发送者。</p>
<p>是一个经证书授权中心(如光网CA)数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。一般情况下证书中还包括密钥的有效时间，发证机关(证书授权中心)的名称，该证书的序列号等信息，证书的格式遵循 ITUT X.509国际标准。</p>
<h3 id="为什么用CA"><a href="#为什么用CA" class="headerlink" title="为什么用CA"></a>为什么用CA</h3><p> 基于Internet网的电子商务系统技术使在网上购物的顾客能够极其方便轻松地获得商家和企业的信息，但同时也增加了对某些敏感或有价值的数 据被滥用的风险。买方和卖方都必须对于在因特网上进行的一切金融交易运作都是真实可靠的，并且要使顾客、商家和企业等交易各方都具有绝对的信心，因而因特 网(Internet)电子商务系统必须保证具有十分可靠的安全保密技术，也就是说必须保证网络安全的四大要素，即信息传输的保密性、数据交换的完整性、 发送信息的不可否认性、交易者身份的确定性。</p>
<p>1、信息的保密性</p>
<p>交易中的商务信息均有保密的要求。如信用卡的帐号和用户名被人知悉，就可能被盗用，订货和付款的信息被竞争对手获悉，就可能丧失商机。因此在电子商务的信息传播中一般均有加密的要求。</p>
<p>2、交易者身份的确定性</p>
<p>​    网上交易的双方很可能素昧平生，相隔千里。要使交易成功首先要能确认对方的身份，对商家要考虑客户端不能是骗子，而客户也会担心网上的商店不是 一个玩弄欺诈的黑店。因此能方便而可靠地确认对方身份是交易的前提。对于为顾客或用户开展服务的银行、信用卡公司和销售商店，为了做到安全、保密、可靠地 开展服务活动，都要进行身份认证的工作。对有关的销售商店来说，他们对顾客所用的信用卡的号码是不知道的，商店只能把信用卡的确认工作完全交给银行来完 成。银行和信用卡公司可以采用各种保密与识别方法，确认顾客的身份是否合法，同时还要防止发生拒付款问题以及确认订货和订货收据信息等。</p>
<p>3、不可否认性</p>
<p>​    由于商情的千变万化，交易一旦达成是不能被否认的。否则必然会损害一方的利益。例如订购黄金，订货时金价较低，但收到订单后，金价上涨了，如收 单方能否认受到订单的实际时间，甚至否认收到订单的事实，则订货方就会蒙受损失。因此电子交易通信过程的各个环节都必须是不可否认的。</p>
<p>4、不可修改性</p>
<p>​    交易的文件是不可被修改的，如上例所举的订购黄金。供货单位在收到订单后，发现金价大幅上涨了，如其能改动文件内容，将订购数1吨改为1克，则可大幅受益，那么订货单位可能就会因此而蒙受损失。因此电子交易文件也要能做到不可修改，以保障交易的严肃和公正。</p>
<p>​    人们在感叹电子商务的巨大潜力的同时，不得不冷静地思考，在人与人互不见面的计算机互联网上进行交易和作业时，怎么才能保证交易的公正性和安全 性，保证交易双方身份的真实性。国际上已经有比较成熟的安全解决方案，那就是建立安全证书体系结构。数字安全证书提供了一种在网上验证身份的方式。安全证 书体制主要采用了公开密钥体制，其它还包括对称密钥加密、数字签名、数字信封等技术。</p>
<p>​    我们可以使用数字证书，通过运用对称和非对称密码体制等密码技术建立起一套严密的身份认证系统，从而保证：信息除发送方和接收方外不被其它人窃取;信息在传输过程中不被篡改;发送方能够通过数字证书来确认接收方的身份;发送方对于自己的信息不能抵赖。</p>
<p> <strong>防止”中间人“攻击，同时可以为网站提供身份证明。</strong></p>
<h1 id="中间人攻击原理"><a href="#中间人攻击原理" class="headerlink" title="中间人攻击原理"></a>中间人攻击原理</h1><p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/34fwbli4dv.jpeg" alt="img"></p>
<p>1.本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器</p>
<p>2.中间人服务器返回中间人自己的证书</p>
<p>3.客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输</p>
<p>4.中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</p>
<p>5.中间人以客户端的请求内容再向正规网站发起请求</p>
<p>6.因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据</p>
<p>7.中间人凭借与正规网站建立的对称加密算法对内容进行解密</p>
<p>8.中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输</p>
<p>9.客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</p>
<p>由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。</p>
<h1 id="应用添加证书"><a href="#应用添加证书" class="headerlink" title="应用添加证书"></a>应用添加证书</h1><p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220405115711745.png" alt="image-20220405115711745"></p>
<p>设置证书</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">InputStream</span> <span class="variable">in_cer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OkHttpClient <span class="title function_">getClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">CertificateFactory</span> <span class="variable">certificateFactory</span> <span class="operator">=</span> CertificateFactory.getInstance(<span class="string">&quot;X509&quot;</span>);</span><br><span class="line">                <span class="type">Certificate</span> <span class="variable">certificate</span> <span class="operator">=</span> certificateFactory.generateCertificate(in_cer);</span><br><span class="line">                <span class="type">KeyStore</span> <span class="variable">ks</span> <span class="operator">=</span> KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">                ks.load(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">                ks.setCertificateEntry(<span class="string">&quot;wallpaper&quot;</span>,certificate);</span><br><span class="line">                <span class="type">TrustManagerFactory</span> <span class="variable">trustManagerFactory</span> <span class="operator">=</span> TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">                trustManagerFactory.init(ks);</span><br><span class="line">                TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();</span><br><span class="line">                <span class="type">SSLContext</span> <span class="variable">context</span> <span class="operator">=</span> SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">                context.init(<span class="literal">null</span>,trustManagers,<span class="keyword">new</span> <span class="title class_">SecureRandom</span>());</span><br><span class="line">                <span class="type">SSLSocketFactory</span> <span class="variable">factory</span> <span class="operator">=</span> context.getSocketFactory();</span><br><span class="line">                OkHttpClient.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder();</span><br><span class="line">                builder.sslSocketFactory(factory, (X509TrustManager) trustManagers[<span class="number">0</span>]);</span><br><span class="line">                builder.hostnameVerifier(<span class="keyword">new</span> <span class="title class_">HostnameVerifier</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(String hostname, SSLSession session)</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hostname.equals(<span class="string">&quot;www.dtasecurity.cn&quot;</span>))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> builder.build();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(String url, Map&lt;String, String&gt; params, Callback callback)</span> &#123;</span><br><span class="line">        FormBody.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder();</span><br><span class="line">        <span class="keyword">for</span> (String key : params.keySet())&#123;</span><br><span class="line">            builder.add(key,params.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">FormBody</span> <span class="variable">body</span> <span class="operator">=</span> builder.build();</span><br><span class="line"></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .post(body)</span><br><span class="line">                .build();</span><br><span class="line">        getClient().newCall(request).enqueue(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加载本地证书</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLoading)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isLoading = <span class="literal">true</span>;</span><br><span class="line">        Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">classify</span> <span class="operator">=</span> <span class="string">&quot;yzmn&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis()+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        params.put(<span class="string">&quot;classify&quot;</span>,classify);</span><br><span class="line">        params.put(<span class="string">&quot;pageNum&quot;</span>,page+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        params.put(<span class="string">&quot;limit&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">        params.put(<span class="string">&quot;timestamp&quot;</span>,timestamp);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> md5(classify+page+timestamp);</span><br><span class="line">        params.put(<span class="string">&quot;sign&quot;</span>,sign);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             in_cer = getAssets().open(<span class="string">&quot;wallpaper.cer&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        OkHttpUtil.post(<span class="string">&quot;https://www.baidu.com&quot;</span>,</span><br><span class="line">                params,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> IOException e)</span> &#123;</span><br><span class="line">                        isLoading = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">responseText</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">                        <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;ResponseEntity&lt;WallPaperEntity&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">                        ResponseEntity&lt;WallPaperEntity&gt; data = <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(responseText, responseType);</span><br><span class="line">                        wallPaperEntityList.addAll(data.getData());</span><br><span class="line">                        <span class="comment">//adapter.notifyDataSetChanged();</span></span><br><span class="line">                        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">                        msg.what = <span class="number">1</span>;</span><br><span class="line">                        handler.sendMessage(msg);</span><br><span class="line">                        isLoading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        page++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220405121345297.png" alt="image-20220405121345297"></p>
<p>抓包</p>
<img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220405121748804.png" alt="image-20220405121748804" style="zoom:150%;">

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>抓包原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Adb命令使用</title>
    <url>/2022/04/23/Adb%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>adb常用命令总结</p>
<span id="more"></span>

<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt;</span><br></pre></td></tr></table></figure>

<p>如果只有一个设备&#x2F;模拟器连接时，可以省略掉 <code>[-d|-e|-s &lt;serialNumber&gt;]</code> 这一部分，直接使用 adb <code>command</code></p>
<h2 id="指定目标设备"><a href="#指定目标设备" class="headerlink" title="指定目标设备"></a>指定目标设备</h2><p>如果有多个设备&#x2F;模拟器连接，则需要为命令指定目标设备。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>指定当前唯一通过usb连接的Android设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td>指定当前唯一通过usb连接的Android设备为命令目标</td>
</tr>
<tr>
<td>-s<serialNumber></serialNumber></td>
<td>指定相应seriaNumber号的设备&#x2F;模拟器为命令目标</td>
</tr>
</tbody></table>
<p>在多个设备&#x2F;模拟器连接的情况下较常用的是 -s <serialNumber> 参数，serialNumber 可以通过 adb devices 命令获取。</serialNumber></p>
<h2 id="启动-x2F-停止"><a href="#启动-x2F-停止" class="headerlink" title="启动&#x2F;停止"></a>启动&#x2F;停止</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb start-server</span><br><span class="line">adb kill-server</span><br></pre></td></tr></table></figure>

<h2 id="adb版本信息"><a href="#adb版本信息" class="headerlink" title="adb版本信息"></a>adb版本信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb version</span><br></pre></td></tr></table></figure>

<h2 id="以root权限运行adbd"><a href="#以root权限运行adbd" class="headerlink" title="以root权限运行adbd"></a>以root权限运行adbd</h2><p>adb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。</p>
<p>所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。</p>
<p><strong>命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br></pre></td></tr></table></figure>

<p>正常输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">restarting adbd as root</span><br></pre></td></tr></table></figure>

<p>有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行,此时可以先安装 adbd Insecure，然后 adb root 试试.</p>
<p>相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。</p>
<h2 id="指定-adb-server-的网络端口"><a href="#指定-adb-server-的网络端口" class="headerlink" title="指定 adb server 的网络端口"></a>指定 adb server 的网络端口</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb -P &lt;port&gt; start-server</span><br></pre></td></tr></table></figure>

<p>默认端口为5037</p>
<h1 id="设备连接管理"><a href="#设备连接管理" class="headerlink" title="设备连接管理"></a>设备连接管理</h1><h2 id="查询已连接设备-x2F-模拟器"><a href="#查询已连接设备-x2F-模拟器" class="headerlink" title="查询已连接设备&#x2F;模拟器"></a>查询已连接设备&#x2F;模拟器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">cf264b8f	device</span><br><span class="line">emulator-5554	device</span><br><span class="line">10.129.164.6:5555	device</span><br></pre></td></tr></table></figure>

<p>输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种：</p>
<ul>
<li>offline —— 表示设备未连接成功或无响应。</li>
<li>device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。</li>
<li>no device —— 没有设备&#x2F;模拟器连接。</li>
</ul>
<p>常见异常输出：</p>
<ol>
<li>没有设备&#x2F;模拟器连接成功。List of devices attached </li>
<li>设备&#x2F;模拟器未连接到 adb 或无响应。List of devices attached cf264b8f offline</li>
</ol>
<h2 id="USB连接"><a href="#USB连接" class="headerlink" title="USB连接"></a>USB连接</h2><p>通过 USB 连接来正常使用 adb 需要保证几点：</p>
<ol>
<li>硬件状态正常。包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。</li>
<li>Android 设备的开发者选项和 USB 调试模式已开启。可以到「设置」-「开发者选项」-「Android 调试」查看。如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。</li>
<li>设备驱动状态正常。这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。</li>
<li>通过 USB 线连接好电脑和设备后确认状态。adb devices 如果能看到xxxxxx device 说明连接成功。</li>
</ol>
<h2 id="无线连接"><a href="#无线连接" class="headerlink" title="无线连接"></a>无线连接</h2><p>工具：wifi adb</p>
<p><strong>Android11 及以上</strong></p>
<p><a href="https://developer.android.com/studio/command-line/adb?hl=zh_cn#connect-to-a-device-over-wi-fi-android-11+">官方文档</a></p>
<p><strong>操作步骤：</strong></p>
<ol>
<li>更新到最新版本的 <a href="https://developer.android.com/studio/releases/platform-tools?hl=zh_cn">SDK 平台工具</a>(至少30.0.0)。</li>
<li>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</li>
<li>在开发者选项中启用无线调试。</li>
<li>在询问要允许在此网络上进行无线调试吗？的对话框中，点击允许。</li>
<li>选择使用配对码配对设备，使用弹窗中的 IP 地址和端口号。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pair ipaddr:port</span><br></pre></td></tr></table></figure>

<ol>
<li>提示Enter pairing code: 时输入弹窗中的配对码，成功后会显示Successfully paired to …。</li>
<li>使用无线调试下的 IP 地址和端口。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb connect ipaddr:port</span><br></pre></td></tr></table></figure>

<h2 id="无线连接（需要借助-USB-线）"><a href="#无线连接（需要借助-USB-线）" class="headerlink" title="无线连接（需要借助 USB 线）"></a>无线连接（需要借助 USB 线）</h2><p>操作步骤：</p>
<ol>
<li>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</li>
<li>将设备与电脑通过 USB 线连接。应确保连接成功（可运行 adb devices 看是否能列出该设备）。</li>
<li>让设备在 5555 端口监听 TCP&#x2F;IP 连接：adb tcpip 5555</li>
<li>断开 USB 连接。</li>
<li>找到设备的 IP 地址。一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 <a href="https://mazhuang.org/awesome-adb/#ip-%E5%9C%B0%E5%9D%80">查看设备信息 – IP 地址</a> 一节里的方法用 adb 命令来查看。</li>
<li>通过 IP 地址连接设备。adb connect <code>device-ip-address</code> 这里的 <code>device-ip-address</code> 就是上一步中找到的设备 IP 地址。</li>
<li>确认连接状态。adb devices 如果能看到<code>device-ip-address</code>:5555 device 说明连接成功。</li>
</ol>
<h2 id="断开无线连接"><a href="#断开无线连接" class="headerlink" title="断开无线连接"></a>断开无线连接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb disconnect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure>

<h2 id="无线连接（无需借助-USB-线）"><a href="#无线连接（无需借助-USB-线）" class="headerlink" title="无线连接（无需借助 USB 线）"></a>无线连接（无需借助 USB 线）</h2><ol>
<li>在 Android 设备上安装一个终端模拟器, 下载地址是：<a href="https://jackpal.github.io/Android-Terminal-Emulator/">Terminal Emulator for Android Downloads</a></li>
<li>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</li>
<li>打开 Android 设备上的终端模拟器，在里面依次运行命令：su setprop service.adb.tcp.port 5555</li>
<li>找到 Android 设备的 IP 地址</li>
<li>在电脑上通过 adb 和 IP 地址连接 Android 设备。adb connect <device-ip-address> 这里的 <device-ip-address> 就是上一步中找到的设备 IP 地址。如果能看到 connected to <device-ip-address>:5555 这样的输出则表示连接成功。</device-ip-address></device-ip-address></device-ip-address></li>
</ol>
<p>有的设备，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">restart adbd</span><br></pre></td></tr></table></figure>

<p>如果 restart 无效，尝试以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop adbd</span><br><span class="line">start adbd</span><br></pre></td></tr></table></figure>

<h1 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h1><h2 id="查看应用列表"><a href="#查看应用列表" class="headerlink" title="查看应用列表"></a>查看应用列表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]</span><br></pre></td></tr></table></figure>

<p>即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>所有应用</td>
</tr>
<tr>
<td>-f</td>
<td>显示应用关联的apk文件</td>
</tr>
<tr>
<td>-d</td>
<td>只显示disabled的应用</td>
</tr>
<tr>
<td>-e</td>
<td>只显示enabled的应用</td>
</tr>
</tbody></table>
<p>|-s|只显示系统应用<br>|-3|只显示第三方应用<br>|-i|显示应用的installer<br>|-u|包含已卸载应用<br>|<code>&lt;FILTER&gt;</code>|包名包含<code>FILTER</code>字符串</p>
<h2 id="所有应用"><a href="#所有应用" class="headerlink" title="所有应用"></a>所有应用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/23/Adb%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/bb94afa39454613438e514045db02fab86275693361396c6eab47e657aa04c85.png" alt="图 1">  </p>
<h2 id="系统应用"><a href="#系统应用" class="headerlink" title="系统应用"></a>系统应用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -s</span><br></pre></td></tr></table></figure>

<h2 id="第三方应用"><a href="#第三方应用" class="headerlink" title="第三方应用"></a>第三方应用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -3</span><br></pre></td></tr></table></figure>

<h2 id="包含某种字符串的应用"><a href="#包含某种字符串的应用" class="headerlink" title="包含某种字符串的应用"></a>包含某种字符串的应用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages zhoushan</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/23/Adb%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/36f8ad08bd7543a6755e2822edad60cce62c8b46e83c99ef6e1e6b07fd2973aa.png" alt="图 2">  </p>
<p>使用grep过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages | grep zhoushan</span><br></pre></td></tr></table></figure>

<h2 id="安装apk"><a href="#安装apk" class="headerlink" title="安装apk"></a>安装apk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb install [-lrtsdg] &lt;path_to_apk&gt;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>将应用安装到保护目录&#x2F;mnt&#x2F;asec</td>
</tr>
<tr>
<td>-r</td>
<td>允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td>允许安装AndroidManifest.xml里application指定android:testOnly&#x3D;”true”的应用</td>
</tr>
<tr>
<td>-s</td>
<td>将应用安装到sdcard</td>
</tr>
<tr>
<td>-d</td>
<td>允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td>授予所有运行时权限</td>
</tr>
<tr>
<td>-abi abi-identifier</td>
<td>为特定ABI强制安装apk,abi-identifier可以是armeabi-v7a,arm64-v8a,v86,x86_64等</td>
</tr>
</tbody></table>
<p>安装成功提示：“Success”</p>
<p>常见安装失败输出代码、含义</p>
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>INSTALL_FAILED_ALREADY_EXISTS</td>
<td>应用已经存在，或卸载了但没卸载干净</td>
<td><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_APK</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_URI</td>
<td>无效的 APK 文件名</td>
<td>确保 APK 文件名里无中文</td>
</tr>
<tr>
<td>INSTALL_FAILED_INSUFFICIENT_STORAGE</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PACKAGE</td>
<td>已经存在同名程序</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_SHARED_USER</td>
<td>请求的共享用户不存在</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UPDATE_INCOMPATIBLE</td>
<td>以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</td>
<td>先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td>
<td>请求的共享用户存在但签名不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_SHARED_LIBRARY</td>
<td>安装包使用了设备上不可用的共享库</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_REPLACE_COULDNT_DELETE</td>
<td>替换时无法删除</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DEXOPT</td>
<td>dex 优化验证失败或空间不足</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_OLDER_SDK</td>
<td>设备系统版本低于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONFLICTING_PROVIDER</td>
<td>设备里已经存在与应用里同名的 content provider</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NEWER_SDK</td>
<td>设备系统版本高于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td>
<td>包含不兼容设备 CPU 应用程序二进制接口的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_FEATURE</td>
<td>应用使用了设备不可用的功能</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONTAINER_ERROR</td>
<td>1. sdcard 访问失败;<br> 2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 确认 sdcard 可用，或者安装到内置存储;<br>2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_INSTALL_LOCATION</td>
<td>1. 不能安装到指定位置;<br>2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 切换安装位置，添加或删除 <code>-s</code> 参数;<br>2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_MEDIA_UNAVAILABLE</td>
<td>安装位置不可用</td>
<td>一般为 sdcard，确认 sdcard 可用或安装到内置存储</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_TIMEOUT</td>
<td>验证安装包超时</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_FAILURE</td>
<td>验证安装包失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_PACKAGE_CHANGED</td>
<td>应用与调用程序期望的不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UID_CHANGED</td>
<td>以前安装过该应用，与本次分配的 UID 不一致</td>
<td>清除以前安装过的残留文件</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERSION_DOWNGRADE</td>
<td>已经安装了该应用更高版本</td>
<td>使用 <code>-d</code> 参数</td>
</tr>
<tr>
<td>INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td>
<td>已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NOT_APK</td>
<td>指定路径不是文件，或不是以 <code>.apk</code> 结尾</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_MANIFEST</td>
<td>无法解析的 AndroidManifest.xml 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td>
<td>解析器遇到异常</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NO_CERTIFICATES</td>
<td>安装包没有签名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td>
<td>已安装该应用，且签名与 APK 文件不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td>
<td>解析 APK 文件时遇到 <code>CertificateEncodingException</code></td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td>
<td>manifest 文件里没有或者使用了无效的包名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td>
<td>manifest 文件里指定了无效的共享用户 ID</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td>
<td>解析 manifest 文件时遇到结构性错误</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td>
<td>在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INTERNAL_ERROR</td>
<td>因系统问题安装失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_USER_RESTRICTED</td>
<td>用户被限制安装应用</td>
<td>在开发者选项里将「USB安装」打开，如果已经打开了，那先关闭再打开。</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PERMISSION</td>
<td>应用尝试定义一个已经存在的权限名称</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_MATCHING_ABIS</td>
<td>应用包含设备的应用程序二进制接口不支持的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_CANCELED_BY_USER</td>
<td>应用安装需要在设备上确认，但未操作设备或点了取消</td>
<td>在设备上同意安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_ACWF_INCOMPATIBLE</td>
<td>应用程序与设备不兼容</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>APK 文件是使用 Android Studio 直接 RUN 编译出来的文件</td>
<td>通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK</td>
</tr>
<tr>
<td>does not contain AndroidManifest.xml</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>is not a valid zip file</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>Offline</td>
<td>设备未连接成功</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>unauthorized</td>
<td>设备未授权允许调试</td>
<td></td>
</tr>
<tr>
<td>error: device not found</td>
<td>没有连接成功的设备</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>protocol failure</td>
<td>设备已断开连接</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>Unknown option: -s</td>
<td>Android 2.2 以下不支持安装到 sdcard</td>
<td>不使用 <code>-s</code> 参数</td>
</tr>
<tr>
<td>No space left on device</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>Permission denied … sdcard …</td>
<td>sdcard 不可用</td>
<td></td>
</tr>
<tr>
<td>signatures do not match the previously installed version; ignoring!</td>
<td>已安装该应用且签名不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
</tbody></table>
<p>adb install 原理：</p>
<ol>
<li>push apk 文件到 &#x2F;data&#x2F;local&#x2F;tmp</li>
<li>调用pm install 安装</li>
<li>删除&#x2F;data&#x2F;lcoal&#x2F;tmp下的对应的apk文件</li>
</ol>
<p>所以，必要的时候也可以根据这个步骤，手动分步执行安装过程</p>
<h2 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb uninstall [-k] &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p>packagename 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。</p>
<h2 id="清除应用数据与缓存"><a href="#清除应用数据与缓存" class="headerlink" title="清除应用数据与缓存"></a>清除应用数据与缓存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm clear &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p>这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p>
<h2 id="查看前台Activity"><a href="#查看前台Activity" class="headerlink" title="查看前台Activity"></a>查看前台Activity</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity activities | grep mResumedActivity</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/23/Adb%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/48062d4dd498432f5d55f30ce6f4ab298b208dfe4c1fd3ece3d2fb34db756f90.png" alt="图 3">  </p>
<h2 id="查看正在运行的Services"><a href="#查看正在运行的Services" class="headerlink" title="查看正在运行的Services"></a>查看正在运行的Services</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity services [&lt;packagename&gt;]</span><br></pre></td></tr></table></figure>

<p>packagename 参数不是必须的，指定 packagename表示查看与某个包名相关的 Services，不指定表示查看所有 Services。<br>packagename 不一定要给出完整的包名，比如运行 adb shell dumpsys activity services org.mazhuang，那么包名 org.mazhuang.demo1、org.mazhuang.demo2 和 org.mazhuang123 等相关的 Services 都会列出来。</p>
<h2 id="查看应用详细信息"><a href="#查看应用详细信息" class="headerlink" title="查看应用详细信息"></a>查看应用详细信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys package &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p>输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。</p>
<h2 id="查看应用安装路径"><a href="#查看应用安装路径" class="headerlink" title="查看应用安装路径"></a>查看应用安装路径</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm path &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<h1 id="应用交互"><a href="#应用交互" class="headerlink" title="应用交互"></a>应用交互</h1><p>主要是使用 am <code>command</code> 命令，常用的 <code>command</code> 如下：</p>
<table>
<thead>
<tr>
<th>command</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>start [options] <code>INTENT</code></td>
<td>启动 <code>INTENT</code> 指定的 Activity</td>
</tr>
<tr>
<td>startservice [options] <code>INTENT</code></td>
<td>启动 <code>INTENT</code> 指定的 Service</td>
</tr>
<tr>
<td>broadcast [options] <code>INTENT</code></td>
<td>发送 <code>INTENT</code> 指定的广播</td>
</tr>
<tr>
<td>force-stop <code>packagename</code></td>
<td>停止 <code>packagename</code> 相关的进程</td>
</tr>
</tbody></table>
<p><code>INTENT</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。<br>用于决定 intent 对象的选项如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-a <code>ACTION</code></td>
<td>指定 action，比如 android.intent.action.VIEW</td>
</tr>
<tr>
<td>-c <code>CATEGORY</code></td>
<td>指定 category，比如 android.intent.category.APP_CONTACTS</td>
</tr>
<tr>
<td>-n <code>COMPONENT</code></td>
<td>指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app&#x2F;.ExampleActivity</td>
</tr>
</tbody></table>
<p><code>INTENT</code> 里还能带数据，就像写代码时的 Bundle 一样：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>–esn <code>EXTRA_KEY</code></td>
<td>null 值（只有 key 名</td>
</tr>
<tr>
<td>-e l –es <code>EXTRA_KEY</code> <code>EXTRA_STRING_VALUE</code></td>
<td>string 值</td>
</tr>
<tr>
<td>–ez <code>EXTRA_KEY</code> <code>EXTRA_BOOLEAN_VALUE</code></td>
<td>boolean 值</td>
</tr>
<tr>
<td>–ei <code>EXTRA_KEY</code> <code>EXTRA_INT_VALUE</code></td>
<td>integer 值</td>
</tr>
<tr>
<td>–el <code>EXTRA_KEY</code> <code>EXTRA_LONG_VALUE</code></td>
<td>long 值</td>
</tr>
<tr>
<td>–ef <code>EXTRA_KEY</code> <code>EXTRA_FLOAT_VALUE</code></td>
<td>float 值</td>
</tr>
<tr>
<td>–eu <code>EXTRA_KEY</code> <code>EXTRA_URI_VALUE</code></td>
<td>URI</td>
</tr>
<tr>
<td>–ecn <code>EXTRA_KEY</code> <code>EXTRA_COMPONENT_NAME_VALUE</code></td>
<td>component name</td>
</tr>
<tr>
<td>–eia <code>EXTRA_KEY</code> <code>EXTRA_INT_VALUE</code>[,&lt;EXTRA_INT_VALUE…]</td>
<td>integer 数组</td>
</tr>
<tr>
<td>–ela <code>EXTRA_KEY</code> <code>EXTRA_LONG_VALUE</code>[,&lt;EXTRA_LONG_VALUE…]</td>
<td>long 数组</td>
</tr>
</tbody></table>
<h2 id="启动应用-x2F-调起Activity"><a href="#启动应用-x2F-调起Activity" class="headerlink" title="启动应用&#x2F;调起Activity"></a>启动应用&#x2F;调起Activity</h2><p>指定Activity名称启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<p>Options 说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-D</td>
<td>开启debug模式</td>
</tr>
<tr>
<td>-W</td>
<td>等待启动完成</td>
</tr>
<tr>
<td>–start-profile<code>FILE</code></td>
<td>将profile中的结果输出到指定文件中</td>
</tr>
<tr>
<td>-P</td>
<td>和上一条一样，区别在于，在app进入idle状态时profiler结束</td>
</tr>
<tr>
<td>-R <code>Count</code></td>
<td>重复启动Activity，但每次重复启动都会关闭掉最上面的Activity</td>
</tr>
<tr>
<td>-S</td>
<td>关闭Activity所属的APP进程后再启动Activity</td>
</tr>
<tr>
<td>–opengl-trace</td>
<td>开启openGL tracing</td>
</tr>
<tr>
<td>–user <code>user_ID</code></td>
<td>使用指定的用户来启动activity，如果不输入，则使用当前用户执行</td>
</tr>
</tbody></table>
<p>启动Activity的实现原理： 存在-W参数则调用startActivityAndWait()方法来运行，否则startActivityAsUser()。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start -n com.tencent.mm/.ui.LauncherUI</span><br></pre></td></tr></table></figure>

<p>表示调起微信主界面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es &quot;toast&quot; &quot;hello, world&quot;</span><br></pre></td></tr></table></figure>

<p>表示调起 org.mazhuang.boottimemeasure&#x2F;.MainActivity 并传给它 string 数据键值对 toast - hello, world。</p>
<p>不指定Activity名称启动（启动主Activity）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p &lt;packagename&gt; -c android.intent.category.LAUNCHER 1</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p com.tencent.mm -c android.intent.category.LAUNCHER 1</span><br></pre></td></tr></table></figure>

<p>表示调起微信主界面。</p>
<h2 id="调起Service"><a href="#调起Service" class="headerlink" title="调起Service"></a>调起Service</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am startservice [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService</span><br></pre></td></tr></table></figure>

<p>表示调起微信的某 Service。<br>另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am startservice -n com.android.systemui/.SystemUIService</span><br></pre></td></tr></table></figure>

<h2 id="停止service"><a href="#停止service" class="headerlink" title="停止service"></a>停止service</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am stopservice [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<h2 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<p>可以向所有组件广播，也可以只向指定组件广播。<br>例如，向所有组件广播 BOOT_COMPLETED：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</span><br></pre></td></tr></table></figure>

<p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。<br>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td>网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td>屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td>屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td>电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td>电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td>设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td>存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td>存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td>安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td>WiFi 连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td>WiFi 状态变为启用&#x2F;关闭&#x2F;正在启动&#x2F;正在关闭&#x2F;未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td>电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td>系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td>外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td>外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td>系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td>系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.WALLPAPER_CHANGED</td>
<td>壁纸发生变化</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td>插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td>卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td>挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td>省电模式开启</td>
</tr>
</tbody></table>
<p>（以上广播均可使用 adb 触发）</p>
<h2 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am force-stop &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="复制设备里的文件到电脑"><a href="#复制设备里的文件到电脑" class="headerlink" title="复制设备里的文件到电脑"></a>复制设备里的文件到电脑</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull &lt;设备里的文件路径&gt; [电脑上的目录]</span><br></pre></td></tr></table></figure>

<p>其中 电脑上的目录 参数可以省略，默认复制到当前目录。</p>
<h2 id="复制电脑里的文件到设备"><a href="#复制电脑里的文件到设备" class="headerlink" title="复制电脑里的文件到设备"></a>复制电脑里的文件到设备</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;</span><br></pre></td></tr></table></figure>

<h1 id="模拟按键-x2F-输入"><a href="#模拟按键-x2F-输入" class="headerlink" title="模拟按键&#x2F;输入"></a>模拟按键&#x2F;输入</h1><p>在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。</p>
<p>input 命令的完整 help 信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sailfish:/ $ input</span><br><span class="line">Usage: input [&lt;source&gt;] [-d DISPLAY_ID] &lt;command&gt; [&lt;arg&gt;...]</span><br><span class="line"></span><br><span class="line">The sources are: </span><br><span class="line">      dpad</span><br><span class="line">      keyboard</span><br><span class="line">      mouse</span><br><span class="line">      touchpad</span><br><span class="line">      gamepad</span><br><span class="line">      touchnavigation</span><br><span class="line">      joystick</span><br><span class="line">      touchscreen</span><br><span class="line">      stylus</span><br><span class="line">      trackball</span><br><span class="line"></span><br><span class="line">-d: specify the display ID.</span><br><span class="line">      (Default: -1 for key event, 0 for motion event if not specified.)</span><br><span class="line">The commands and default sources are:</span><br><span class="line">      text &lt;string&gt; (Default: touchscreen)</span><br><span class="line">      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)</span><br><span class="line">      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)</span><br><span class="line">      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</span><br><span class="line">      draganddrop &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</span><br><span class="line">      press (Default: trackball)</span><br><span class="line">      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)</span><br><span class="line">      event &lt;DOWN|UP|MOVE&gt; &lt;x&gt; &lt;y&gt; (Default: touchscreen)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如使用 adb shell input keyevent keycode命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 <a href="https://developer.android.com/reference/android/view/KeyEvent.html">KeyEvent</a>，摘引部分我觉得有意思的如下：</p>
<table>
<thead>
<tr>
<th>keycode</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>26</td>
<td>电源键</td>
</tr>
<tr>
<td>176</td>
<td>打开系统设置</td>
</tr>
<tr>
<td>210</td>
<td>打开计算器</td>
</tr>
<tr>
<td>223</td>
<td>系统休眠</td>
</tr>
<tr>
<td>224</td>
<td>点亮屏幕</td>
</tr>
</tbody></table>
<p>用列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 26</span><br></pre></td></tr></table></figure>

<p>执行效果相当于按电源键。</p>
<h2 id="滑动解锁"><a href="#滑动解锁" class="headerlink" title="滑动解锁"></a>滑动解锁</h2><p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。</p>
<p>命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input swipe 300 1000 300 500</span><br></pre></td></tr></table></figure>

<p>参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。</p>
<h2 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h2><p>在焦点处于某文本框时，可以通过 input 命令来输入文本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input text hello</span><br></pre></td></tr></table></figure>

<h1 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h1><p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 &#x2F;proc&#x2F;kmsg，Android 的日志输出到 &#x2F;dev&#x2F;log。</p>
<h2 id="Android日志"><a href="#Android日志" class="headerlink" title="Android日志"></a>Android日志</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...</span><br></pre></td></tr></table></figure>

<h2 id="按级别过滤日志"><a href="#按级别过滤日志" class="headerlink" title="按级别过滤日志"></a>按级别过滤日志</h2><p>Android 的日志分为如下几个优先级（priority）：</p>
<ul>
<li>V —— Verbose（最低，输出得最多）</li>
<li>D —— Debug</li>
<li>I —— Info</li>
<li>W —— Warning</li>
<li>E —— Error</li>
<li>F —— Fatal</li>
<li>S —— Silent（最高，啥也不输出）</li>
</ul>
<p>按某级别过滤日志则会将该级别及以上的日志输出。</p>
<p>比如，命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat *:W</span><br></pre></td></tr></table></figure>

<p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p>
<h2 id="按tag和级别过滤日志"><a href="#按tag和级别过滤日志" class="headerlink" title="按tag和级别过滤日志"></a>按tag和级别过滤日志</h2><p><code>filter-spec</code> 可以由多个 <code>tag</code>[:priority] 组成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat ActivityManager:I MyApp:D *:S</span><br></pre></td></tr></table></figure>

<p>表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p>
<h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p>可以用 adb logcat -v <code>format</code> 选项指定日志输出格式。</p>
<p>日志支持按以下几种 <code>format</code>：</p>
<ul>
<li>brief默认格式。格式为：<code>priority</code>&#x2F;<code>tag</code>(<code>pid</code>): <code>message</code> 示例：D&#x2F;HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0</li>
<li>process格式为：<code>priority</code>(<code>pid</code>) <code>message</code> 示例：D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine)</li>
<li>tag格式为：<code>priority</code>&#x2F;<code>tag</code>: <code>message</code> 示例：D&#x2F;HeadsetStateMachine: Disconnected process message: 10, size: 0</li>
<li>raw格式为：<code>message</code> 示例：Disconnected process message: 10, size: 0</li>
<li>time格式为：<code>datetime</code> <code>priority</code>&#x2F;<code>tag</code>(<code>pid</code>): <code>message</code> 示例：08-28 22:39:39.974 D&#x2F;HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0</li>
<li>threadtime格式为：<code>datetime</code> <code>pid</code> <code>tid</code> <code>priority</code> <code>tag</code>: <code>message</code> 示例：08-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0</li>
<li>long格式为：[ <code>datetime</code> <code>pid</code>:<code>tid</code> <code>priority</code>&#x2F;<code>tag</code> ] <code>message</code> 示例：[ 08-28 22:39:39.974 1785: 1832 D&#x2F;HeadsetStateMachine ] Disconnected process message: 10, size: 0</li>
</ul>
<p>指定格式可与上面的过滤同时使用。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat -v long ActivityManager:I *:S</span><br></pre></td></tr></table></figure>

<h2 id="清空日志"><a href="#清空日志" class="headerlink" title="清空日志"></a>清空日志</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat -c</span><br></pre></td></tr></table></figure>

<h2 id="内核日志"><a href="#内核日志" class="headerlink" title="内核日志"></a>内核日志</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dmesg</span><br></pre></td></tr></table></figure>

<h1 id="查看设备信息"><a href="#查看设备信息" class="headerlink" title="查看设备信息"></a>查看设备信息</h1><h2 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.product.model</span><br></pre></td></tr></table></figure>

<h2 id="电池状况"><a href="#电池状况" class="headerlink" title="电池状况"></a>电池状况</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys battery</span><br></pre></td></tr></table></figure>

<h2 id="android-id"><a href="#android-id" class="headerlink" title="android_id"></a>android_id</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings get secure android_id</span><br></pre></td></tr></table></figure>

<h2 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">service call iphonesubinfo 1</span><br></pre></td></tr></table></figure>

<h2 id="Android-系统版本"><a href="#Android-系统版本" class="headerlink" title="Android 系统版本"></a>Android 系统版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure>

<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ifconfig | grep Mask</span><br></pre></td></tr></table></figure>

<h2 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cat /sys/class/net/wlan0/address</span><br></pre></td></tr></table></figure>

<h2 id="CPU-信息"><a href="#CPU-信息" class="headerlink" title="CPU 信息"></a>CPU 信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<h2 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cat /proc/meminfo</span><br></pre></td></tr></table></figure>

<h2 id="更多硬件与系统属性"><a href="#更多硬件与系统属性" class="headerlink" title="更多硬件与系统属性"></a>更多硬件与系统属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cat /system/build.prop</span><br></pre></td></tr></table></figure>

<p>这会输出很多信息,它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ro.build.version.sdk</td>
<td>SDK 版本</td>
</tr>
<tr>
<td>ro.build.version.release</td>
<td>Android 系统版本</td>
</tr>
<tr>
<td>ro.build.version.security_patch</td>
<td>Android 安全补丁程序级别</td>
</tr>
<tr>
<td>ro.product.model</td>
<td>型号</td>
</tr>
<tr>
<td>ro.product.brand</td>
<td>品牌</td>
</tr>
<tr>
<td>ro.product.name</td>
<td>设备名</td>
</tr>
<tr>
<td>ro.product.board</td>
<td>处理器型号</td>
</tr>
<tr>
<td>ro.product.cpu.abilist</td>
<td>CPU 支持的 abi 列表</td>
</tr>
<tr>
<td>persist.sys.isUsbOtgEnabled</td>
<td>是否支持 OTG</td>
</tr>
<tr>
<td>dalvik.vm.heapsize</td>
<td>每个应用程序的内存上限</td>
</tr>
<tr>
<td>ro.sf.lcd_density</td>
<td>屏幕密度</td>
</tr>
</tbody></table>
<p>一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 ro.product.cpu.abilist 属性名查找不到，可以这样试试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cat /system/build.prop | grep ro.product.cpu.abi</span><br></pre></td></tr></table></figure>

<h1 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h1><p>修改设置的原理主要是通过 settings 命令修改 &#x2F;data&#x2F;data&#x2F;com.android.providers.settings&#x2F;databases&#x2F;settings.db 里存放的设置值。</p>
<h2 id="关闭-USB-调试模式"><a href="#关闭-USB-调试模式" class="headerlink" title="关闭 USB 调试模式"></a>关闭 USB 调试模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put global adb_enabled 0</span><br></pre></td></tr></table></figure>

<h2 id="允许-x2F-禁止访问非-SDK-API"><a href="#允许-x2F-禁止访问非-SDK-API" class="headerlink" title="允许&#x2F;禁止访问非 SDK API"></a>允许&#x2F;禁止访问非 SDK API</h2><p><strong>允许访问非 SDK API：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put global hidden_api_policy_pre_p_apps 1</span><br><span class="line">adb shell settings put global hidden_api_policy_p_apps 1</span><br></pre></td></tr></table></figure>

<p><strong>禁止访问非 SDK API：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings delete global hidden_api_policy_pre_p_apps</span><br><span class="line">adb shell settings delete global hidden_api_policy_p_apps</span><br></pre></td></tr></table></figure>

<p>不需要设备获得 Root 权限。</p>
<p>命令最后的数字的含义：</p>
<table>
<thead>
<tr>
<th>指</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。</td>
</tr>
<tr>
<td>1</td>
<td>仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。</td>
</tr>
<tr>
<td>2</td>
<td>禁止调用深灰名单和黑名单中的接口。</td>
</tr>
<tr>
<td>3</td>
<td>禁止调用黑名单中的接口，但允许调用深灰名单中的接口。</td>
</tr>
</tbody></table>
<h2 id="状态栏和导航栏的显示隐藏"><a href="#状态栏和导航栏的显示隐藏" class="headerlink" title="状态栏和导航栏的显示隐藏"></a>状态栏和导航栏的显示隐藏</h2><p>本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control &lt;key-values&gt;</span><br></pre></td></tr></table></figure>

<p><code>key-values</code> 可由如下几种键及其对应的值组成，格式为 <code>key1</code>&#x3D;<code>value1</code>:<code>key2</code>&#x3D;<code>value2</code>。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>immersive.full</td>
<td>同时隐藏</td>
</tr>
<tr>
<td>immersive.status</td>
<td>隐藏状态栏</td>
</tr>
<tr>
<td>immersive.navigation</td>
<td>隐藏导航栏</td>
</tr>
<tr>
<td>immersive.preconfirms</td>
<td>?</td>
</tr>
</tbody></table>
<p>这些键对应的值可则如下值用逗号组合：</p>
<table>
<thead>
<tr>
<th>value</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>apps</td>
<td>所有应用</td>
</tr>
<tr>
<td>*</td>
<td>所有界面</td>
</tr>
<tr>
<td>packagename</td>
<td>指定应用</td>
</tr>
<tr>
<td>-packagename</td>
<td>排除指定应用</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.full=*</span><br></pre></td></tr></table></figure>

<p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3</span><br></pre></td></tr></table></figure>

<p>表示设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。</p>
<h1 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h1><h2 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h2><p>截图保存到电脑当前位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb exec-out screencap -p &gt; sc.png</span><br></pre></td></tr></table></figure>

<p>先截图保存到设备里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/sc.png</span><br></pre></td></tr></table></figure>

<p>然后将 png 文件导出到电脑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/sc.png</span><br></pre></td></tr></table></figure>

<p>可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>指定保存文件为 png 格式</td>
</tr>
<tr>
<td>-d display-id</td>
<td>指定截图的显示屏编号（有多显示屏的情况下）</td>
</tr>
</tbody></table>
<p>实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p>
<p>另外一种一行命令截图并保存到电脑的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p | sed &quot;s/\r$//&quot; &gt; sc.png</span><br></pre></td></tr></table></figure>

<h2 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/filename.mp4</span><br></pre></td></tr></table></figure>

<p>可以使用 adb shell screenrecord –help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>–size WIDTHxHEIGHT</td>
<td>视频的尺寸，比如 1280x720，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>–bit-rate RATE</td>
<td>视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>–time-limit TIME</td>
<td>录制时长，单位秒。</td>
</tr>
<tr>
<td>–verbose</td>
<td>输出更多信息。</td>
</tr>
</tbody></table>
<h2 id="查看连接过的-WiFi-密码"><a href="#查看连接过的-WiFi-密码" class="headerlink" title="查看连接过的 WiFi 密码"></a>查看连接过的 WiFi 密码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cat /data/misc/wifi/*.conf</span><br></pre></td></tr></table></figure>

<p>如果 Android O 或以后，WiFi 密码保存的地址有变化，是在 WifiConfigStore.xml 里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cat /data/misc/wifi/WifiConfigStore.xml</span><br></pre></td></tr></table></figure>

<h2 id="使用-Monkey-进行压力测试"><a href="#使用-Monkey-进行压力测试" class="headerlink" title="使用 Monkey 进行压力测试"></a>使用 Monkey 进行压力测试</h2><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<p>简单用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p &lt;packagename&gt; -v 500</span><br></pre></td></tr></table></figure>

<p>表示向 <code>packagename</code> 指定的应用程序发送 500 个伪随机事件。</p>
<p>Monkey 的详细用法参考 <a href="https://developer.android.com/studio/test/monkey.html">官方文档</a>。</p>
<h2 id="开启-x2F-关闭-WiFi"><a href="#开启-x2F-关闭-WiFi" class="headerlink" title="开启&#x2F;关闭 WiFi"></a>开启&#x2F;关闭 WiFi</h2><p>开启 WiFi：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi enable</span><br></pre></td></tr></table></figure>

<p>关闭 WiFi：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi disable</span><br></pre></td></tr></table></figure>

<p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。</p>
<h1 id="刷机相关"><a href="#刷机相关" class="headerlink" title="刷机相关"></a>刷机相关</h1><h2 id="重启到-Recovery-模式"><a href="#重启到-Recovery-模式" class="headerlink" title="重启到 Recovery 模式"></a>重启到 Recovery 模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure>

<h2 id="从-Recovery-重启到-Android"><a href="#从-Recovery-重启到-Android" class="headerlink" title="从 Recovery 重启到 Android"></a>从 Recovery 重启到 Android</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure>

<h2 id="重启到-Fastboot-模式"><a href="#重启到-Fastboot-模式" class="headerlink" title="重启到 Fastboot 模式"></a>重启到 Fastboot 模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure>



<h1 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h1><h2 id="启用-x2F-禁用-SELinux"><a href="#启用-x2F-禁用-SELinux" class="headerlink" title="启用&#x2F;禁用 SELinux"></a>启用&#x2F;禁用 SELinux</h2><p>启用 SELinux</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setenforce 1</span><br></pre></td></tr></table></figure>

<p>禁用 SELinux</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setenforce 0</span><br></pre></td></tr></table></figure>

<h2 id="启用-x2F-禁用-dm-verity"><a href="#启用-x2F-禁用-dm-verity" class="headerlink" title="启用&#x2F;禁用 dm_verity"></a>启用&#x2F;禁用 dm_verity</h2><p>启用 dm_verity</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb enable-verity</span><br></pre></td></tr></table></figure>

<p>禁用 dm_verity</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb disable-verity</span><br></pre></td></tr></table></figure>

<h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ps</span><br></pre></td></tr></table></figure>

<h2 id="查看实时资源占用情况"><a href="#查看实时资源占用情况" class="headerlink" title="查看实时资源占用情况"></a>查看实时资源占用情况</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell top</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/23/Adb%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/8d150b494d9f1132f7a47c58689aec70d74e4156f60ccbb8e37c8554a3ea574d.png" alt="图 1"><br>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PID</td>
<td>进程ID</td>
</tr>
<tr>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>CPU%</td>
<td>当前瞬间占用 CPU 百分比</td>
</tr>
<tr>
<td>S</td>
<td>进程状态（R&#x3D;运行，S&#x3D;睡眠，T&#x3D;跟踪&#x2F;停止，Z&#x3D;僵尸进程）</td>
</tr>
<tr>
<td>#THR</td>
<td>线程数</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>PCY</td>
<td>调度策略优先级，SP_BACKGROUND&#x2F;SPFOREGROUND</td>
</tr>
<tr>
<td>UID</td>
<td>进程所有者的用户 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody></table>
<p>top 命令还支持一些命令行参数，详细用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]</span><br><span class="line">    -m num  最多显示多少个进程</span><br><span class="line">    -n num  刷新多少次后退出</span><br><span class="line">    -d num  刷新时间间隔（单位秒，默认值 5）</span><br><span class="line">    -s col  按某列排序（可用 col 值：cpu, vss, rss, thr）</span><br><span class="line">    -t      显示线程信息</span><br><span class="line">    -h      显示帮助文档</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>cat</td>
<td>显示文件内容</td>
</tr>
<tr>
<td>cd</td>
<td>切换目录</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件的存取模式&#x2F;访问权限</td>
</tr>
<tr>
<td>df</td>
<td>查看磁盘空间使用情况</td>
</tr>
<tr>
<td>grep</td>
<td>过滤输出</td>
</tr>
<tr>
<td>kill</td>
<td>杀死指定 PID 的进程</td>
</tr>
<tr>
<td>ls</td>
<td>列举目录内容</td>
</tr>
<tr>
<td>mount</td>
<td>挂载目录的查看和管理</td>
</tr>
<tr>
<td>mv</td>
<td>移动或重命名文件</td>
</tr>
<tr>
<td>ps</td>
<td>查看正在运行的进程</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>top</td>
<td>查看进程的资源占用情况</td>
</tr>
</tbody></table>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="https://www.ddosi.org/awesome-adb/">雨苁</a></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>C++（一）</title>
    <url>/2022/03/25/C-%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>函数重载，默认参数，引用，应用传参，指针和引用的区别，C++的输入输出机制，类的声明、定义和应用，定义对象，this指针，类的构造与析构</p>
<span id="more"></span>

<h2 id="C与C-区别"><a href="#C与C-区别" class="headerlink" title="C与C++区别"></a>C与C++区别</h2><p>C++是C的扩展，C是C++的额子集，C++包括C的全部特征，属性和优点。同时增加了对面向对象编程的完全支持 </p>
<h2 id="关于堆的使用"><a href="#关于堆的使用" class="headerlink" title="关于堆的使用"></a>关于堆的使用</h2><p>C++中申请空间用的是new与delete运算符，这两个类似于c语言中的malloc于free函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new</span><br><span class="line">语法：</span><br><span class="line">        指针变量=new 数据类型；</span><br><span class="line">        指针变量=new 数据类型[长度]；</span><br><span class="line">例如：</span><br><span class="line">        <span class="type">int</span> *p; p=new <span class="type">int</span></span><br><span class="line">        <span class="type">char</span> *pstr=new <span class="type">char</span>[<span class="number">50</span>]; </span><br><span class="line">delete</span><br><span class="line">语法：c</span><br><span class="line">        delete  指针变量；</span><br><span class="line">        delete[] 指针变量；</span><br><span class="line">例如：</span><br><span class="line">        delete  p;</span><br><span class="line">        delete  []  pStr; <span class="comment">//对于数组  </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> using  namespace  <span class="built_in">std</span>;</span><br><span class="line"> <span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> *p = new  <span class="type">int</span>(<span class="number">33</span>);<span class="comment">//分配一个整数空间4字节，圆括号代表初始化值</span></span><br><span class="line">     count&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="type">int</span> * p2=new  <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//分配连续的10个整数空间40字节</span></span><br><span class="line">     delete  p;</span><br><span class="line">     delete[] p2;</span><br><span class="line">     <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针p</p>
<p><img src="/2022/03/25/C-%EF%BC%88%E4%B8%80%EF%BC%89/image-20220325150626060.png" alt="image-20220325150626060"></p>
<p>释放指针p</p>
<p><img src="/2022/03/25/C-%EF%BC%88%E4%B8%80%EF%BC%89/image-20220325150656517.png" alt="image-20220325150656517"></p>
<p>指针p2</p>
<p><img src="/2022/03/25/C-%EF%BC%88%E4%B8%80%EF%BC%89/image-20220325150730671.png" alt="image-20220325150730671"></p>
<ol>
<li>从示例中可以看出使用new申请空间并不是以字节为单位的，而是以数据类型，从而也无需强制转换 </li>
<li>要申请多个数据，需要使用了中括号，释放这块内存的时候也需要中括号 </li>
<li>注意中括号和圆括号的差别，圆括号是初始化，中括号是申请多个的意思</li>
</ol>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>相同的作用域，如果两个函数名称相同，而参数不同，我们把他们称为函数重载，函数重载又称为函数的多态性<br>一下几种方式会构成函数重载</p>
<ul>
<li>形参数量不同 </li>
<li>形参类型不同 </li>
<li>形参的顺序不同 </li>
<li>形参的数量和形参的类型都不同</li>
</ul>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>函数声明或者定义的时候，可以给形参赋一些默认值，调用函数时，若没有给出实参，则按指定的默认值进行工作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">Addition</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b, <span class="type">int</span> c=<span class="number">0</span>,<span class="type">int</span> d=<span class="number">0</span>,<span class="type">int</span> e=<span class="number">0</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span>  a+b+c+d+e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上这个例子中，调用函数的时候，可以传递两个参数，也可以传递三个，四个，五个。传递的参数不足五个的时候，后面的会默认的被传递0. </p>
<p>需要注意的问题 </p>
<ol>
<li>函数没有声明时，在函数定义中指定形参的默认值 </li>
<li>函数即又定义又有声明时，申明指定后，定义后就不能再指定默认值 </li>
<li>当使用了默认参数的同时还使用了重载容易造成二义性 </li>
<li>默认值的定义必须遵守从右到左的顺序，如果某个形参没有默认值，则它左边的参数就不能有默认值 ，函数调用时，实参与形参按从左到右的顺序进行匹配</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用是给一个变量起别名，定义引用的一般格式：<br>类型&amp;引用名&#x3D;变量名<br>int nSize;<br>int &amp;nNum&#x3D;nSize; </p>
<ol>
<li>由于引用就是变量的一个别名，因此上例中nSize的地址与nNum的地址是完全一样的 </li>
<li>定义引用时一定要初始化，指明该引用变量是谁的别名</li>
<li>引用一经初始化不能再引用其他对象 </li>
<li>不能引用常量</li>
</ol>
<h3 id="引用传参"><a href="#引用传参" class="headerlink" title="引用传参"></a>引用传参</h3><p>引用传递方式是再函数定义时在形参前面加上引用运算符“&amp;” </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：int swap(int &amp;nNumA, int &amp;nNumB); </span><br></pre></td></tr></table></figure>

<p>按值传递方式容易理解，但形参值的改变不同对实参产生影响，地址传递通过形参的改变使相应的实参改变<br>引用作为参数对形参的任何操作都能改变相应的实参的数据，又使函数调用显得方便自然</p>
<h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><p>引用访问一个变量是直接访问，而指针里面需要保存变量的地址，所以是间接访问<br>引用是一个变量的别名，本身不单独分配自己的内存空间，它不是一个单独的变量，而指针有自己的内存空间<br>引用一经初始化不能再引用其他变量，而指针可以（非const指针）<br>尽可能使用引用，不得已时使用指针 </p>
<p><strong>三种传参方式比较</strong></p>
<p><strong>值传递：</strong>实参要初始化形参要分配空间，将实参内容拷贝到形参<br><strong>指针传递：</strong>传递的是指针，能够间接修改函数外部的变量，其本质仍是值传递<br><strong>引用传递：</strong>实参初始化形参的时候不分配空间，而是形参融为一体，修改了形参就是改变了实参</p>
<h2 id="作用域符号"><a href="#作用域符号" class="headerlink" title="作用域符号"></a>作用域符号</h2><p>在C++有一个新的符号随处可见，由两个冒号<code>::</code>，它被称之为作用域符号，变量，在解决C++中变量，函数重名等问题，起到了关键的作用</p>
<h2 id="输入输出机制"><a href="#输入输出机制" class="headerlink" title="输入输出机制"></a>输入输出机制</h2><p><code>I/O</code>流是指输入输出的一系列数据流，输出使用插入操作符<code>&lt;&lt;</code>向<code>cout</code>输出流中插入字符<br>在使用<code>cout</code>和<code>cin</code>的时候，需要包含<code>iostream</code>这个头文件，并且使用<code>std</code>这个命名空间<br>输入使用抽取操作符<code>&gt;&gt;</code>从<code>cin</code>输入流中抽取字符</p>
<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>面向对象的三要素</p>
<p>对象，类和继承<br><strong>什么是对象？</strong><br>概念上:在问题空间中，将客观世界的实体称为对象，对象可以是某人，某物<br>实现上:把一系列数据和处理数据的过程(操作或方法)当成一个整体，这个封装体就称为对象<br><strong>什么是类？</strong><br>类是创建对象的样板，它包含着所创建对象的状态描述和方法的定义，对象是由特定的类创造的，某个类所创建的对象也称为这个类的实例<br><strong>什么是继承</strong><br>C++采用继承机制重用，不仅可重用具有特定功能的类，而且继承可以由已有的类创造新的类<br>新类共享已有类的属性，自己还具有额外添加的属性，新类是从已有类派生的，称为派生类或子类，已有类称为父类或基类<br>面向对象的三大特性</p>
<p>封装，继承，多态</p>
<h2 id="类的声明、定义与应用"><a href="#类的声明、定义与应用" class="headerlink" title="类的声明、定义与应用"></a>类的声明、定义与应用</h2><p><strong>类的定义格式</strong></p>
<p>类是对现实世界中的客观事物的抽象，将具有相同属性的一类事物称作类，类的实例称为对象，类是一种复杂的数据类型，它是将不同类型的数据和与这些数据相关的操作封装在一起的集合体，类具有对数据的抽象性，隐藏性和封装性。类对象的行为由类的内部数据结构和相关的操作确定，外部行为通过操作接口实现。 </p>
<p><strong>类定义包括两个部分</strong></p>
<p>说明部分（做什么）<br>数据成员(名称，类型)<br>实现部分（方法）<br>成员函数的定义和实现 </p>
<h3 id="类定义的一般形式"><a href="#类定义的一般形式" class="headerlink" title="类定义的一般形式"></a>类定义的一般形式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  &lt;</span>类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">           公有数据及成员函数</span><br><span class="line">  protected:</span><br><span class="line">           保护数据及成员函数</span><br><span class="line">  private:</span><br><span class="line">            私有数据及成员函数</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现部分</span></span><br><span class="line">&lt;各成员函数的实现&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CLocation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  public:</span><br><span class="line">        <span class="type">void</span>  <span class="title function_">init</span><span class="params">(<span class="type">int</span> nNumA,<span class="type">int</span> nNumB)</span></span><br><span class="line">        &#123;</span><br><span class="line">                  m_X=nNumA;</span><br><span class="line">                  m_Y=nNumB;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">getx</span><span class="params">()</span>&#123;<span class="keyword">return</span>  m_X;&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">gety</span><span class="params">()</span>&#123;<span class="keyword">return</span>  m_Y;&#125;</span><br><span class="line">private:</span><br><span class="line">  <span class="type">int</span>  m_X,m_Y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明如下：</strong> </p>
<p>关键字class表示类<br>CLocation是自定义的类名，一般首字母用大写字母表示，与对象名相区别<br>关键字public,private,protected为访问权限控制符，规定成员的访问权限，他们出现的顺序和次数无限制 </p>
<ul>
<li>公有(public)成员提供了类的接口功能，不仅可以被成员函数访问，而且可以在程序中被访问 </li>
<li>私有(private)成员是被类隐藏的数据，外部无法访问，派生类的函数也无法访问，通常将数据成员定义为私有 成员 </li>
<li>保护(protected)成员外部无法访问，派生类的函数可以访问</li>
</ul>
<h3 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h3><p>对象是类的实例，任何一个对象都是属于某个已知类的，当定义一个类后，在C++编码的角度来看，就产生了一个新的数据类型，之后便可以使用这个数据类型定义新的变量。 </p>
<p>&lt;类名&gt;&lt;对象名表&gt; </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLocation objLocation; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：定义 Location类的对象如下 </span><br><span class="line">CLocation objA,objB,objC[10],*pobjD; </span><br></pre></td></tr></table></figure>

<ol>
<li>objA,objB为两个一般对象 </li>
<li>objC[10]是对象数组 </li>
<li>objD是指向类Location对象的指针 </li>
<li>对象的成员与它所属类成员一样，有数据成员和成员函数，创建对象时，每个对象的数</li>
<li>成员具有不同的存储空间，以存放不同的数据，但成员函数的代码为每个对象所共享</li>
</ol>
<h3 id="对象及成员的引用"><a href="#对象及成员的引用" class="headerlink" title="对象及成员的引用"></a>对象及成员的引用</h3><p>当定义好对象后，我们需要访问对象中的成员，对象访问成员的方法与结构变量访问成员变量的方法相同<br>访问一般对象的成员：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;对象名&gt;.&lt;数据成员名&gt;</span><br><span class="line">&lt;对象名&gt;.&lt;成员函数名&gt;（&lt;参数表&gt;）</span><br></pre></td></tr></table></figure>

<p>访问指向对象的指针的成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;对象指针名&gt;-&gt;&lt;数据成员名&gt;</span><br><span class="line">&lt;对象指针名&gt;-&gt;&lt;成员函数名&gt;(&lt;参数表&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="定义成员函数"><a href="#定义成员函数" class="headerlink" title="定义成员函数"></a>定义成员函数</h3><p>定义类中的成员函数可以采用以下三种方式： </p>
<ol>
<li>成员函数的定义及实现在类体中完成 </li>
<li>成员函数的定义及实现在类体外完成 </li>
<li>成员函数的定义及实现与类体在不同的文件中完成<br>调用成员函数</li>
</ol>
<p>一个对象要表现其行为，就要调用它的成员函数， </p>
<h3 id="用成员访问符调用"><a href="#用成员访问符调用" class="headerlink" title="用成员访问符调用"></a>用成员访问符调用</h3><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数必须使用对象来调用，一个类的所有对象调用的成员函数都是同一个代码段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTdate</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> d, <span class="type">int</span> y)</span>;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> m_Month;</span><br><span class="line">    <span class="type">int</span> m_Day;</span><br><span class="line">    <span class="type">int</span> m_Year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">CTdate::set</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> d, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  m_Month = m;</span><br><span class="line">  m_Day = d;</span><br><span class="line">  m_Year = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>成员函数如何识别m_Month，m_Day和m_Year是属于哪个调用对象呢<br>成员函数有一个隐含的附加形参，即指向该对象的指针，这个隐含的形参叫做this指针，通过this指针保证了每个对象可以拥有不同的数据成员，处理这些成员的代码可以被所有对象共享<br>当对象s调用s.set(2,15,1998)时，实际上传递了4个参数，除了接收传递的3个参数外，还接收到正在调用成员函数的对象s的地址，这个地址放入隐含的形参this指针中。等同于执行this &#x3D; &amp;s语句。所以对成员函数内数据成员的访问都隐含地加上了this指针<br>因此m_Month&#x3D;m;等价于this - &gt; m_Month&#x3D;m; </p>
<p>故而set()函数还可以表示成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">void</span>  <span class="title function_">CTdate::set</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> d,<span class="type">int</span> y)</span></span><br><span class="line"> &#123;</span><br><span class="line">   this - &gt;m_Month=m;</span><br><span class="line">   this - &gt;m_Day = d;</span><br><span class="line">   this -&gt; m_Year = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以无论对应哪个对象调用，成员函数从获得地参数(显示地实参和隐含地对象地址)来判断都不会弄错，可见，编译器设置this指针地作用是使成员函数记住当前访问成员函数地对象，以便于对对象中地数据成员进行访问 </p>
<ol>
<li>一个类对象所占据地内存空间由它地数据成员所占据地 数据空间总和决定 </li>
<li>类地成员函数不占据对象的内存空间</li>
</ol>
<h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><p>类的作用域简称类域，类域的范围是指在类所定义地类体中，该类的成员局部于该类所属的类域，一个类的任何成员都能访问同一类地任一其他成员，对类作用域外地一个类的数据成员和成员函数的访问受程序员编写程序的额控制，当把成员定义为私有和保护时，外界访问被限制，类域可以被包含在文件域中，可见类域小于文件域：而类域中又可包含函数域，可见类域又大于函数域，类域介于文件域和函数域之间</p>
<p>不同存储类的对象具有不同的生命期，对象的生命期是指对象从创建开始到被释放为止的存在时间，即刻对象的寿命，按生命期的不同，对象可分为如下三种(与介绍的变量划分情况相似) <strong>局部对象：</strong>定义在一个函数体内或程序块内，作用域和生命周期都是局部的</p>
<p> <strong>全局对象：</strong>定义在某个文件中，作用域为包含该文件的整个程序，生命期是全局的 </p>
<p><strong>静态对象：</strong>分为内部静态对象和外部静态对象，生命期都是全局的，前者作用域为定义他的函数体和程序块内；后者作用域为定义它的文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">类名允许与其他变量名或函数名同名 </span><br><span class="line"><span class="number">1</span>，如果一个非类型名隐藏了类型名，则类型名通过加前缀<span class="class"><span class="keyword">class</span>访问： </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span>&#123;</span> </span><br><span class="line"><span class="comment">//... </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> Sample)</span> 形参屏蔽了类型名 </span><br><span class="line">&#123; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="title">a</span>;</span> <span class="comment">//类型名前加class </span></span><br><span class="line">Sample++; <span class="comment">//形参自增运算 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="number">2</span>，如果一个类型名隐藏了一个非类型名，则用一般作用域规则访问 </span><br><span class="line"><span class="type">int</span> S=<span class="number">0</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="title">a</span>;</span> <span class="comment">//类S屏蔽了全局变量S定义类对象a </span></span><br><span class="line">::S=<span class="number">3</span>; <span class="comment">//引用全局变量前加作用域 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> g=S ; <span class="comment">//全局变量S给变量g初始化 </span></span><br><span class="line">定义一个类就是实现对创建一个对象的数据结构的描述，在类中，一些成员是保护的，被有效的屏蔽，以防外界的干扰和误操作，另一些成员是公共的，作为接口提供外界使用 </span><br></pre></td></tr></table></figure>

<h2 id="类与结构体的区别"><a href="#类与结构体的区别" class="headerlink" title="类与结构体的区别"></a>类与结构体的区别</h2><p>默认访问区别:<br>类的定义中默认情况下的成员访问级别是private<br>结构体定义中默认情况下的成员访问级别是public<br>初始化的区别：<br>类可以通过构造函数与析构函数初始化数据成员<br>结构体的初始化依靠特定的语法格式</p>
<h2 id="类的构造与析构"><a href="#类的构造与析构" class="headerlink" title="类的构造与析构"></a>类的构造与析构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CDesk</span>&#123;</span>  <span class="comment">//定义一个办公桌类</span></span><br><span class="line">private:</span><br><span class="line">  <span class="type">int</span>  m_high;</span><br><span class="line">  <span class="type">int</span>  m_width;</span><br><span class="line">  <span class="type">int</span>  m_length;</span><br><span class="line">  <span class="type">int</span>  m_weight;</span><br><span class="line">&#125;;</span><br><span class="line">CDesk  g_objDesk;     <span class="comment">//全局对象</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CDesk  objDesk ; <span class="comment">//局部对象</span></span><br><span class="line">  CDesk  *pobjDesk = new CDesk; <span class="comment">//堆对象</span></span><br><span class="line">  delete  pobjDesk;</span><br><span class="line">  <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是特殊的成员函数，函数名和类名完全相同，没有返回值类型，即不能定义构造函数的返回类型，也不能使用void。通常情况下构造函数应声明为公有函数，构造函数被声明为私有有特殊的用途<br>全局对象，局部对象，堆中的对象，只有有对象被创建了，都会自动调用构造函数</p>
<p><strong>构造函数的注意点</strong></p>
<ol>
<li>构造函数是C++提供的一种机制，当对下行被创建的时候会自动调用。构造函数内写什么代码都可以，但是它提供的这种自动调用的机制，是为了方便程序编写者初始化对象 </li>
<li>类体外定义构造函数，其函数名前要加上”类::”，构造函数无返回类型，构造函数不能是虚函数</li>
<li>全局对象的构造函数先于main函数执行 </li>
<li>在定义时，若类的数据成员是另一个类的对象，则在调用构造函数创建对象时，对作为数据成员的对象先要自动调用其自身的构造函数，然后再构造本类的对象</li>
<li>New不仅仅分配了内存还调用了构造函数，这一点从上面的例子也能够看出。值得注意的是，malloc也能分配堆内存，但是无法识别对象，也就无法调用构造函数了</li>
<li>可以有参数，并且可以定义多个构造函数构成重载</li>
</ol>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>除了构造函数，C++还提供了析构函数，析构函数在对象被销毁的时候，会被自动调用，通常来说是用来回收对象内被申请出的资源，比如对象中有一个指针指向堆空间，可以在析构函数中释放掉 </p>
<p><strong>析构函数的特点</strong></p>
<ol>
<li>无返回类型 </li>
<li>无参数 </li>
<li>不能随意调用(是可以调用的)； </li>
<li>不能重载（而构造函数可以有参数，也可以重载） </li>
<li>析构函数与构造函数的功能相对应，所以析构函数名是构造函数名前加一个逻辑反运算符“~”</li>
</ol>
<p>当对象结束其生命期时，比如在函数体内定义的对象，当该函数调用结束时，或局部对象被释放，就调用了析构函数<br>下面情况下需要使用析构函数</p>
<ul>
<li>构造函数打开一个文件，使用完文件时，需要关闭文件 </li>
<li>从堆中分配了动态内存区，在对象消失之前必须释放</li>
</ul>
<p><strong>带参数的构造函数</strong></p>
<p>不带参数的构造函数不能完全满足初始化的要求，因为这样创建的类对象具有相同的初始化值，如果需要对类对象按不同特征初始化不同的值，应采用带参数的构造函数。<br>一个类可以拥有多个构造函数构成重载，这样可以多样化的对对象进行初始化。 </p>
<p><strong>缺省构造函数</strong></p>
<p>C++规定，每一个类必须有一个构造函数，没有构造函数就不能创建任何对象，若未定义一个类的构造函数，则C++提供了一个缺省的构造函数，该缺省构造函数是一个无参数的构造函数，仅仅负责创建对象，而不做任何初始化工作 ，只要一个类定义了一个构造函数，C++就不再提供缺省的构造函数。如还需要无参数构造函数，则必须自己定义，与变量定义类型类似，在用缺省构造函数创建对象时，如果创建的是全局对象或静态对象，则对象成员数据全为0；局部对象创建时，其成员数据是无意义的随机数 </p>
<p>一个类如果什么都没有则被称之为空类，一个空类的大小为1个字节，且编译器会为其隐式产生6个成员，假设有一个空类class Empty，则编译器会为其产生以下几个成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Empty();       <span class="comment">//默认构造函数</span></span><br><span class="line">Empty(<span class="type">const</span>  Empty&amp;);<span class="comment">//默认拷贝构造函数</span></span><br><span class="line">~Empty();    <span class="comment">//默认析构函数</span></span><br><span class="line">Empty&amp; operator=(<span class="type">const</span>  Empty&amp;); <span class="comment">//默认赋值运算符</span></span><br><span class="line">Empty*  opetator&amp;();    <span class="comment">//取地址运算符</span></span><br><span class="line"><span class="type">const</span>  Empty*  operator&amp;()  <span class="type">const</span>;   <span class="comment">//取地址运算符const</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h3><p>构造函数中给变量初始值的时候，实际上都不算初始化，在构造函数初始化列表中初始化才算上是初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CLacation</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">CLocaton(<span class="type">int</span>  nNumA,<span class="type">int</span> nNumB):m_X(nNumA),m_Y(nNumB)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;2个参数的构造函数&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">CLocation(<span class="type">int</span>  nNumA): m_X(nNumA), m_Y(nNumA*<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;1个参数的构造函数&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">getx</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span>  m_X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gety</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  m_Y;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line"> <span class="type">int</span> m_X,m_Y;<span class="comment">//数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> CLocation  <span class="title function_">objA</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>;</span><br><span class="line"> CLocation  <span class="title function_">objB</span><span class="params">(<span class="number">3</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数声明的后面，加上一个冒号，冒号后面就是初始化列表。在初始化列表中，你可以为成员变量初始化，初始化时可以使用一个表达式，表达式可以有形参，也可以没有形参 </p>
<p>在构造函数执行的时候，分为两个阶段： </p>
<p>1，初始化阶段（在分配内存的时候，直接填充数据）<br>2，普通计算阶段（函数体内的程序代码，在这里初始化操作，算是赋值操作） </p>
<p>初始化列表是在第一阶段中，而在构造函数中赋值，就属于第二阶段了，此时也不能称之为初始化，只能算是赋值了 </p>
<ul>
<li>const类型的成员，只能在初始化列表中初始化 </li>
<li>引用类型的成员，只能在初始化列表中初始化 </li>
<li>有参数的对象成员（对象所对应的类没有默认构造函数），也只能在构造函数初始化列表中初始化</li>
</ul>
<p>因为他们都必须在定义的时候就初始化 </p>
<p><strong>总结</strong> </p>
<ol>
<li>推荐初始化放在初始化列表中，包括普通数据成员，对象数据成员 </li>
<li>没有默认构造函数的对象成员的初始化，只能放在构造函数的初始化列表中进行，等到了构造函数体内，已经来不及了 </li>
<li>这一原则也适用于const型成员，引用型成员，都要在初始化列表中初始化 </li>
<li>当有参构造函数，参数全部有默认值，也可以相当于有默认构造函数 </li>
<li>对象成员的构造顺序按照在类中的定义顺序来决定，跟初始化列表中的顺序无关、</li>
</ol>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>在C++中，提供了用一个对象值创建并初始化另一个对象的方法，完成该功能的是 拷贝构造函数（也叫复制构造函数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;拷贝构造函数名&gt;(&lt;类名&gt;&amp;&lt;引用名&gt;)</span><br><span class="line">&#123; &lt;函数体&gt; &#125;</span><br><span class="line">CLocation::CLocation(CLocation  &amp;obj)</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   public:</span><br><span class="line">      <span class="type">int</span> <span class="title function_">getLength</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">      Line( <span class="type">int</span> len );             <span class="comment">// 简单的构造函数</span></span><br><span class="line">      Line( <span class="type">const</span> Line &amp;obj);      <span class="comment">// 拷贝构造函数</span></span><br><span class="line">      ~Line();                     <span class="comment">// 析构函数</span></span><br><span class="line"> </span><br><span class="line">   private:</span><br><span class="line">      <span class="type">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 为指针分配内存</span></span><br><span class="line">    ptr = new <span class="type">int</span>;</span><br><span class="line">    *ptr = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::Line(<span class="type">const</span> Line &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用拷贝构造函数并为指针 ptr 分配内存&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ptr = new <span class="type">int</span>;</span><br><span class="line">    *ptr = *obj.ptr; <span class="comment">// 拷贝值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::~Line(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放内存&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    delete ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Line::getLength</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(Line obj)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;line 大小 : &quot;</span> &lt;&lt; obj.getLength() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   Line <span class="title function_">line</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line"> </span><br><span class="line">   display(line);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中&lt;拷贝构造函数名&gt;与该类名相同 ,如果一个类中没有定义拷贝构造函数，则系统自动生成一个缺省拷贝构造函数，其功能是将已知对象的所有数据成员的值拷贝给对应对象的数据成员 </p>
<p><strong>拷贝构造函数的特点</strong></p>
<ul>
<li>拷贝构造函数名字与类同名，没有返回类型 </li>
<li>拷贝构造函数只有一个形参数，该参数是该类的对象的引用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CLocation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    CLocation(CLocation&amp; obj) <span class="comment">//拷贝构造</span></span><br><span class="line">        :m_X(obj.m_X), m_Y(obj.m_Y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CLocation(<span class="type">int</span>  nX, <span class="type">int</span>  nY)<span class="comment">//普通带参构造</span></span><br><span class="line">        :m_X(nX), m_Y(nY)</span><br><span class="line">      </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;普通构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span>  m_X, m_Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    CLocation  <span class="title function_">objA</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>;</span><br><span class="line">    CLocation  <span class="title function_">objB</span><span class="params">(objA)</span>; <span class="comment">//此时调用的是拷贝构造函数</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/25/C-%EF%BC%88%E4%B8%80%EF%BC%89/image-20220325172828862.png" alt="image-20220325172828862"></p>
<p>拷贝构造函数除了用于使用已知对象的值创建一个同类的新对象外，还有两个主要用处 </p>
<ol>
<li>把对象作为实参数进行函数调用时，系统自动调用拷贝构造函数实现把对象值传递给形参 </li>
<li>当函数的返回值为对象时，系统自动调用拷贝函数对返回对象值创建一个临时对象，然后再将这个临时对象值赋给接收函数返回值的对象</li>
</ol>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2>]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>C++（二）</title>
    <url>/2022/03/28/C-%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>派生与继承，多态性与虚函数，模板，STL的基本使用，静态成员</p>
<span id="more"></span>

<h2 id="派生与继承"><a href="#派生与继承" class="headerlink" title="派生与继承"></a>派生与继承</h2><p><strong>继承的优势</strong></p>
<ol>
<li>继承是使用已经编写好的类来创建新类，新的类具有原有类的所有属性和操作，也可以在原有类的基础上作一些修改和增补 </li>
<li>新类称为派生类或子类，原有类称为基类或父类 </li>
<li>派生类是基类的具体化，一般来说派生类比基类的表示范围小的多</li>
</ol>
<p><strong>C++的继承支持单继承和多继承</strong> </p>
<ul>
<li>单继承：派生类只有一个直接基类的继承方式 </li>
<li>多继承：派生类有多个直接基类的继承方式</li>
</ul>
<p>单继承的基本格式如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  &lt;</span>派生类名&gt;:&lt;继承方式&gt;&lt;基类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//&lt;派生类新成员的定义&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，派生类名就是派生类的名字，并且派生类是按指定的继承方式派生的，继承方式有： </p>
<ul>
<li>public 公有继承 </li>
<li>private 私有继承 </li>
<li>protected 保护继承<br>  多继承的定义方式和单继承差不多</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;</span>派生类名&gt;:&lt;继承方式&gt;&lt;基类名<span class="number">1</span>&gt;，&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;，...</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//派生类新成员定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多继承派生类有多个基类，基类名之间用逗号分隔，每个基类名前都应有一个该基类的继承方式说明，假如不写继承方式的话，默认的继承方式为私有继承</p>
<h3 id="派生类的继承方式"><a href="#派生类的继承方式" class="headerlink" title="派生类的继承方式"></a>派生类的继承方式</h3><p>类的继承方式有三种： </p>
<ul>
<li>公有继承(public)：基类中的每个成员在派生类中保持同样的访问权限 </li>
<li>私有继承(private)：基类中的每个成员在派生类中都是private成员，而且他们不能再被派生的子类所访问 </li>
<li>保护继承(protexted)：基类中的Public成员和protected成员在派生类中都是Protected成员，private成员在派生类中仍为private成员</li>
</ul>
<blockquote>
<p>不管是什么继承方式，派生类的成员函数和友元函数都可以访问基类中的公有成员和保护成员，但不能访问私有成员<br>在公有继承时，派生类的对象只能访问公有成员，在保护继承和私有继承时，派生类的对象不能访问基类中任何成员</p>
</blockquote>
<p><img src="/2022/03/28/C-%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220328190742096.png" alt="image-20220328190742096"></p>
<h3 id="接口继承与实现继承"><a href="#接口继承与实现继承" class="headerlink" title="接口继承与实现继承"></a>接口继承与实现继承</h3><p><strong>公有继承</strong>，基类的公有成员函数在派生类中仍然是公有的，换句话说是基类的接口称为了派生类的接口，因而将它称为接口继承<br><strong>实现继承</strong>，对于私有，保护继承，派生类不继承基类的接口，派生类将不再支持基类的公有接口，它希望能重用基类的实现而已，因而将它称为实现继承 </p>
<p><strong>总结</strong></p>
<p>公有继承使得父类的接口继承传承到子类，子类可以继续往孙子类派生，保护继承使得父类的接口全部失效，只能在内部调用，依然可以往孙子类派生，私有继承使得父类所有接口也是只能在内部调用，但是不能往孙子类派生了，私有继承阻断了爷爷类和孙子类间的联系 </p>
<h3 id="派生类的构造、析构函数"><a href="#派生类的构造、析构函数" class="headerlink" title="派生类的构造、析构函数"></a>派生类的构造、析构函数</h3><p>基类的构造函数不被继承，派生类中需要声明自己的构造函数，声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化要调用基类的构造函数完成。假如基类构造函数没有缺省的构造函数，派生类的构造函数需要给基类的构造函数传递参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;派生类名&gt;(&lt;总参数表&gt;)</span><br><span class="line">:&lt;基类构造函数名&gt;(&lt;参数<span class="number">1</span>&gt;),&lt;子对象名&gt;(&lt;参数表<span class="number">2</span>&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//&lt;派生类中数据成员的初始化&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>正常情况下，如果基类构造是无参构造函数，那么会自动去调用，而不用派生类构造显示调用，如果基类没有无参数构造函数，那么派生类必须显示调用基类的构造函数 </p>
</blockquote>
<p>假如同时有父类，又有类对象的数据成员的时候，构造函数的调用顺序</p>
<ol>
<li>基类构造函数 </li>
<li>数据成员的构造函数 </li>
<li>派生类构造函数</li>
</ol>
<p>执行派生类的析构函数时，也要调用基类及子类的析构函数，同时析构函数的调用顺序与构造函数是相反的。</p>
<ol>
<li>先调用派生类的析构函数 </li>
<li>数据成员的析构函数 </li>
<li>基类的析构函数</li>
</ol>
<h2 id="类的成员重定义"><a href="#类的成员重定义" class="headerlink" title="类的成员重定义"></a>类的成员重定义</h2><p>重定义是子类需要修改或扩展基类的某个成员的功能时需要利用的机制，可以分为两种 </p>
<ol>
<li><p>对基类的数据成员的重定义 </p>
</li>
<li><p>对基类成员函数的重定义</p>
<ul>
<li>与基类完全相同 </li>
<li>与基类成员函数名相同，参数不同</li>
</ul>
</li>
<li><p>对于基类与派生类重定义的数据成员。派生类对象调用的时候，应该是派生类的数据成员，也就是说数据成员重定义的时候隐藏了基类的数据成员 </p>
</li>
<li><p>对于与基类完全相同的成员函数，会隐藏基类的成员函数，调用的时候，调用的是派生类的成员函数 </p>
</li>
<li><p>对于与基类成员函数函数名相同，参数不同的成员函数，还是会隐藏基类的成员函数，这一点要注意 </p>
</li>
<li><p>注意在不同的作用域中定义的成员函数名相同，参数不同，这不叫重载，这叫重定义，重载说的是在相同作用域中的现象，也就是在一个类中定义的函数</p>
</li>
</ol>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p><strong>单重继承：</strong>一个派生类最多只能有一个基类<br><strong>多重继承：</strong>一个派生类可以有多个基类，如果派生类有两个或两个以上的直接基类，称为多继承 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  &lt;</span>派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//派生类的类体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CClassC</span>:</span>publlic  CClassB,privatee  CClassA</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多继承派生类的构造函数格式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;派生类名&gt;(&lt;总参数表&gt;)</span><br><span class="line">:&lt;基类名<span class="number">1</span>&gt;(&lt;参数表<span class="number">1</span>&gt;),&lt;基类名<span class="number">2</span>&gt;(&lt;参数表<span class="number">2</span>&gt;),&lt;子对象名<span class="number">3</span>&gt;(&lt;参数<span class="number">3</span>&gt;),....</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//派生类构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">CClassC(<span class="type">int</span> nNum)</span><br><span class="line">:CClassB(nNum),CClassA(nNum),m_nNum(<span class="number">15</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行顺序：先执行所有基类的构造函数，再执行派生类本身的构造函数，包含子对象在内</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">classA</span><br><span class="line">&#123;&#125;</span><br><span class="line">classB</span><br><span class="line">&#123;&#125;</span><br><span class="line">classC</span><br><span class="line">&#123;&#125;</span><br><span class="line">classD:public A,public B,public C</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>首先要顺序执行类A，类B和类C的构造函数，再执行派生类D本身的构造函数</p>
<h3 id="多继承中的二义性问题"><a href="#多继承中的二义性问题" class="headerlink" title="多继承中的二义性问题"></a>多继承中的二义性问题</h3><p>一般的，派生类成员的访问是唯一的，但是在多继承的情况下，可能出现派生类对其类成员访问的不唯一性，即二义性。<br><strong>虚基类</strong></p>
<p>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性–采用虚基类来解决</p>
<p>虚基类的引入：用于有共同基类的场合<br>虚基类(virtual base class)说明格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">virtual  &lt;继承方式&gt;&lt;基类名&gt;</span><br><span class="line">virtual  public  CClassA</span><br></pre></td></tr></table></figure>

<p>作用 </p>
<p>主要用于解决多继承时可能发生的对同一基类继承多次而产生的二义性问题<br>为最远的派生类提供唯一的基类成员，而不重复产生多个数据<br>如果一个派生类有多个直接基类，而这些直接基类又有一个共同的基类，则在最终的派生类中会保留该间接共同基类数据成员的多份同名成员，C++提供虚基类的方法，使得在继承间接共同基类时只保留一份成员 </p>
<p>总结</p>
<p>C++支持类继承机制，继承是面向对想想的重要概念之一，派生类的成员函数和友元函数可以访问基类的所有公有和保护的数据成员和成员函数<br>派生类对象只能访问基类的公有成员和成员函数，多重继承是一个类从多个基类派生而来的机制，派生类实际上获取了所有基类的特性<br>当一个类是两个或多个基类的派生类时，必须在派生类名和冒号之后，列出所有基类的类名，基类间用逗号隔开，派生类的构造函数必须激活所有基类的构造函数，并把相应的参数传递给它们<br>派生类可以是另一个类的基类，这样，相当于形成了一个继承链，当派生类的构造函数被激活时，它的所有基类的构造函数也会被激活，为解决多继承中的二义性问题，引进虚基类的概念，其目的是使公共基类在其派生对象中只产生一个基类子对象</p>
<h3 id="多态性与虚函数"><a href="#多态性与虚函数" class="headerlink" title="多态性与虚函数"></a>多态性与虚函数</h3><p>多态性是指对不同类的对象发出相同的消息将会有不同的行为，消息主要是指对类的成员函数的调用，不同的行为是指不同的实现 </p>
<p>**C++中实现多态有以下多种方式： **</p>
<ul>
<li>函数重载 </li>
<li>运算符重载 </li>
<li>模板 </li>
<li>虚函数 </li>
<li>子类型</li>
</ul>
<p>在继承关系中，若类B是类A以公有继承形式产生的派生类，则类B包含了父类A的行为，并且它本身还可具有新的行为，可称类B是类A的一个子类型 </p>
<h3 id="静态连编与动态联编"><a href="#静态连编与动态联编" class="headerlink" title="静态连编与动态联编"></a>静态连编与动态联编</h3><p>联编是指程序自身彼此关联的过程，按照联编所进行的阶段不同，可分为静态联编和动态联编，静态联编是指在程序编译连接阶段进行联编，也称为早期联编。这种联编工作由于在程序运行之前完成，所调用的函数与执行该函数的代码之间的关系已确定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CBase</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">   <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;CBase:fun&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyClass</span>:</span>public  CBase&#123;</span><br><span class="line">public:</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;CMyClass:fun&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CBase *p;</span><br><span class="line">  CBase  objA;</span><br><span class="line">  CMyClass  objB;</span><br><span class="line">  p = &amp;objA; p-&gt;fun();</span><br><span class="line">  p = &amp;objB; p-&gt;fun();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指向基类的指针p,在此程序运行前，p-&gt;fun()已确定为访问基类的成员函数fun()，所以不管p指向基类，还是派生类的对象，p-&gt;fun()都是基类绑定的成员函数，结果都相同，这就是静态联编的结果<br>动态联编是指在程序运行时进行的联编，也称晚期联编，动态联编要求在运行时解决程序中的函数调用与执行该函数代码间的关系</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数的概念：在基类中冠以关键字virtual的成员函数 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">virtual  &lt;类型说明符&gt;&lt;函数名&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">virtual  <span class="type">void</span> <span class="title function_">fun_a</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//&lt;函数体&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： </p>
<ol>
<li>如果一个函数在基类中被声明为虚函数，则他在所有派生类中都是虚函数 </li>
<li>只有通过基类指针或引用调用虚函数才能引发动态绑定 </li>
<li>虚函数不能声明为静态，也不能是友元函数 </li>
<li>基类中的虚函数，在派生类中即使没有指定virtual关键字，它也是虚函数 </li>
<li>如果某个类中的一个成员函数被说明为虚函数，该成员函数可能在派生类中存在着不同的实现版本 </li>
<li>由于存在有虚函数，编译器将进行动态联编，使调用虚函数的对象在运行时确定，以实现动态联编的多态性</li>
</ol>
<p>特性：</p>
<p>当一个父类指针指向子类对象的时候，调用一个虚函数，将调用子类的虚函数</p>
<h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><p>纯需函数提供了基类指针指向派生类对象，调用的是派生类的虚函数这一特性，这就使得我们以一致的观点来看待不同的派生类对象，在运行时刻才确定函数的入口。 </p>
<p>但是思考一个问题，如果基类的接口使无法实现的怎么办？比如：<br>形状有一个求面积的函数，原型与矩形继承自形状类，那么圆形与矩形知道怎么算出面积。但是下形状是无法求得面积的，因为形状是一个抽象的概念，这个情况就用到了纯虚函数<br>包含纯虚函数的类就是抽象类，这样的类也不能实例化，纯虚函数是一种特殊的虚函数，是一种没有具体实现的虚函数，其定义格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">virtual</span> &lt;函数名&gt; &lt;函数名&gt;(&lt;参数表&gt;)=<span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> CClassA</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">virtual</span>  &lt;函数名&gt; &lt;函数名&gt;(&lt;参数表&gt;)=<span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做，这就是纯虚函数的作用 </p>
<p>一个类中如果定义了纯虚函数，则这个类就会变成抽象类，C++规定抽象类类型将不能再定义对象 </p>
<p>注意： </p>
<ul>
<li>抽象类只能作为基类来使用 </li>
<li>不能声明抽象类的对象 </li>
<li>构造函数不能是虚函数，析构函数可以是虚函数 </li>
<li>抽象类不能用于直接创建对象实例，可以声明抽象类的指针和引用 </li>
<li>可使用指向抽象类的指针支持运行时多态性 </li>
<li>派生类中必须实现基类中的纯虚函数，否则它仍将被看作一个抽象类</li>
</ul>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>构造函数不能说明为虚函数，而析构函数可以说明为虚函数，其方法是在析构函数前加上关键字virtual说明符，如果一个基类的析构函数被说明为虚函数，则其派生类中的析构函数，可省略virtual说明符</p>
<p><strong>为什么要将析构函数声明为虚函数</strong></p>
<p>基类指针指向子类对象，是多态中常见的做法，那么delete基类指针去释放空间，也会经常出现，但是delete基类指针只会调用父类的析构函数，子类的析构函数不会被调用，这样就有可能会出现内存泄漏<br>基类的析构函数为虚函数，且派生类有自定义析构函数实现时，delete基类指针时会同时调用派生类的析构函数，派生类析构的时候，会自动调用基类的析构函数</p>
<h3 id="重载、重定义与重写"><a href="#重载、重定义与重写" class="headerlink" title="重载、重定义与重写"></a>重载、重定义与重写</h3><p><img src="/2022/03/28/C-%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220329102929322.png" alt="image-20220329102929322"></p>
<p>成员函数被重载的特征： </p>
<ol>
<li>相同的范围(在同一个类中) </li>
<li>函数名字相同 </li>
<li>参数不同 </li>
<li>virtual关键字可有可无</li>
</ol>
<p>重写是指派生类函数覆盖基类函数，特征是： </p>
<ol>
<li>不同的范围（分别位于派生类与基类） </li>
<li>函数名字相同 </li>
<li>参数相同 </li>
<li>基类函数必须有virtual关键字</li>
</ol>
<p>重定义（派生类与基类） </p>
<ol>
<li>不同的范围（分别位于派生类与基类） </li>
<li>函数名与参数都相同，无virtual关键字 </li>
<li>函数名相同，参数不同，virtual可有可无</li>
</ol>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板是一种工具模板可以使程序员能建立具有通用类型的函数库和类库模板也是C++语言支持参数多态性的工具<br>C++语言的程序结构主要是由函数和类构成的，模板具有两种不同的形势<br>A:函数模板<br>B:类模板</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>考察两个swap()函数，一个交换整形数，一个交换浮点数，尽管函数的功能一样，仅处理数据类型不同，但对有强数据类型校验的C++语言，必须使用函数重载，分别编写代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>                                   <span class="type">void</span>  <span class="title function_">swap</span><span class="params">(<span class="type">float</span>  &amp;a,<span class="type">float</span> &amp;b)</span></span><br><span class="line">&#123;                                                                         &#123;</span><br><span class="line">  <span class="type">int</span>  temp=a;                                                                <span class="type">float</span>  temp=a;</span><br><span class="line">  a=b;                                                                            a=b;</span><br><span class="line">  b=temp;                                                                      b=temp;</span><br><span class="line">&#125;                                                                          &#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数的参数个数，实现代码是相同的，只有形参的类型不同，如果将两个函数中的int 和float进行参数化，使用参数T替代，则交换任何一对数据类型的变量(包括类对象)可以定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Template&lt;T&gt;</span><br><span class="line"><span class="type">void</span>  <span class="title function_">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span><br><span class="line">&#123;</span><br><span class="line">   T  temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上述定义，对任一类型T的两个变量或类对象(x1,x2)，函数调用swap(x1,x2)编译器都能理解并执行函数模板所确定的功能<br>函数模板提供了具有处理相同功能的一类函数的抽象，它以任意类型T为参数，其定义形式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;参数化类型名表&gt;</span><br><span class="line">&lt;返回类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//&lt;函数体&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span>  T_TYPE&gt;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">fun</span><span class="params">(T_TYPE  NumA,T_TYPE  NumB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，template是定义函数模板啊的关键字，&lt;参数化类型名表&gt;可以包括基本数据类型，也可以包含类类型<br>如果是类类型，则需加关键字class，例如： template </p>
<p>函数模板是对一组函数的描述，它不是一个实实在在的函数，表示每次它能单独处理在类型形式参数中说明的数据类型，编译器不会为其产生任何执行代码<br>当编译器发现有函数调用：函数名（实参数)，当实参数与函数模板形参数相匹配时，则产生一个重载函数。该重载函数与函数模板实现功能相同（函数体定义相同），该重载函数称为模板函数<br>函数模板是模板的定义，不是一个函数，定义中使用通用的类型参数<br>模板函数是用函数模板实例化的函数，它是一个实实在在的函数定义，它由编译器遇到模板函数调用时所生成，具有可执行的程序代码</p>
<h3 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h3><p>模板的特化也可以理解为实例化，模板的特化分为隐式实例化与显示实例化 </p>
<p>特化的目的是为了适应模板在实例化时会产生的一些特殊情况，模板的特化分为普通特化与偏特化，他们的特点分别如下： </p>
<p>普通特化：将此模板的所有替换类型的某一种类型进行特别处理<br>偏特化：将此模板的所有替身类型的某一种类型的某几项进行特别处理</p>
<h3 id="函数重载模板"><a href="#函数重载模板" class="headerlink" title="函数重载模板"></a>函数重载模板</h3><p>重载方法约定： </p>
<ol>
<li>查找参数完全匹配的函数； </li>
<li>查找函数模板，实例化产生一个匹配的模板函数 </li>
<li>通过类型转化可产生参数匹配的函数</li>
</ol>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>考虑定义一个一维数组的情况，不管数组元素是什么类型数据的类。数组类在所有类型数据上进行的基本操作都是相同的(如插入，删除，检索等)，链表情况也是如此。可以定义节点为不同类型数据的类，但链表类在所有类型数据上进行的基本操作也是i相同的。<br>如果要对功能相同，类的实现没有变化，仅类的数据类型不同的各种情况，都要重新定义一种新的类型，将带来较大的重复。为解决这一问题，可以引进类模板的概念。即将数组种的元素和链表中的节点的数据类型用一个通用参数T来替代 </p>
<p>类模板的定义格式为： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">templete &lt;模板参数表&gt; </span><br><span class="line"><span class="keyword">class</span> &lt;类名&gt; </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//类体说明 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其中templete是关键字，&lt;模板参数表&gt;中可以有多个参数，其间用逗号分隔<br>类模板是为具有相同特性的一组类，定义的一种模式，它说明单个类怎样建立，这与类型声明说明单个对象是怎样建立类似，用模板是参数数生成的类称为模板类，模板类可以生成对象 </p>
<p>总结</p>
<p>模板是一种安全的，搞笑的重用代码方式，它使用通用的参数化类型，在创建对象或函数时所传递的实参类型可以改变其行为，函数模板和类模板经实例化后，可生成具有不同类型的模板函数和模板类，尽管处理数据的类型不同，但其功能和实现是相同的 </p>
<p>每个模板类的实例是一个实际的对象，可以像其他类的对象一样使用<br>在C++中的一个发展趋势是使用标准模板类库(STL)，将其作为编译器的一部分，STL是一个基于模板的包容类库，包括向量，链表和队列，还包括一些通用的排序和查找算法等。STL为用户提供了那些需要重复编码的程序代码，提高了变成的效率。</p>
<h2 id="STL的基本使用"><a href="#STL的基本使用" class="headerlink" title="STL的基本使用"></a>STL的基本使用</h2><p>STL &#x3D; Staandard Template Library，标准模板库，它是由惠普实验室开发的一系列标准化的组件，目前是C++的一部i分。<br>STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内</p>
<h3 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h3><p>string类型支持长度可变的字符串，C++标准模板库将负责管理与存储字符相关的内存，以及提供各种有用的操作，<br>使用string需要包含它的头文件，并且using它 </p>
<p>string的构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1:   <span class="comment">//默认构造函数，s1为空串</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span>:   //将s2初始化为s1的一个副本</span></span><br><span class="line"><span class="function">string s3(<span class="string">&quot;value&quot;</span>):   //将s3初始化为一个字符串字面值副本</span></span><br><span class="line"><span class="function">string s4(n,<span class="string">&#x27;c&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string  s1;</span><br><span class="line">  <span class="function">string  <span class="title">s2</span><span class="params">(<span class="string">&quot;asdfgg&quot;</span>)</span></span>;</span><br><span class="line">  cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">  <span class="function">string  <span class="title">s4</span><span class="params">(<span class="string">&quot;abcdefg&quot;</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  cout&lt;&lt;s4&lt;&lt;endl;</span><br><span class="line">  <span class="function">string  <span class="title">s5</span><span class="params">(s2,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  cout&lt;&lt;s5&lt;&lt;endl;</span><br><span class="line">  string::iterator first = s2.<span class="built_in">begin</span>() +<span class="number">1</span>; <span class="comment">//迭代器</span></span><br><span class="line">  string::iterator last = s2.<span class="built_in">begin</span>()+<span class="number">5</span>;  <span class="comment">//迭代器</span></span><br><span class="line">  <span class="function">string <span class="title">s6</span><span class="params">(first,last)</span></span>;</span><br><span class="line">  cout&lt;&lt;s6&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中出现了迭代器，迭代器是一种类似于指针的东西，目前暂可这么理解，他是用来指代容器中的某一个元素的，最常见的用法是遍历容器中的每一个元素 </p>
<p>常用的成员函数</p>
<p><img src="/2022/03/28/C-%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220329110632733.png" alt="image-20220329110632733"></p>
<h3 id="vector类"><a href="#vector类" class="headerlink" title="vector类"></a>vector类</h3><p>vector是动态数组，并且由于它是模板技术实现的，它支持任意类型 </p>
<p>vector的常用函数</p>
<p><img src="/2022/03/28/C-%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220329110812151.png" alt="image-20220329110812151"></p>
<p>vector的强大在于它支持很多的运算符，在数组中想要整体赋值愿望就这么被它实现了，并且它还是一个会无限扩张的数组。（前提是你的元素都是push_back添加进去的）<br>vector也是支持迭代器的，可以用于遍历vector中的每一个元素</p>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>全局对象是实现数据共享的一种方法，由于它处处可见，因此不够安全，应尽量在程序中少用全局对象，实现类的多个对象之间的数据共享，可使用静态成员<br>静态成员包括静态数据和静态成员函数，友元函数也是一种普通的C++函数，但是它可以访问类的保护或私有成员，方便编程，提高了效率，同时也破坏了类的封装性<br>在一个类中，若将一个数据说明为static，则该数据称为静态数据，它告诉编译器无论建立多个该类的对象，都只有一个静态数据的拷贝，这个拷贝被所有类对象共享，静态数据属于类而共享，不属于对象独有，它的值对每个对象都是一样的，对静态数据成员的值的更新，即是对所有对象的该静态数据成员值的更新，静态数据使用关键字static，静态数据成员在类体中说明，在类体外定义，以分配存储空间并初始化</p>
<h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CCounter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  public:</span><br><span class="line">      <span class="type">void</span>  <span class="title function_">sercount</span><span class="params">(<span class="type">int</span> i)</span> &#123; m_nCount=i&#125;</span><br><span class="line">      <span class="type">void</span>   showcount()  &#123;<span class="built_in">cout</span>&lt;&lt;m_nCount&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">   private:</span><br><span class="line">      <span class="type">static</span>  <span class="type">int</span>  m_nCount;   <span class="comment">//在类体内说明静态数据</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="type">int</span>  CCounter::m_nCount = <span class="number">0</span>; <span class="comment">//在类体外定义静态数据</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CCounter  objA,objB;</span><br><span class="line">  objA.showcount();</span><br><span class="line">  objB.showcount();</span><br><span class="line">  objA.setcount(<span class="number">15</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态数据成员可应用在以下几个方面：</p>
<ul>
<li>用来保存流动变化的对象个数(如学生人数) </li>
<li>作为一个标志，指示一个特定的动作是否发生 </li>
<li>指向一个链表第一成员或最后一个成员的指针</li>
</ul>
<p>对静态成员函数的访问，在程序中可使用如下方式： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;)； </span><br><span class="line">classA::<span class="built_in">Fun</span>(<span class="number">123</span>,<span class="number">456</span>); </span><br></pre></td></tr></table></figure>

<p>或 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;对象名&gt;.&lt;静态成员函数名&gt;(&lt;参数表&gt;)； </span><br><span class="line">objA.<span class="built_in">Fun</span>(<span class="number">123</span>,<span class="number">456</span>) </span><br></pre></td></tr></table></figure>

<p>静态成员函数只属于一个类，而不属于类中的任何对象<br>静态成员函数的说明和定义与静态数据成员一样，函数实现可在类体内，也可在类体外，与一般成员函数相同<br>在静态成员函数的实现中，可以直接使用静态成员，可以通过对象来使用非静态成员</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>C（三）</title>
    <url>/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/veer-354426716.webp" alt="veer-354426716" style="zoom: 200%;">

<span id="more"></span>

<p>函数，预处理，指针，结构体和联合体，类型定义，堆内存，文件处理</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>什么是函数</strong> </p>
<p>（1）函数就是被定义的有特定功能的一小段独立程序。函数也被称为方法<br>（2）函数是C语言的基本构成单位<br>（3）函数都是平等的，没有谁等级更高一些这种说法，只有main()稍微特殊一些</p>
<p><strong>函数划分</strong></p>
<p>（1）标准C定义的标准库函数<br>符合标准的C编译器必须提供这些函数，函数的行为也要符合标准C的定义<br>（2）第三方库函数<br>由其它厂自行开发的C语言函数库，不在标准范围内，能扩充C语言的功能<br>（3）自定义函数<br>自己编写的函数包装后，也可成为函数库，供别人使用</p>
<p><strong>函数定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数的定义规则：</span><br><span class="line">返回值类型   函数名（参数类型   形式参数名1，参数类型  形式参数名2，···）</span><br><span class="line">&#123;</span><br><span class="line">  函数语句</span><br><span class="line">  return  返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ol>
<li>返回值类型：函数调用表达式的值类型，需和return之后的数据类型一致，假如函数没有返回值，则可以写 void </li>
<li>参数类型：形式参数的数据类型，调用函数的时候，可以给函数传递的数据类型。 </li>
<li>形式参数名：接到外部数据的变量，可以在函数内部直接使用，假如没有参数的话，写一个void即可 </li>
<li>return语句：有两个作用，第一个是用于结束函数，第二个是将返回值传递出函数。<br>注：假如函数中没有写return,则函数在最后一个}时结束 </li>
<li>返回值，就是函数会返回给调用者的一个数据。假如返回值类型时void的，那么就不用写返回值了，有没有 返回值这都是由设计者决定的</li>
</ol>
<p>实现一个函数，主要考虑的就是三个问题 </p>
<ul>
<li>你定义这个函数的主要功能是什么 </li>
<li>你实现这个函数的功能，需要外部给你传递什么参数？ </li>
<li>如何让调用者，得到最终的结果？</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><ol>
<li>函数语句<br>把函数调用作为一个语句，这时不要求函数带返回值，只要求函数完成一定的操作 </li>
<li>函数表达式<br>函数出现在一个表达式中，这种表达式称为函数表达式，这时要求函数带回一个确定的值以参加表达式的运算 </li>
<li>函数参数<br>函数嗲用作为一个函数的实参</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，当定义在调用之前时，调用者不需要申明即可调用</span><br><span class="line"><span class="type">int</span>  <span class="title function_">print_message</span><span class="params">(<span class="type">int</span>  nNumb,<span class="type">int</span>  nNumA)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>  <span class="title function_">print_message_a</span><span class="params">(<span class="type">int</span>  nNumb,<span class="type">int</span>  nNumA)</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="type">int</span>  nTem=nNumb;</span><br><span class="line">    nNumb=nNumA;</span><br><span class="line">     nNumA=nTem;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">int</span>  nNumb=<span class="number">12</span>，nNumA=<span class="number">10</span>;</span><br><span class="line">  <span class="comment">//1,当定义在调用之前时，调用者不需要申明即可调用</span></span><br><span class="line">  print_message_a(nNumb,nNumA);</span><br><span class="line">  <span class="comment">//2,当函数定义在调用之后时，需要先声明函数声明必须要与该函数定义完全相同</span></span><br><span class="line">  <span class="comment">//(返回值，参数类型，参数个数)最后以分号结束</span></span><br><span class="line">  <span class="type">int</span>  <span class="title function_">FUN</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> b,<span class="type">int</span> c)</span>;</span><br><span class="line">  <span class="comment">//可以没有变量的名字，但是必须要有类型：int  FUN(int,int,int);</span></span><br><span class="line">  <span class="comment">//调用函数:</span></span><br><span class="line"> FUN(<span class="number">1</span>,print_message_a(nNumb,nNumA),<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span>  <span class="title function_">FUN</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> b, <span class="type">int</span> c)</span>;</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用注意事项：<br>在一个函数中调用另一个函数需要具备的条件如下</p>
<ol>
<li>首先被调用的函数必须是已经存在的函数(是库函数或用户自己定义的函数)。</li>
<li>如果使用库函数，还应该在本文件开头用#include命令将调用有关库函数时所需用到的信息”包含”到本文件中去</li>
<li>如果使用用户自己定义的函数，而该函数的位置在调用它的函数(即主调函数)的后面(同一个文件中，应该在主调函数中对被调用的函数作声明)</li>
<li>即使没有实现该函数，但有声明，在写的时候没有错误，但在编译时会出现错误(无法解析XXX外部符号)</li>
<li>将函数作为另一个函数的参数时该函数的返回值必须要和当前函数形参类型一致</li>
</ol>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>通过函数调用使主调函数能得到一个确定的值，这就是函数的返回值 </p>
<p>1，函数的返回值是通过函数中的return语句获得的。 </p>
<p>return语句将被调用函数中的一个确定值带回主调函数中去 </p>
<p>2，函数值的类型。既然函数有返回值，这个值当然应属于某一个确定的类型，应当在定义函数时指定函数值的 类型</p>
<p>3，在定义函数时指定的函数类型一般应该和return语句中的表达式类型一致<br>如果函数值的类型和return语句中表达式的值不一致，则以函数类型为准，对数值型数据，可以自动进行类型转换。即函数类型决定返回值类型</p>
<h3 id="形式参数与实际参数"><a href="#形式参数与实际参数" class="headerlink" title="形式参数与实际参数"></a>形式参数与实际参数</h3><p>在定义函数时函数名后面括号中的变量名称为”形式参数”（简称”形参“），在主调函数中调用一个函数时，函数名后面括号中的参数（可以是一个表达式）称为”实际参数“（简称”实参“） </p>
<p><strong>形式参数和实际参数说明</strong> </p>
<ol>
<li>在定义函数中指定的形参，在未出现函数调用时，他们并不占内存中的存储单元。只有在发生函数调用 时，函数中的形参才被分配内存单元，在调用结束后，形参所占的内存单元也被释放<br>注：因为当进入函数时，形参也相当于变量，是变量就要给它开辟空间。当调用结束后，形参所占的内存单元也被释放 </li>
<li>实参可以是常量，变量或表达式。但要求他们有确定的值 </li>
<li>在被定义的函数中，必须指定形参的类型 </li>
<li>实参与形参的类型应相同或赋值兼容 </li>
<li>实参向形参的数据传递是”值传递“，单向传递，只由实参传给形参，而不能由形参传回来给实参，在内存 中，实参单元与形参单元是不同的单元，在调用函数时，给形参分配存储单元，并将实参对应的值传递给 形参，调用结束后，形参单元被释放，实参单元仍保留并维持原值，因此，在执行一个被调用函数时，形 参的值如果发生改变，并不会改变主调函数的实参的值</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">通过函数实现两个数的交换</span><br><span class="line"><span class="type">int</span> <span class="title function_">print_message_a</span><span class="params">(<span class="type">int</span> nNumb,<span class="type">int</span> nNumA)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>  nTem = nNumb;</span><br><span class="line">  nNumb = nNumA;</span><br><span class="line">  nNumA = nTem;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;b=%d,A=%d&quot;</span>,nNumb,nNumA);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>  nNumb=<span class="number">12</span>,nNumA=<span class="number">10</span>;</span><br><span class="line">  print_message_a(nNumb, nNumA);  <span class="comment">//可以不接受返回值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;nNumb=%d,nNumA=%d&quot;</span>,nNumb,nNumA);</span><br><span class="line">  <span class="comment">//最终结果 nNumb,nNumA值没有任何变化</span></span><br><span class="line">  <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220321163503789.png" alt="image-20220321163503789"></p>
<p>所有函数都是平行的，即在定义函数时是分别进行的，是相互独立的。一个函数并不从属另一个函数，即函数不能嵌套定义，函数间可以相互调用，但不能调用main函数，main函数是系统调用的 </p>
<p>从用户使用的角度看，函数有两种，<br>（1）标准函数即库函数，它是由系统提供的，用户不必自己定义而直接使用他们<br>（2）用户自己定义的函数，它是用以解决用户专门需要的函数<br>从函数的形式看，函数分两类<br>（1）无参函数，在调用无参函数时，主调函数不向被调函数传递数据，无参函数一般用来执行指定的一组操作<br>无参函数可以带回或不带回函数值，但一般以不带回返回值的居多<br>（2）有参函数，在调用函数时，主调函数在调用被调函数时，通过参数向被调函数传递数据，一般情况下，执行被调函数时会得到一个函数值，供主调函数使用</p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p><strong>局部变量</strong></p>
<p>局部变量定义在函数内部，只对当前函数有效，如“{}”内定义的局部变量与外面重名，则以内部为准 </p>
<p><strong>全局变量</strong></p>
<p>全局变量需要定义在函数外部，对所有函数有效，全局变量的作用范围是从定义变量的位置开始到源程序结束，即全局变量可以被在其定义位置之后的其他函数所共享，全局变量主要用于函数之间数据的传递 </p>
<p><strong>静态局部变量</strong></p>
<p>静态变量的作用类似于全局变量，所有的全局变量均为静态变量，而局部变量只有定义时加上类型下修饰符static，才为局部静态变量 </p>
<p>静态变量的特点是在程序的整个执行过程中始终存在，但是它作用域之外不能使用，静态变量的生存期就是整个程序的运行期，函数体内如果在定义静态变量的同时进行了初始化，则以后程序不再进行初始化操作 </p>
<p><strong>extern与static在全局变量中的应用</strong></p>
<p>如果组成这一个程序的几个文件需要用到同一个全局变量，只要在其它引用该全局变量的源程序文件中说明该全局变量为extern即可 </p>
<p>如果一个源程序文件中的全局变量仅限于该文件使用，只要在该全局变量定义时的类型说明前加static即可 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern int nNum;//nNum已经在其他位置定义 </span><br></pre></td></tr></table></figure>

<p>如果一个源程序文件中的全局变量仅限于该文件使用，只要在该全局变量定义时的类型说明前加static即可 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int nNum;//仅限于本文件使用</span><br></pre></td></tr></table></figure>

<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>编译预处理主要用于在程序正式编译前进行一些预加工操作，编译预处理共分为以下几种：</p>
<ul>
<li>宏定义 </li>
<li>文件包含 </li>
<li>条件编译 </li>
<li>所有的编译预处理命令均以”#”开头 </li>
<li>宏</li>
</ul>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>宏定义的作用就是在程序中某段代码的一个别名，宏定义主要为程序调试，移植等提供便利，是一个非常使用的功能。所有宏命令都以符号“#define”开头，并且结尾不用分号。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define PI 3.14 </span><br></pre></td></tr></table></figure>

<p>宏定义的作用是在编译预处理时，将源程序中所有标识符替换成语句序列。。宏定义分别为有参宏和无参宏 </p>
<p>需要注意的是宏名一般用大写字母，以便与变量名的区别，在编译预处理时宏名与字符串进行替换时，不做语法检查，只是简单的字符替换，只有在编译时才对已经展开红名的源程序进行语法检查。宏明的有效范围是从定义位置到文件结束，如果需要终止宏定义的作用域，可以用<code>#undef</code>命令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define PI 3.14 </span><br><span class="line">........ </span><br><span class="line">#undef PI </span><br></pre></td></tr></table></figure>

<h3 id="无参宏"><a href="#无参宏" class="headerlink" title="无参宏"></a>无参宏</h3><p>无参宏指的是执行单一替换功能的宏定义，在使用无参宏时要注意以下两个问题，<br>1，宏定义时可以应用已经定义的宏名，如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\#define R 2.0 </span><br><span class="line">\#define PI 3.14 </span><br><span class="line">\#define L 2*PI*R </span><br></pre></td></tr></table></figure>

<p>2，对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作 </p>
<h3 id="有参宏"><a href="#有参宏" class="headerlink" title="有参宏"></a>有参宏</h3><p>可以让我们在定义宏时，还可以带参数扩大宏的应用范围，有参宏的格式</p>
<p><code>#define </code>标识符（参数列表） 字符串 </p>
<p>它的作用是在编译预处理时，将源程序中所有标识符替换成字符串，并且将字符串中的参数用实际使用的参数替换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define S(a,b) (ab)/2 </span><br></pre></td></tr></table></figure>

<p>需要注意的是，在宏定义时，宏名和参数之间不能有空格，否则空格后面的所有字符序列都作为替换的字符串。带参数的宏展开时，只作简单的字符和参数的替换，不进行任何计算操作，所以一般在定义宏时，字符串中的形式参数外面加一个小括号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define L(r) 2*PI*r </span><br></pre></td></tr></table></figure>

<p>如果源程序有L(2+3),则编译预处理后变为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">23.141592+3 不是 23.141595 </span><br></pre></td></tr></table></figure>

<p>解决办法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define L(r) 2PI*(r) </span><br></pre></td></tr></table></figure>

<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>文件包含的功能是将指定的文件内容嵌入到一个源文件中，文件包含共用以下两种格式 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\#include //标准方式 </span><br></pre></td></tr></table></figure>

<p>只按照标准方式在C语言编译器的C函数库头文件中查找要包含的文件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\#include &quot;xxxx.x&quot; //通用方式 </span><br></pre></td></tr></table></figure>

<p>先在源文件所在的目录中查找要包含的文件，若未能找到，则在按照标准方式查找</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h3><p>计算机内存是以字节为单位的存储空间，内存的每一个字节都有一个唯一的编号，这个编号就称为地址，当C程序中定义一个变量时，系统就分配一个带有一个唯一地址的存储单元来存储这个变量，程序对变量的读取操作(即变量的引用)，实际上是对变量所在存储空间进行写入或取出数据 </p>
<p>通常我们引用变量时是通过变量名直接引用变量，例如赋值运算b&#x3D;66，系统自动将变量名转换成变量的存储位置(即地址)，然后再将数据66放入变量b的存储空间中，这种引用变量的方式称为变量的“直接引用”方式 </p>
<p>此外，C语言中还有另一种称“间接引用”的方式，它首先将变量A的地址存放再一个变量B(存放地址的变量成为指针变量)中，然后通过存放变量地址的这个变量B来引用变量A<br>一个变量的地址称为该变量的指针，用来存放一个变量地址的变量名称为指针变量，当指针变量p的值为某变量的地址时，可以说指针变量p指向该变量</p>
<blockquote>
<p>定义变量的本质：开辟出一块空间，并用变量名代表那一片空间<br>内存空间的最小单位是字节，每一个字节都有一个编号，这个编号我们称之为地址。<br>有一种特殊的变量，专门存储地址，这种变量叫做指针变量，一般我们也简称为指针</p>
</blockquote>
<h3 id="基本使用方式"><a href="#基本使用方式" class="headerlink" title="基本使用方式"></a>基本使用方式</h3><p>指针的使用一般分为三步： </p>
<ol>
<li>定义指针变量</li>
<li>给指针变量赋值</li>
<li>指针解引用</li>
</ol>
<p>在这个过程中你需要使用到两个运算符：&amp;和* 定义指针变量</p>
<p>指针变量定义的一般形式为：<br>类型名<code>*</code> 指针变量名<br><code>int* pNums </code></p>
<p>注意：<br>（1）变量名前面的<code>*</code>是一个说明符，用来说明该变量是指针变量，这个<code>*</code>是不能省略的，但是			它不是变量名的一部分<br>（2）类型名表示指针变量所指向的变量的类型，而且只能指向这种类型的变量 </p>
<p>指针变量允许在定义时进行初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int nNumA, nNumB </span><br><span class="line">int *pA=&amp;nNumA，*pB=&amp;nNumB</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322112304615.png" alt="image-20220322112304615"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表示：定义了两个指向int型变量的指针变量pA和pB，pA的初值为变量nNumA的地址&amp;nNumA，pB的初值为变量nNumB的地址&amp;nNumB，不是表示*pA的初值为&amp;nNumA,*pB的初值为&amp;nNumB </span><br></pre></td></tr></table></figure>

<h3 id="给指针变量赋值"><a href="#给指针变量赋值" class="headerlink" title="给指针变量赋值"></a>给指针变量赋值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  nNum=<span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> *p1;</span><br><span class="line">   p1=&amp;nNum;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针变量的引用"><a href="#指针变量的引用" class="headerlink" title="指针变量的引用"></a>指针变量的引用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">	<span class="type">int</span>* p = <span class="number">0</span>;</span><br><span class="line">	p = &amp;a;</span><br><span class="line">	<span class="type">int</span> temp = *p;</span><br><span class="line">	*p = <span class="number">200</span>;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322112828709.png" alt="image-20220322112828709"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;a表示变量a的地址 </span><br><span class="line">*p表示指针变量p指向的变量* </span><br></pre></td></tr></table></figure>

<p>指针变量是用来存放地址的，不要给指针变量赋常量值，例如：<br><code>int* p</code>&#x3D;100; </p>
<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322113328807.png" alt="image-20220322113328807"></p>
<p>指针变量没有指向确定地址前，不要对它所指的对象赋值，例如：<br><code>int nNum=5, *p=nNum</code>; &#x2F;&#x2F;类型不匹配 </p>
<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322113519948.png" alt="image-20220322113519948"></p>
<h3 id="指针与函数传参"><a href="#指针与函数传参" class="headerlink" title="指针与函数传参"></a>指针与函数传参</h3><p>指针是间接引用，可以利用这一特性进行参数传递，使得函数内值的变化能够影响到函数外部</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">11</span>;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">22</span>;</span><br><span class="line">	swap(&amp;a, &amp;b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322114011810.png" alt="image-20220322114011810"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">11</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">22</span>;</span><br><span class="line">	swap(a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322114155187.png" alt="image-20220322114155187"></p>
<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322114220820.png" alt="image-20220322114220820"></p>
<h3 id="指针与一维数组"><a href="#指针与一维数组" class="headerlink" title="指针与一维数组"></a>指针与一维数组</h3><p>指针是可以有数学运算的但是指针的运算和它的类型昔昔相关</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span>* p1 = &amp;a;</span><br><span class="line">    p1 + <span class="number">1</span>;<span class="comment">//它并非会将地址+1，而是将地址加到下一个Int型的位置</span></span><br><span class="line">    p1++; <span class="comment">//实际上地址值会自增4</span></span><br><span class="line">    <span class="type">short</span>  b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">short</span>* p2 = &amp;b;</span><br><span class="line">    p2 + <span class="number">1</span>;<span class="comment">//同样的，它是将地址加到下一个short型的位置</span></span><br><span class="line">    p2++; <span class="comment">//实际上地址值会自增2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322114936268.png" alt="image-20220322114936268"></p>
<p>一维数组名其实是地址，并且一维数组名这个地址，她也是有类型的，就是一级指针类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  Array[<span class="number">5</span>] = &#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	<span class="type">int</span>* p = Array;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">0</span>]);<span class="comment">//和打印Array[0]，*(p+0)一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322115135402.png" alt="image-20220322115135402"></p>
<h2 id="结构体与联合体"><a href="#结构体与联合体" class="headerlink" title="结构体与联合体"></a>结构体与联合体</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体就是把具有内在联系的多个不同类型的数据结合成一个整体，使他们关联起来 </p>
<p>结构体类型定义的初级形式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strcut </span><br><span class="line">&#123; </span><br><span class="line">类型<span class="number">1</span> 成员名<span class="number">1</span>； </span><br><span class="line">。。。。 </span><br><span class="line">类型名n 成员名n </span><br><span class="line">&#125;结构体变量名=&#123;初始化元素<span class="number">1</span>，初始化元素<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  strcut&#123;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> score;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;People1;</span><br><span class="line"> <span class="comment">//1,使用结构体成员，通过&quot;.&quot;符号</span></span><br><span class="line"> <span class="comment">//2,使用的时候，就和普通变量一样</span></span><br><span class="line">People.age = <span class="number">18</span>;</span><br><span class="line">People.score = <span class="number">95</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简便模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  结构体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  类型名<span class="number">1</span>  成员名<span class="number">1</span>；</span><br><span class="line">  .....</span><br><span class="line">  类型名n  成员名n</span><br><span class="line">&#125;;</span><br><span class="line">这么写并非为了定义一个结构体变量，而是产生了一个结构体类型，如果需要，可以用这个类型定义无数的变量</span><br><span class="line">例如：</span><br><span class="line"><span class="number">1</span>，定义结构体类型定义</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  _<span class="title">PERSON</span>&#123;</span></span><br><span class="line"> <span class="type">char</span>  name[<span class="number">20</span>];</span><br><span class="line"> <span class="type">char</span>  sex;</span><br><span class="line">  <span class="type">int</span>  age;</span><br><span class="line">  <span class="type">float</span>  height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">2</span>，定义结构体变量</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  _<span class="title">PERSON</span>  <span class="title">abc</span></span></span><br><span class="line"><span class="class">1，表示定义了一个结构体类型<span class="keyword">struct</span> <span class="title">person</span>，它由<span class="title">name</span>,<span class="title">sex</span>,<span class="title">age</span>和<span class="title">height</span>四个成员组成</span></span><br><span class="line"><span class="class">2，表示定义一个结构体类型的变量</span></span><br></pre></td></tr></table></figure>

<p>中间模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">也可以在给结构体起名的同时定义一个变量，这也不常用</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PERSON</span>&#123;</span></span><br><span class="line"> <span class="type">char</span>  name[<span class="number">20</span>];</span><br><span class="line"> <span class="type">char</span>  sex;</span><br><span class="line"> <span class="type">int</span>  age;</span><br><span class="line"> <span class="type">float</span>  height;</span><br><span class="line">&#125;per1;</span><br><span class="line">per1就是_PERSON类型的变量c</span><br></pre></td></tr></table></figure>

<p>结构体嵌套</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  _<span class="title">PERSON</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> score;</span><br><span class="line">  <span class="type">char</span>  name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="comment">//定义一个结构体变量，初始化结构体变量，放在&#123;&#125;中</span></span><br><span class="line"> _PEOPLE  stcPeople = &#123;<span class="number">18</span>,<span class="number">100</span>,<span class="string">&quot;xiaoming&quot;</span>&#125;;</span><br><span class="line"> <span class="comment">//使用结构体变量</span></span><br><span class="line"> strPeople.age=<span class="number">18</span>;</span><br><span class="line"> stcPeople.score=<span class="number">95</span>;</span><br><span class="line"> strcpy_s(stcPeople.name,<span class="number">20</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">注意：不能嵌套自己本身，但能够嵌套自己类型的指针</span><br></pre></td></tr></table></figure>

<h3 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h3><p>将结构体变量各成员的初值顺序地放在一对大括号中，并用逗号分隔； </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span> </span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>]; </span><br><span class="line"><span class="type">char</span> sex; </span><br><span class="line"><span class="type">int</span> age; </span><br><span class="line"><span class="type">float</span> height; </span><br><span class="line">&#125;per=&#123;<span class="string">&quot;Li Ping&quot;</span>,<span class="string">&quot;M&quot;</span>,<span class="number">20</span>,<span class="number">175.5</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="结构体变量的引用"><a href="#结构体变量的引用" class="headerlink" title="结构体变量的引用"></a>结构体变量的引用</h3><p>结构体变量的引用必须在定义结构体变量后进行，对结构体变量的引用可以分为对结构体变量中成员的引用和对整个结构体变量的引用。引用结构体成员的一般形式为：<br>结构体变量名.成员名<br>“.”时成员运算符，它在所有运算符中优先级最高<br>如果某个成员本身又是结构体变量，则必须连续使用成员运算符，直到最低一级成员才能进行运算，结构体变量的每个成员都属于某种数据类型，因此都可以像普通变量一样进行其类型允许的各种操作</p>
<h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><p>定义结构体数组的方法和定义结构体变量的方法一样，定义结构体变量的三种方法都可以用来定义结构体数组<br>定义结构体数组不常用这种方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strcut  person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span>  name[<span class="number">20</span>];</span><br><span class="line">  <span class="type">char</span>  sex;</span><br><span class="line">  <span class="type">int</span>  age;</span><br><span class="line">  <span class="type">float</span>  height;</span><br><span class="line">&#125;per[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>常用方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strcut  person</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  name[<span class="number">20</span>];</span><br><span class="line">   <span class="type">char</span>  sex;</span><br><span class="line">   <span class="type">int</span>  age;</span><br><span class="line">   <span class="type">float</span>  height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">person</span> <span class="title">per</span>[3];</span></span><br></pre></td></tr></table></figure>

<h3 id="联合体类型"><a href="#联合体类型" class="headerlink" title="联合体类型"></a>联合体类型</h3><p>联合体的基本语法<br>联合体有时也被称为共用体，其基本使用语法，和结构体一样。只有关键字是(union)。<br>定义形式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>  联合体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  类型名<span class="number">1</span>  成员名<span class="number">1</span>；</span><br><span class="line">  ......</span><br><span class="line">  类型名n  成员名n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联合体与结构体的区别"><a href="#联合体与结构体的区别" class="headerlink" title="联合体与结构体的区别"></a>联合体与结构体的区别</h3><p>结构体，每一个成员单独占用内存空间<br>联合体，所有的成员共享一块空间<br>联合体的应用</p>
<p>通常来说有两种用途<br>1，同一个数据需要多种表现形式<br>2，在互斥情况之下的节省空间</p>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>定义新类型名的一般形式<br>typedef 类型名 表示符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span>  INT;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> * PINT</span><br><span class="line"> <span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">   INT num2 =<span class="number">20</span>;</span><br><span class="line">   PINT  pInt = <span class="literal">NULL</span>;</span><br><span class="line">   pInt=&amp;num;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*pInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了类型定义之后，就可以用新的名字代替原来的名字定义变量</p>
<p>使用typedef语句不是创造新类型，而是为已经存在的类型增加了一个名字，目前来看，最为常用的使用方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  _<span class="title">PEOPLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span>  nAge;</span><br><span class="line">  <span class="type">int</span> nScore;</span><br><span class="line">  <span class="type">char</span>  szName[<span class="number">20</span>];</span><br><span class="line">&#125;PEOPLE,*PPEOPLE  <span class="comment">//给结构体类型起一个新的名字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  _<span class="title">PEOPLE</span>  <span class="title">stcPeople1</span> =</span> &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="string">&quot;xiaoming&quot;</span>&#125;;</span><br><span class="line">  PEOPLE stcPeople = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="string">&quot;xiaoming&quot;</span>&#125;; <span class="comment">//这里使用新名字定义变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个C语言的遗留问题，在C语言中，定义结构体变量，必须使用上述代码斜体的方式。<br>为了省略一个struct，所以重定义类型名，这种用法一直用到了现在。并且遗留带来C++中。但是我们知道C++中定义结构体变量本身也不需要加struct。这不算尴尬，尴尬的是大家现在都知道C++定义结构体或者联合体变量不需要加struct，很多地方依然保留C语言的习惯，尤其在windows开发中。</p>
<h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><h3 id="堆内存的动态分配"><a href="#堆内存的动态分配" class="headerlink" title="堆内存的动态分配"></a>堆内存的动态分配</h3><p>在程序设计中，对于要处理的批量数据，我们往往是选用数组作为存放这些数据的数据结构，然而，数组有一个明显的缺点，就是在定义数组时，其长度必须时常值，无法根据需要动态地定义。这样，在很多情况下不是定义的数组长度不够，就是定义太长以至于浪费。</p>
<p>采用动态分配可以客服这一缺点，并且可以随时释放</p>
<p>动态分配内存空间的步骤 </p>
<ol>
<li>定义一个指针变量： </li>
<li>申请一片内存空间，并将其首地址赋给指针变量，此时便可通过指针变量访问这片内存</li>
<li>用完后释放这片内存空间<br>在这里主要涉及两个函数，即malloc-申请空间，free-释放空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//malloc这个函数，参数要申请的大小(字节)</span></span><br><span class="line">  <span class="comment">//返回值，就是申请成功之后，申请出空间的起始地址</span></span><br><span class="line">  p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  *p = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br><span class="line">  <span class="comment">//释放掉申请出的空间</span></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322160824495.png" alt="image-20220322160824495"></p>
<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322160847563.png" alt="image-20220322160847563"></p>
<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322160921824.png" alt="image-20220322160921824"></p>
<h3 id="使用堆和使用数组的差别"><a href="#使用堆和使用数组的差别" class="headerlink" title="使用堆和使用数组的差别"></a>使用堆和使用数组的差别</h3><ul>
<li>数组长度只能是常量，堆大小可以是变量</li>
<li>堆，需要自己释放，假如不释放，或者忘记释放，就会造成内存泄漏。数组，不需要自己释放。</li>
</ul>
<h3 id="关于悬空指针与野指针"><a href="#关于悬空指针与野指针" class="headerlink" title="关于悬空指针与野指针"></a>关于悬空指针与野指针</h3><h4 id="悬空指针"><a href="#悬空指针" class="headerlink" title="悬空指针"></a>悬空指针</h4><p>我们释放了内存之后，指针，应该被及时的赋值为NULL，不赋值为NULL的话，称为悬空指针 </p>
<h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><p>指针变量被定义之后，没有被初始化，这种指针被称为野指针<br>总结：指针变量，要么指向有意义的地方(变量，数组，堆)，要么就指向NULL(0);</p>
<h2 id="一个程序的内存划分"><a href="#一个程序的内存划分" class="headerlink" title="一个程序的内存划分"></a>一个程序的内存划分</h2><p>通常来说，一个运行当中的程序，内存会划分为5各个区域 </p>
<p>代码区，常量区，栈区，堆区，全局数据区<br>常量区：字符串<br>栈区 ：局部变量<br>堆区 ：malloc出来的区域<br>全局数据区：全局变量，static局部变量</p>
<p><strong>其他内存操作函数</strong></p>
<h3 id="内存初始化函数memset"><a href="#内存初始化函数memset" class="headerlink" title="内存初始化函数memset"></a><strong>内存初始化函数memset</strong></h3><p>其原型为： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void memset（起始地址，要设置的值，要设置多大区域）</span><br></pre></td></tr></table></figure>

<p>一般用于给刚申请出的内存，设置一个初始值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">	p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="built_in">memset</span>(           <span class="comment">//通常我们使用这个函数给申请地空间初始化为0</span></span><br><span class="line">		p,            <span class="comment">//起始地址</span></span><br><span class="line">		<span class="number">1</span>,            <span class="comment">//设置地值</span></span><br><span class="line">		<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)  <span class="comment">//大小</span></span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322162249087.png" alt="image-20220322162249087"></p>
<h3 id="内存拷贝函数memcpy"><a href="#内存拷贝函数memcpy" class="headerlink" title="内存拷贝函数memcpy"></a>内存拷贝函数memcpy</h3><p>其原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void memcpy(目标地址，源数据地址，要拷贝多大区域) </span><br></pre></td></tr></table></figure>

<p>一般用于要把内存中的数据考到另一块内存中</p>
<p>使用堆，实际上就大量的会使用指针，记住以下原则 </p>
<ul>
<li>刚刚分配的动态内存的初始值是不确定的 </li>
<li>不能对同一指针(地址)连续两次进行free操作 </li>
<li>不能对指向静态内存区（全局变量）或栈内存区（局部变量）的指针应用free（但可以对空指针NULL应用free），对一个指针应用free之后，它的值不会改变，但它指向了一个无效的内存区，这个也就是上面讲的“悬空指针” </li>
<li>如果没有及时释放某块动态内存，并且将指向它的指针指向了别处，就会造成“内存泄漏”，执行malloc和free函数有一定代价，所以对于较小的数据量不应该放在动态内储中，并且尽量避免频繁地分配和释放内存</li>
</ul>
<p>进行内存区域地申请时，主要需注意避免发生以下错误：</p>
<ul>
<li>内存分配未成功，却用了它 </li>
<li>内存分配虽然成功，但是尚未初始化就引用它。(误认为初始值为0) </li>
<li>内存分配成功并且已经初始化，但操作超过了内存地边界 </li>
<li>忘记了释放内存，造成内存泄漏 </li>
<li>释放了内存却继续使用它</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一级指针地使用方式和数组类似</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">  p[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">p=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//此时释放地就是后面申请，前面申请地地址丢失了，也就无法释放了</span></span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//此时使用了悬空指针</span></span><br><span class="line"><span class="comment">//p=&amp;Num;</span></span><br><span class="line"><span class="comment">//free(p);不能释放除了堆空间之外地内存</span></span><br><span class="line"><span class="comment">//free(p);错误对同一块堆空间，不能释放两次</span></span><br><span class="line"><span class="comment">//p=NULL;及时置为空，配合下main地代码，就会避免悬空指针地使用</span></span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//一般我们使用指针之前，检测一下是不是空指针是一个好习惯 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针进阶"><a href="#指针进阶" class="headerlink" title="指针进阶"></a>指针进阶</h2><h3 id="指针算术运算"><a href="#指针算术运算" class="headerlink" title="指针算术运算"></a>指针算术运算</h3><p>指针能够支持一些算术运算，不过含义和普通地数据地算数运算非常不同<br>首先指针只能进行加法和减法运算： </p>
<p>并且只有两种形式： </p>
<ol>
<li>指针+(-)整数 </li>
<li>指针-指针</li>
</ol>
<p>指针加或者减一个整数地话，得到地数据类型还是一个指针。得到地数据值是+(-)整数sizeof(整数类型)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a[] = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">	<span class="type">int</span>* ptr = (<span class="type">int</span>*)a;</span><br><span class="line">	<span class="type">char</span>* cp = a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">	<span class="keyword">while</span> (*ptr != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *ptr);</span><br><span class="line">		ptr++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//while(*cp!=&#x27;\0&#x27;)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	printf(&quot;%c\n&quot;,*cp);	</span></span><br><span class="line">	<span class="comment">//	cp++;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针-指针得到地是这两个地址间能够存放多少个这种类型地数据 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* p1 = &amp;a;</span><br><span class="line">    <span class="type">int</span>* p2 = &amp;b;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = p1 - p2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1= %x\n&quot;</span>, p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2= %x\n&quot;</span>, p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num的地址=%x, num=%d\n&quot;</span>, &amp;num, num);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322164223393.png" alt="image-20220322164223393"></p>
<h3 id="指针与一维数组-1"><a href="#指针与一维数组-1" class="headerlink" title="指针与一维数组"></a><strong>指针与一维数组</strong></h3><p>数组名就是数组地起始地址，也就是第一个元素地地址，数组名是个常量指针</p>
<p>类型地变化规律</p>
<ul>
<li>对变量取地址，得到地是地址，类型为一级指针类型 </li>
<li>数组名，也是一级指针类型 </li>
<li>对一级指针解引用，得到的是相应的数据类型 </li>
<li>对一级指针类型用下标运算符，得到的是相应数据类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span>* p = a; <span class="comment">//这里数组名a,可以看成整形指针类型</span></span><br><span class="line">	<span class="type">int</span> *m = a + <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> *m1 = &amp;a[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> *m2 = p + <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> *m3 = &amp;p[<span class="number">2</span>];<span class="comment">// 表示同一个一级指针类型的同一地址</span></span><br><span class="line">	<span class="type">int</span> n = *(a + <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> n1 = *&amp;a[<span class="number">2</span>];c</span><br><span class="line">	<span class="type">int</span> n2 = *(p + <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> n3 = *&amp;p[<span class="number">2</span>]; <span class="comment">// 都表示Int型，数据是a[2];</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322164812275.png" alt="image-20220322164812275"></p>
<h3 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h3><p>二维数组名也是一个指针类型，叫做一维数组指针类型 </p>
<p>我们自己定义一维数组指针：类型名（*变量名）[数组长度] </p>
<p>注意：<br>对于数组指针，应该给出所指向数组的长度 </p>
<p>类型变化规律:</p>
<ol>
<li>对一维数组指针解引用就会降维，变成一级指针 </li>
<li>对一维数组指针使用下标运算符也会降维，变成一级指针 </li>
<li>对于一维数组指针+1，会得到下一排起始地址，类型还是数组指针 </li>
<li>对于一维数组名取地址，会变为二维数组指针，数值不变</li>
</ol>
<h3 id="指针与多维数组"><a href="#指针与多维数组" class="headerlink" title="指针与多维数组"></a>指针与多维数组</h3><p>多维数组指的是一维以上的数组，其数组名为多维数组指针类型 </p>
<p>转换规律</p>
<ol>
<li>对多维数组指针解引用会降维，变成降一维的数组指针，直到降成一级指针 </li>
<li>对数组指针使用下标运算符也会降维，直到降维成一级指针 </li>
<li>对于数组指针+1，会得到下一个数组的起始地址，类型不变 </li>
<li>对多维数组名取地址，会变为更高维度的数组指针，数值不变</li>
</ol>
<h3 id="指针数组与数组指针"><a href="#指针数组与数组指针" class="headerlink" title="指针数组与数组指针"></a>指针数组与数组指针</h3><ul>
<li>指针数组：指针数组可以说成是”指针的数组”，首先这个变量是一个数组，其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型，在32位系统中，指针占四个字节。</li>
<li>数组指针：数组指针可以说成是”数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。<br>根据上面的解释，可以了解到指针数组和数组指针的区别，因为二者根本就是种类型的变量。</li>
</ul>
<p><strong>指针数组</strong><br>指针数组就是其元素为指针的数组<br>每一个元素都是指针变量<br>说明指针数组的语法格式为<br>数据类型 * 指针数组名[常量表达式]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *arr[4] = &#123;&quot;hello&quot;, &quot;world&quot;, &quot;shannxi&quot;, &quot;xian&quot;&#125;;</span><br><span class="line">//arr就是我定义的一个指针数组，它有四个元素，每个元素是一个char *类型的指针，这些指针存放着其对应字符串的首地址。</span><br></pre></td></tr></table></figure>

<p><strong>数组指针</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char (*pa)[4];</span><br></pre></td></tr></table></figure>

<p>如果指针数组和数组指针这俩个变量名称一样就会是这样：char *pa[4]和char (*pa)[4]，原来指针数组和数组指针的形成的根本原因就是运算符的优先级问题</p>
<p>注意指针数组与数组指针的区别 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *p[5];//一级指针数组 </span><br><span class="line">int **p[5]; //二级指针数组 </span><br><span class="line">int (*p2[5])[10]; //数组指针数组 </span><br></pre></td></tr></table></figure>


<p>指针数组存储的是指针，二维数组存储的是数据</p>
<h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><p>一般称为数据流，也有叫做字节流，比特流的，还有很具体的文件流，视频流，音频流等</p>
<p>文件是指存储在计算机外部存储中的数据的集合。计算机根据文件的名字，完成对文件的操作，C语言将文件看作是字符构成的序列，即字符流，其基本的存储单位是字节，C语言中的文件，按照它的ASCII代码存放，称为ASCII文件或文本(text)文件，按照数据值的二进制代码存放，称为二进制中 </p>
<p>ASCII文件中的字节与实例字符一一对应，方便字符处理和用户阅读，但占用存储空间较大，而二进制文件节省存储空间，也无需ASCII代码和二进制形式之间的转换时间，但是无法直接输出，一般用于程序与程序之间或者程序与设备之间数据的传递</p>
<p>在C语言中，文件可以是磁盘文件，终端显示器或打印机等等，程序通过打开操作把流与设备联系起来，文件打开后，可以在程序和文件之间交换数据，程序通过关闭操作断开流与文件的联系，所有流的性质都一样，因为流与设备无关，所以能写入磁盘文件的同意函数也能写入另一设备，如控制终端等，但文件的能力则可能不同，例如，磁盘文件可以支持随机存取，而键盘则不行，数据必须按照存入的类型读出，才能回归其本来面貌</p>
<h3 id="文件访问的基本模式"><a href="#文件访问的基本模式" class="headerlink" title="文件访问的基本模式"></a>文件访问的基本模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; open：打开文件，获得对此文件的指针，引用和句柄等，以证明可以使用此文件</span><br><span class="line">&gt; read：读文件，参数一般指明要读多少字节，读到哪块内存，每次调用此功能，都是接着上次调用的结束位置读。（所以是个输入流）</span><br><span class="line">&gt; write：写文件，参数一般指明把哪块内存的内容写入文件，要写多少字节，每次调用此功能，都是接着上次调用的结束位置写。（所以是个输出流）</span><br><span class="line">&gt; close：关闭文件，表明操作结束，不再使用此文件，文件使用完毕必须关闭，否则影响系统性能</span><br><span class="line">&gt; seek：随机控制流的当前位置，文件定位</span><br></pre></td></tr></table></figure>

<p><strong>定义一个指向文件结构体类型的指针变量的形式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FILE * 指针变量名</span><br><span class="line">FILE *fpFile</span><br></pre></td></tr></table></figure>

<p>则fpFile是可以指向一个FILE文件结构体的指针变量，文件指针变量的赋值操作是由打开文件函数fopen()实现的</p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>fopen()函数的原型是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FILE *fopen(char *filename,char *mode)</span><br><span class="line"></span><br><span class="line">FILE *fpFile=fopen(C:\\File.txt&quot;,&quot;r);</span><br></pre></td></tr></table></figure>

<p><strong>C语言的文件打开模式一览</strong></p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>处理方式</th>
<th>文件不存在</th>
<th>文件存在</th>
<th>向文件输入</th>
<th>从文件输出</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读取</td>
<td>出错</td>
<td>打开文件</td>
<td>不能</td>
<td>可以</td>
</tr>
<tr>
<td>w</td>
<td>写入</td>
<td>建立新文件</td>
<td>覆盖原文件</td>
<td>可以</td>
<td>不能</td>
</tr>
<tr>
<td>a</td>
<td>追加</td>
<td>建立新文件</td>
<td>在源文件后追加</td>
<td>可以</td>
<td>不能</td>
</tr>
<tr>
<td>r+</td>
<td>读取&#x2F;写入</td>
<td>出错</td>
<td>打开文件</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>w+</td>
<td>写入&#x2F;读取</td>
<td>建立新文件</td>
<td>覆盖源文件</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>a+</td>
<td>读取&#x2F;追加</td>
<td>建立新文件</td>
<td>在源文件后追加</td>
<td>可以</td>
<td>可以</td>
</tr>
</tbody></table>
<p>如果是二进制文件，在使用时只要在模式后添加字符b即可，如“rb”,”rb+”分别表示读取二进制文件和以读取&#x2F;写入模式打开二进制文件，如果由于文件不存在等原因造成不能打开文件，则调用fopen()后将返回一个空指针NULL,我们可以用如下代码检查文件是否打开成功</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((fpFIle=fopen(<span class="string">&quot;c:\\File.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Cannot open the file.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般exit(0)表示程序正常退出，exit(非零值)表示程序出错后退出</p>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>当C语言文件使用完后，应该立即关闭文件，防止由于误操作等原因破坏已经打开的文件。文件 的关闭通过stdio.h中的fclose()函数实现，具体用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fclose(文件指针)；</span><br><span class="line">fclose(fpFIle);</span><br></pre></td></tr></table></figure>

<p>程序将文件类型指针fpFile所指向的文件关闭，fpFile不再指向该文件</p>
<h3 id="文件的读写操作"><a href="#文件的读写操作" class="headerlink" title="文件的读写操作"></a>文件的读写操作</h3><p>C语言提供多种对文件的读取和写入的函数，四种常用的文件的读写操作函数,他们都在头文件stdio.h定义的</p>
<ol>
<li>按字符读写的函数fgetc(), fputc()</li>
<li>按字符串读写的函数fgets(), fputs()</li>
<li>按格式要求读写的函数fprint() , fscanf()</li>
<li>按数据块读写的函数fread(), fwrite()</li>
</ol>
<p>函数fputc()的作用是向文件写入一个字符，其调用形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(字符，文件型指针变量);</span><br><span class="line">fputc(<span class="string">&#x27;A&#x27;</span>,fpFile);</span><br></pre></td></tr></table></figure>

<p>fpFile为一个文件类型指针变量，上式将字符常量’A’（也可以是字符型变量）写入文件当前位置，并且使文件位置指针下移一个字节，如果写入操作成功，返回值是该字符，否则返回EOF</p>
<p>函数fgetc()的作用使从一个文件中读取一个字符。其调用形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fgetc(文件型指针变量)</span><br><span class="line"><span class="type">char</span>  cChar = fgetc(fpFile);</span><br></pre></td></tr></table></figure>

<p>fpFile为一个文件类型指针变量，函数fgetc(fpFile)不仅返回文件当前位置的字符，并且使文件位置指针下移一个字符，如果遇到文件结束，则返回值为文件结束标志EOF。</p>
<p>函数fputs()的作用使向文件写入一个字符串，其调用形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fputs(字符串，文件型指针变量)；</span><br></pre></td></tr></table></figure>

<p>其中字符串可以是字符串常量，指向字符串的指针变量，存放字符串数组的数组名，写入文件成功，函数返回值为0，否则为EOF。</p>
<p>注意：字符串的结束标志‘\0’不写入，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fputs(&quot;Hello&quot;,fpFile);</span><br></pre></td></tr></table></figure>

<p>fpFile为一个文件类型指针变量，上式将字符串的字符H,e,l,l,o写入文件指针的当前位置</p>
<p>函数fprintf()的作用与printf()相似，只是输出对象不是标准输出设备而是文件，即按照格式要求将数据写入文件。它调用的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(文件型指针变量，格式控制，输出列表);</span><br><span class="line"><span class="built_in">fprintf</span>(fpFile,<span class="string">&quot;%ld,%s&quot;</span>,num,name);</span><br></pre></td></tr></table></figure>

<p>它的作用使将变量num，name按照%ld，%s的格式写入fp指向的文件的当前位置。函数scanf()从通过标准输入设备读取数据，</p>
<p>同样函数fscanf()按照格式要求从文件中读取数据，它调用的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fscanf</span>(文件指针变量，格式控制，输入列表)</span><br><span class="line"><span class="built_in">fscanf</span>(fpFile,<span class="string">&quot;%ld,%s&quot;</span>,&amp;num,name)</span><br></pre></td></tr></table></figure>

<p>它的作用是从fpFile指向的文件的当前位置开始，按照%ld，%s的格式取出数据，赋给变量Num,name,fscanf()主要用于数据文件的读写，即可以使用ASCII文件也可以使用二进制文件。</p>
<p>函数fwrite()的作用是将成批的数据块写入文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fwrite(存放地址，数据块个数，文件型指针变量)</span><br></pre></td></tr></table></figure>

<p>如果函数fwirte()操作成功，则返回值为实际写入文件的数据块的个数。</p>
<p>例如，已知struct  student类型数组stu[20],则语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fwrite(&amp;stu[1],sizeof(struct  student),2,fp);</span><br></pre></td></tr></table></figure>

<p>从结构体数组元素stu[1]存放的地址开始，以一个结构体struct  student类型变量所占字节数为一个数据块，共写入文件类型指针fp指向的文件2个数据块，即stu[1],stu[2]的内容写入文件，如果操作成功，函数的返回值为2</p>
<h3 id="其他常用的文件操作函数"><a href="#其他常用的文件操作函数" class="headerlink" title="其他常用的文件操作函数"></a>其他常用的文件操作函数</h3><p>函数feof()用来检测一个指向文件的指针是否已经指到了文件最后的结束标志EOF，调用的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feof(文件型指针变量)；</span><br><span class="line">bool  bIsEnd = !feof(fpFile);</span><br></pre></td></tr></table></figure>

<p>如果文件型指针指向的文件的当前位置为结束标志EOF，则函数返回一个非零值，否则返回0值</p>
<p>函数rewind()将指向文件的指针重新指向文件的开始位置，函数无返回值，其调用形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rewind(文件型指针变量)；</span><br><span class="line">rewind(fpFile);</span><br></pre></td></tr></table></figure>

<p>fpFile是一个指向文件的指针，执行该语句后，fpFile指向文件的开始位置，即文件的第一个数据</p>
<p>函数fseek()可以将使得指向文件的指针变量指向文件的任何一个位置，实现随机读写文件，它调用的形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fseek(文件型指针变量，偏移量，起始位置)；</span><br><span class="line">fseek(fpFile,<span class="number">0x123</span>,SEEK_SET);</span><br></pre></td></tr></table></figure>

<p>函数fseek()将以文件的起始位置为基准，根据偏移量往前或往后移动指针。其中偏移量是一个长整形数，表示从起始位置移动的字节数，正数表示指针往后移，负数表示指针往前移。起始位置用宏SEEK_SET，SEEK_END代表文件开始，文件当前位置和文件结束位置，如果指针设置成功，返回值为0，否则为非0值</p>
<p>函数ftell()用于测试指向文件的指针的当前位置。它的调用方式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ftell(文件型指针变量)</span><br><span class="line"><span class="type">int</span> nOffset=ftell(fpFile);</span><br></pre></td></tr></table></figure>

<p>函数的返回值是一个常整形数，如果测试成功，则返回指向文件的指针当前指向的位置距离文件开头的字节数，否则返回-1L.</p>
<h2 id="源文件组织原则"><a href="#源文件组织原则" class="headerlink" title="源文件组织原则"></a>源文件组织原则</h2><p>同一类型或同意功能的代码，用一个.c文件与一个.h文件保存，头文件中不能有可执行代码，也不能有数据的定义，只能有宏，类型(typedef,struct,union,menu)，数据和函数的声明</p>
<p>头文件中不能包本地数据（即模块自己使用的数据或函数）。只有模块自己使用的函数，数据，不要用extern在头文件里声明，只有模块自己使用的宏，常量，类型也不要在头文件里声明，应该在自己的*.文件里声明，防止重复包含，使用宏“#pragma  once”防止一个头文件被重复包含</p>
<p>文件名和实现模块的c文件相同，例如“abc.c”对应的头文件应该是”abc.h”。不要包含那些只有在本模块中才使用的头文件，这些头文件应该在*c文件中包含。接口文件要有面向用户的充足的注释，接口文件在发布后尽量避免修改，即使修改也要保证不影响用户程序</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>C</title>
    <url>/2022/03/15/C/</url>
    <content><![CDATA[<img src="/2022/03/15/C/images1.jpg" alt="images1" style="zoom:200%;">

<span id="more"></span>

<h1 id="计算机中的数据"><a href="#计算机中的数据" class="headerlink" title="计算机中的数据"></a>计算机中的数据</h1><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><p>逢16进1，每一位都是16的整数次幂（基数16），符号：“H”</p>
<h2 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h2><p>逢10进1</p>
<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>逢2进1，每一位都是2的整数次幂(基数2) ，符号：“B” </p>
<h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><p>逢8进1，每一位都是8的整数次幂(基数是8) ，符号：”O” </p>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><p>逆序取余</p>
<p>二进制数得到每一位就是十进制数每次除以2得到余数，最后把所有的余数倒着排列，就得到二进制数 </p>
<p>10的二进制</p>
<p>10除以2得5余0</p>
<p>5除以2得2余1</p>
<p>2除以2得1余0</p>
<p>1除以2得0余1</p>
<p>整数10的二进制就是1010</p>
<h3 id="八进制转十六进制"><a href="#八进制转十六进制" class="headerlink" title="八进制转十六进制"></a>八进制转十六进制</h3><p>方法：</p>
<p>以二进制位中介，即先将八进制数按照一位拆三位的方法转换为二进制，在对这个二进制数使用四位合一位的方法转换为十六进制</p>
<p>规则：</p>
<p>整数部分从低位向高位每3位用一个等值的八进制来替换，不足3位时在高位补0凑满3位<br>小数部分从高位向低位每3位用一个等值八进制数来替换，不足3位时在低位补0凑满3位 </p>
<p>十进制：16</p>
<p>八进制：20</p>
<p>二进制：010 000</p>
<p>十六进制：10</p>
<h2 id="计算机中存储单位"><a href="#计算机中存储单位" class="headerlink" title="计算机中存储单位"></a>计算机中存储单位</h2><p>位是计算机中数据最小单位，它表示一个二进制数，0或者1，英文是Bit </p>
<p>字长是CPU的主要技术指标之一，指的是一次最大能并行处理的二进制位数</p>
<p>Byte 表示字节，一个字节是8位<br>word是两个字节，也就是16位<br>dword是四个字节，也就是32位</p>
<h2 id="源码反码补码关系"><a href="#源码反码补码关系" class="headerlink" title="源码反码补码关系"></a>源码反码补码关系</h2><p><strong>正数：</strong></p>
<p>​	三码合一 </p>
<p><strong>负数：</strong><br>    原码：最高位不变，后面数据和其绝对值相同<br>    反码：将源码除最高位，其余安位取反<br>    补码：将反码+1 </p>
<p><strong>例如：</strong><br>1 010 1010 （原）<br>1 101 0101 （反码：符号位不变，其他位按位取反）<br>1 101 0110 （补码:反码+1）<br>在计算机中保存的都是补码，使用补码的目的是将减法运算转换为加法运算</p>
<h1 id="C基础"><a href="#C基础" class="headerlink" title="C基础"></a>C基础</h1><p>一个程序包含哪些东西</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include //编译预处理命令 </span><br><span class="line">#include //编译预处理命令 </span><br><span class="line">int main(void) //程序启动函数 </span><br><span class="line">&#123; //函数开始标志 </span><br><span class="line">	printf(&quot;Hello world&quot;); //库函数输出信息 </span><br><span class="line">	system(&quot;pause&quot;); //让程序暂停一下 </span><br><span class="line">	return 0； //函数退出返回0 </span><br><span class="line">&#125; //程序结束标志</span><br></pre></td></tr></table></figure>

<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>1，编写好源代码<br>2，编译前，进行预处理<br>3，进行编译，生成obj文件<br>4，进行连接，生成可执行文件<br>5，生成目标程序，即可以运行<br>其中，预处理，编译，连接可以使用VS一键完成，也就是只要你写好了源代码，直接可以生成能够执行的程了。</p>
<p>（main 函数 ，预处理 ，库函数 ，关键字，注释）</p>
<p><strong>VS中的默认main函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int  _tmain(int argc, _TCHAR*  argv[])</span><br><span class="line">&#123;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>预处理</strong></p>
<p>以#号开头的命令(通常称为指令)，他是在程序编译之前进行的处理，通常会对文件做一些复制，替换等操作</p>
<p><strong>为什么要使用#includ</strong> </p>
<p>对于本程序而言#include的作用是包含stdio函数库，包含了函数库头文件之后，就可以使用其中的函数。<br><code>#include</code>有两种形式<br>1)#include “文件名” 在当前工程目录中会找到该头文件<br>2)#include &lt;文件名&gt; 在vs自带的头文件夹中去找该头文件</p>
<p><strong>库函数</strong></p>
<p>C语言已经写好的代码，直接提供给开发者使用，提供的代码就叫做库函数，使用相应的库函数，必须要先包含相应的头文件</p>
<p><strong>关键字</strong></p>
<p>被赋予了某些特殊含义的单词，不能用于其他任何目的，所有的关键字小写，C语言中的关键字32个</p>
<p><img src="/2022/03/15/C/image-20220315163741780.png" alt="image-20220315163741780"></p>
<h2 id="数据类型及变量"><a href="#数据类型及变量" class="headerlink" title="数据类型及变量"></a>数据类型及变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>整型，就是整数</li>
<li>浮点型，就是小数 </li>
<li>字符型，就是文本符号</li>
</ul>
<h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><p><strong>常量</strong><br>常量就是固定不变的数据，根据类型有以下四种:<br>1、整形常量<br>所有整数（正整数，负整数，零）<br>2、浮点型常量<br>所有小数。<br>3、字符常量<br>普通字符，用单引号括起来的一个字符(不包括单引号本身)如：’A’，’1‘.<br>4、字符串常量<br>用双引号括起来的若干个字符串（不包括双引号本身）如：“hello world”</p>
<p><strong>变量</strong> </p>
<p>变量就是一块有名字的内存空间，我们可以通过变量的名字来为其背后的内存空间填充数据，或者使用内存空间中的数据</p>
<p>定义变量<br>变量类型 变量名 &#x3D; 初始值</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int num =10;</span><br><span class="line">  num=200;</span><br><span class="line">  printf(&quot;%d&quot;,num+100);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int 是整数型，num就是变量名，10就是变量的初始值，变量可以被修改，也可以参与运算。当变量被定义之后，自动就开辟出了空间，变量名就代表这片空间了 ，可以通过VS的自动窗口，局部变量窗口，监视窗口动态的查看变量的值</p>
<p><strong>变量类型</strong></p>
<p>整数：int short long<br>小数：float double<br>字符：char wchar_t<br>另外还有一个关键字：unsigned可以修饰整数和字符，可以表示无符号数（就是正数）</p>
<h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a><strong>字符类型</strong></h2><p>字符类型本质上说，也是数字。有一个美国国家标准协会指定了一个标准，用0<del>127之间的数字代表不同的字符。所以每一个字符都和一个数字一一对应。美国人制定的这个标准称之为ASCII ，一个字节能表示0</del>255，所以存储一个普通的英文符只需要一个字节，故而char也就是1个字节大小， wchar就是用来存储复杂字符的，而且他是两个字节，共有65536个状态。 </p>
<p>定义char型字符变量，直接使用char即可，赋值的但字符需要用’ ‘括起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char  ch  = &#x27;A&#x27;</span><br></pre></td></tr></table></figure>

<p>定义wchar_t型字符变量，直接使用wchar_t，需要注意的是字符要用这种格式L’ ‘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wchar_t   ch  = L&#x27;A&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="标识符的命名规则"><a href="#标识符的命名规则" class="headerlink" title="标识符的命名规则"></a>标识符的命名规则</h2><p>1，只能由字母（A<del>Z，a</del>z)，数字(0~9),下划线(_)组成<br>2，数字不能开头<br>3，不可以使用关键字<br>4，C语言中的标识符区分大小写 </p>
<p><strong>字符型与数字</strong></p>
<p>字符型与整数类型没有本质的区别，都表示数字，只是，字符类型所能表示的数字被人为设计与不同的字符一一对应，所以字符类型的变量也可以用于数学计算，只是它表示的数据范围有限。有符号的情况下<br>(char -128<del>127,wchar_t -32768</del>32767) </p>
<p><strong>字符串</strong></p>
<p>C语言中还有一种类型叫做字符串常量，但是没有一个变量能够存储字符串常量，需要借助于字符数组或指针<br>字符串的表示方式：使用双引号扩起来<br>列如:char szCh[]&#x3D;”adsfgh23435” </p>
<p><strong>标识符</strong></p>
<p>编程的时候，有许多需要命名的对象，比如函数名，变量名等，这些名称叫做标识符 </p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>匈牙利命名法的变量名由一个或多个小写字母开始，这些字母由助于记忆变量的类型和用途，紧跟着的就是程序员 选择的任何名称，而在最前面加入前缀m_,s_,g_表示变量的作用域类型<br>匈牙利命名法的目标是便于记忆，而且使变量名清晰易懂，（一看变量名就知道他是什么类型，知道是干什么用的），增强了代码的可读性，方便程序员之间相互交流代码</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Windows</tag>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C（二）</title>
    <url>/2022/03/18/C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<img src="/2022/03/18/C%EF%BC%88%E4%BA%8C%EF%BC%89/images.jpg" alt="images" style="zoom: 200%;">

<span id="more"></span>

<p>输入输出函数，运算符，一维数组，二维数组，三大结构（顺序，选择，循环）</p>
<h2 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h2><p>输入输出函数</p>
<p><img src="/2022/03/18/C%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220321100851507.png" alt="image-20220321100851507"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;格式化字符串&quot;，参数列表)</span><br></pre></td></tr></table></figure>

<p><strong>格式化字符串：</strong></p>
<p>实际上就是一个字符串，然后printf会把字符串原封不动的打印到屏幕上，除非遇到格式控制符</p>
<p><strong>参数列表：</strong></p>
<p>参数列表可以传递各种各样的数据，参数和字符串的格式控制符是一一匹配的。参数列表中的参数，可以有任意多个，可以是常量，也可以是变量，但是需要和格式字符串中的控制符匹配上。</p>
<p><strong>printf作用:</strong></p>
<p>把格式字符串原样输出，除非遇到格式控制符，遇到格式控制符的时候，会去参数列表中匹配，把匹配到的参数替换到相应的格式控制符的位置输出出来 </p>
<p>格式控制符：</p>
<p><img src="/2022/03/18/C%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220321101327088.png" alt="image-20220321101327088"></p>
<p>转义字符：</p>
<p><img src="/2022/03/18/C%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220321101351593.png" alt="image-20220321101351593"></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>单目运算符 &#x3D;<br>算术运算符 +，-，*，&#x2F;<br>关系运算符 &lt;,&gt;,&lt;&#x3D;,&gt;&gt;&#x3D;,&#x3D;&#x3D;<br>逻辑运算符 !,!&#x3D;,&amp;&amp;,||<br>位运算符 <del>,&amp;,|,&lt;&lt;,&gt;&gt;&gt;,</del><br>逗号运算符 ，<br>求大小运算符 sizeof<br>sizeof 它能得到某一个数据或者数据类型所占用的内存大小</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li><p>自动类型转换<br>（1）当一个算数表达式中为类型不同的变量时，会进行自动类型转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double </span><br></pre></td></tr></table></figure>

<p>（2）进行赋值运算的时候，会将右值类型自动转换为左值，有可能会丢失数据 </p>
</li>
<li><p>强制类型转换<br>通过使用转换可以将一个表达式强制转换成一种类型<br>括号的优先级最高，逗号的优先级最低</p>
</li>
</ul>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>数据类型： 数组名[数组长度]    int arrTem[11]</p>
<p><strong>说明</strong><br>1，数组名的命名规则和变量名相同，遵循标识符命名规则<br>2，数组名后接一个或多个方括号，用以指定数组的维数(元素个数)<br>3，数组长度只能时常量和常量表达式(大于0)，不能是变量 </p>
<p><strong>使用</strong></p>
<p>数组可以通过下标来访问某一个元素，下标可以使用常量，变量，其他有整数值的表达式。通过下标对每个数组元素的使用和普通变量一样。</p>
<p><strong>数组的初始化</strong></p>
<ol>
<li>整体赋值<br>int ary[5]&#x3D;{1,2,3,4,5}; </li>
<li>部分赋值<br>int ary[5]&#x3D;{1,2,3} &#x2F;&#x2F;还有最后两个元素为0 </li>
<li>不给定数组长度，根据实际数组元素个数分配<br>Int arr[]&#x3D;{1,2,3,4,5,6}; &#x2F;&#x2F;共有6个元素，所以实际分配24个字节空间</li>
</ol>
<p>使用数组的时候，假如不小心下标超过了最大界限会发生什么？这种情况，编译器是不会检查的，称之为数组的越界问题。这种情况会破坏程序的内存，照成程序间接性的不稳定。（就是程序运行可能会出错，有可能不会出错） </p>
<p><strong>字符数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char ary[]=&#123;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;；//正确用法 </span><br><span class="line">char ary2[]=&quot;hello&quot;; //字符数组的特殊用法，可以用一个字符串初始化数组 </span><br></pre></td></tr></table></figure>

<p>在C语言中，字符串是以‘\0’为结尾的，所使用字符串的地方，都是检查字符串结尾的’\0’来判断字符串是不是结束了<br>注意：字符串的结尾是一个’\0’，这个字符的ASC||码是0.而字符‘0’的ASC||码是0x30 </p>
<p><strong>字符数组的输入与输出</strong></p>
<p>数组名就是数组的起始地址，他是一个常量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span>  <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line">  scanf_s(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>,<span class="number">10</span>);会检测输入的数据是不是超过了第三个参数</span><br><span class="line">  <span class="comment">//scanf(&quot;%s&quot;,string);//越界是不会检查的</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,<span class="built_in">string</span>);  <span class="comment">//为什么scanf中的string不用取地址？因为数组名就是首地址， </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于一些字符串的操作函数</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>strlen</td>
<td>求字符串的长度</td>
</tr>
<tr>
<td>strcpy&#x2F;strcpy_s</td>
<td>字符串拷贝函数</td>
</tr>
<tr>
<td>strcmp</td>
<td>比较两个字符串是否一样</td>
</tr>
<tr>
<td>strcat&#x2F;strcat_s</td>
<td>将两个字符串拼接到一起</td>
</tr>
</tbody></table>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><strong>声明方式：</strong><br>类型说明符 数组名【常量表达式1】【常量表达式2】<code>int temp[3][4]</code></p>
<p>二维数组也可以看成是一个一维数组，它的每一个元素又是一个一维数组 </p>
<p><strong>初始化</strong></p>
<p>二维数组和一维数组一样，也可以在声明时对其进行初始化，二维数组的初始化方式比一维数组较为复杂，但都是一维数组初始化方法衍生而来的 </p>
<p>1, 分行给二维数组赋初值 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[2][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;//使用大括号分别把每行标记出来</span><br></pre></td></tr></table></figure>

<p>2，可以将所有数据写在一个花括号内，按数组排列的顺序对各元素赋初始值 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[2][3]=&#123;1,2,3,4,5,6&#125;; </span><br></pre></td></tr></table></figure>

<p>3，可以对部分元素赋初值 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[2][3]=&#123;&#123;1&#125;,&#123;2&#125;,&#123;3&#125;&#125;; //分行方式初始化 </span><br><span class="line">int arr[2][3]=&#123;1,2,3&#125; //整体方式初始化 </span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<p>分行方式：至少每行都有值，不足的补0<br>整体方式：将第一行赋值完后，再赋值后面的内容，有可能该部分值只给了第一行，后面的值都默认为0 </p>
<p>4，如果对全部元素都赋初值（即提供全部初始数据），则定义数组时对第一维的长度可以不指定，但第二维的长度不能省 </p>
<p><strong>引用</strong></p>
<p>数组名【下标】【下标】<br>1，下标可以是普通的数值<br>2，下标可以是整形表达式<br><code>arrTem[2-1][2*2-1]</code>;&#x2F;&#x2F;无论什么表达式，只要满足结果大于0 </p>
<p><strong>使用</strong></p>
<p>数组元素使用的时候和普通变量一样，可以出现在表达式中，也可以被赋值 </p>
<p><strong>说明：</strong> </p>
<ol>
<li>二维数组可被看作是一种特殊的一维数组，它的元素又是一个一维数组 </li>
<li>二维数组中元素排列的顺序是按行存放的，即在内存中先顺序存放完第一行的元素后，再存放第二行的元素</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">打印杨辉三角</span><br><span class="line">思路</span><br><span class="line">说明：杨辉三角的边都为<span class="number">1</span></span><br><span class="line">中间的每一个值是它对应的左上角和正上方值之和</span><br><span class="line"><span class="number">1</span>，定义一个<span class="number">10</span>*<span class="number">10</span>的二维数组，将斜面和每一行中第一个元素赋值为<span class="number">1</span>；</span><br><span class="line"><span class="number">2</span>，其他元素根据<span class="number">1</span>中定义的值做加法得到</span><br><span class="line">例：<span class="type">int</span>  arrTem[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        arrTem[<span class="number">2</span>][<span class="number">1</span>]=arrTem[<span class="number">1</span>][<span class="number">0</span>]+arrTem[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>  arrTem[<span class="number">10</span>][<span class="number">10</span>]=&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">   &#123;</span><br><span class="line">           <span class="keyword">if</span>((j==<span class="number">0</span>)||(j==i))</span><br><span class="line">         &#123;</span><br><span class="line">              arrTem[i][j]=<span class="number">1</span>;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,arrTem[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">                  <span class="comment">//每一个值是它对应的左上角的值和正上方值之和</span></span><br><span class="line">              arrTem[i][j]=arrTem[i<span class="number">-1</span>][j<span class="number">-1</span>]+arrTem[i<span class="number">-1</span>][j];</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,arrTem[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/18/C%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220321111001724.png" alt="image-20220321111001724"></p>
<h2 id="三大结构"><a href="#三大结构" class="headerlink" title="三大结构"></a>三大结构</h2><p>顺序结构：顺序结构就是从上到下，一条一条语句的执行 </p>
<p>选择结构：是当满足一定条件的时候，执行某一段语句，满足条件或者不满足条件用真假来描述 </p>
<p>循环结构相比于选择结构，也是满足一定的条件，就执行某一些语句，不同的是 ，它执行完之后， 还会再回来，判断条件满足不满足，又要执行一遍语句序列 </p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>表示</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>当且仅当两个运算量的值都为‘真’时，运算结果为‘真’，否则为‘假’</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>当且仅当两个运算量的值都为“假”时，运算结果为“假”，否则为“真”</td>
</tr>
<tr>
<td>！</td>
<td>非</td>
<td>当运算量的值为“真”时，运算结果为“假”，当运算量的值为“假”时，运算结果</td>
</tr>
</tbody></table>
<p>与位运算符的区别：</p>
<p>（1）逻辑运算符用if条件或者循环条件判断，得到的是1或者0两个逻辑结果<br>（2）位运算是属于两个操作数转换位二进制之后，针对于特定位的操作，得到的是一个数字</p>
<p>运算顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!a&amp;&amp;b||x&gt;y&amp;&amp;c</span><br></pre></td></tr></table></figure>

<p>按以下的优先次序:<br>（1）！（非）-&gt;&amp;&amp;（与）-&gt;||（或），即”！“为三者中最高的<br>（2）逻辑运算符中的”&amp;&amp;“和”||“低于关系运算符，”！“高于算术运算符</p>
<p>在逻辑表达式中，并不是两边的表达式都被执行，只是在必须执行下一个表达式时才能求出表达式的解</p>
<p>“&amp;&amp;”与”| |”均为短路运算符<br>“&amp;&amp;”当确认左边表达式为假，则不再判断右边的表达式<br>“||”当确认左边表达式为真，则不再判断右边的表达式</p>
<h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>基本形式 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if--else （else条件为假时执行）</span><br><span class="line">if--else if </span><br><span class="line">switch-case</span><br></pre></td></tr></table></figure>

<p><strong>switch - case语句的一般形式为：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>()&#123;</span><br><span class="line">        <span class="keyword">case</span> 常量<span class="number">1</span>：</span><br><span class="line">            语句序列；</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> 常量<span class="number">2</span>：</span><br><span class="line">            语句序列；</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">default</span>:</span><br><span class="line">        	语句序列；</span><br><span class="line">            <span class="keyword">break</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>switch说明</strong></p>
<ol>
<li><p>switch后面括号内的表达式 的值与某一个case后面的常量表达式的值相等时，就执行此case后面的语句，如所有的case中的 常量表达式的值都没有与表达式的值匹配的，就执行default后面的语句 </p>
</li>
<li><p>每一个case的常量表达式的值必须互不相同，否则就会出现相互矛盾的现象 </p>
</li>
<li><p>各个case和default的出现次序不影响执行结果 </p>
</li>
<li><p>执行完一个case后面的语句后，流程控制转义到下一个case继续执行 </p>
</li>
<li><p>break语句使得执行完case语句后跳出switch语句。如果没有break语句，程序将与下一个case语句匹配， 直到遇到Break为止 </p>
</li>
<li><p>多个case可以共用一组执行语句 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">        <span class="keyword">case</span> 常量<span class="number">1</span>：</span><br><span class="line">        <span class="keyword">case</span> 常量<span class="number">2</span>：</span><br><span class="line">            语句序列：</span><br><span class="line">            <span class="keyword">break</span>；</span><br><span class="line">        defasult:</span><br><span class="line">        	语句序列：</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>在使用case进行语句时，不要忘记case的条件只能是常量或者常量表达式‘</p>
</li>
</ol>
<p><strong>if–else语句的优缺点</strong><br>（1）使用if结构可以实现较为复杂的逻辑判断<br>（2）用switch结构能够实现的结构，使用if结构都可以实现<br>（3）分支较少的情况使用if结构更简单<br>（4）分支较多的情况下使用if结构会使 此程序结构变得复杂<br>（5）如果if嵌套层次过深，也容易使程序结构变得复杂<br><strong>switch语句的优缺点</strong><br>（1）没有复杂的逻辑判断，程序结构简单<br>（2）对于分支很多的情况，特别适合用switch结构<br>（3）switch结构只能基于一个整数值进行分支选择<br>（4）switch只能判断是否相等，不能判断在某一区间的值<br>（5）虽然使用switch语句编写的程序有规律，可读性强，但是由于switch语句不能根据表达式的取值范围做出选 择，所以使用时也有很大的局限性</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while语句的一般形式</span><br><span class="line">while(表达式)             //while循环头</span><br><span class="line"> &#123;</span><br><span class="line">   语句                   //while循环体</span><br><span class="line"> &#125;</span><br><span class="line">执行过程：</span><br><span class="line"> （1）判断表达式的真假，求出表达式</span><br><span class="line"> （2）如果表达式的值不为0（真），则执行语句，然后程序转至步骤(1)，再次求出表达式的值；如果表达式为0，while循环语句结束</span><br></pre></td></tr></table></figure>

<h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line"> //循环体语句</span><br><span class="line">&#125;while(表达式);</span><br><span class="line">注：在使用do--while语句时，条件要放在while关键字的括号内，其后必须加上分号</span><br></pre></td></tr></table></figure>

<p>先执行循环体，在判断循环控制条件，循环体至少也要执行一次</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for语句可以分为两部分，即for循环头和for循环体</p>
<p>for 循环头由关键字for和包含在一个括号内由分号隔开的3个表达式组成 ，循环体可以是一条语句，也可以是包含在大括号内的复合语句。<br>关于for的三个表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for循环的三个语句的执行顺序</span><br><span class="line">  for(printf(&quot;我是语句1\n&quot;);printf(&quot;我是语句2\n&quot;);printf(&quot;我是语句3\n&quot;));</span><br><span class="line">   &#123; </span><br><span class="line">             printf(&quot;我是循环体&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li><p>表达式的省略问题</p>
<p>for语句的一般形式中的“表达式1”可以省略，此时应在for语句之前给循环变量赋初值<br>如果表达式2省略，即不判断循环条件，循环无终止地进行下去<br>表达式3也可以省略，但此时程序设计者应另外设法保证循环能正常结束<br>可以省略表达式1和表达式3，只有表达式2，即只给循环条件</p>
</li>
<li><p>表达式的填写问题</p>
<p>表达式1可以是设置循环变量初值得赋值表达式，也可以是与循环变量无关的其他表达式<br>表达式2一般是关系表达式或逻辑表达式，但也可以是任意表达式，只要其值为非零，就执行循环体<br>表达式3一般是修改循环变量的语句，但也可以是任意表达式</p>
</li>
</ol>
<h4 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h4><p><strong>break</strong><br>         break语句在switch-case语句中是跳出，break语句在循环中还有另外一种用法<br>         当循环中遇到break语句时，立即结束循环，跳到循环体外，执行循环结构后面的语句<br><strong>continue</strong><br>         对于continue来说，作用是跳过本次循环<br>continue与break多与if连用</p>
<p><strong>打印九九乘法表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdafx.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%d&quot;</span>,j,i,j*i);</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>N5X刷Android_10</title>
    <url>/2022/03/14/N5X%E5%88%B7Android-10/</url>
    <content><![CDATA[<p>N5X刷入Android10</p>
<span id="more"></span>

<h2 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h2><p>1：offline</p>
<p><img src="/2022/03/14/N5X%E5%88%B7Android-10/image-20220313074826944.png" alt="image-20220313074826944"></p>
<p>拔掉数据线从新插入</p>
<p>2：failed to read copy response</p>
<p><img src="/2022/03/14/N5X%E5%88%B7Android-10/image-20220313074908930.png" alt="image-20220313074908930"></p>
<p>重启</p>
<p>3：</p>
<p><img src="/2022/03/14/N5X%E5%88%B7Android-10/image-20220313110910328.png" alt="image-20220313110910328"></p>
<p>fastboot版本问题</p>
<h2 id="刷机："><a href="#刷机：" class="headerlink" title="刷机："></a>刷机：</h2><p>1，刷入twrp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash recovery 下载的twrp版本</span><br></pre></td></tr></table></figure>

<p>2，twrp下刷入install 压缩包</p>
<h2 id="修改System权限"><a href="#修改System权限" class="headerlink" title="修改System权限"></a>修改System权限</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o rw,remount /system</span><br><span class="line">mount -o rw,remount /</span><br></pre></td></tr></table></figure>

<p>或者使用MT管理器移动</p>
<h2 id="证书相关："><a href="#证书相关：" class="headerlink" title="证书相关："></a>证书相关：</h2><p>移动到系统目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv /sdcard/xxxxxxx.0 /etc/security/cacerts/ 移动文件到系统</span><br><span class="line">chown root:root /etc/security/cacerts/fc365f9d.0 修改用户组</span><br><span class="line">chmod 644 /system/etc/security/cacerts/xxxxxxx.0 修改权限</span><br></pre></td></tr></table></figure>

<p>导出证书转换为pem：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform DER -in cacert.der -out cacert.pem</span><br></pre></td></tr></table></figure>

<p>查看pem证书的hash值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform PEM -subject_hash_old -in cacert.pem</span><br></pre></td></tr></table></figure>

<p>修改pem证书改名为”hash值.0“</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title>Python使用问题</title>
    <url>/2022/04/23/Python%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>python使用中的问题总结</p>
<span id="more"></span>

<h1 id="python第三方库安装"><a href="#python第三方库安装" class="headerlink" title="python第三方库安装"></a>python第三方库安装</h1><h2 id="PIP中安装"><a href="#PIP中安装" class="headerlink" title="PIP中安装"></a>PIP中安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install packagename</span><br></pre></td></tr></table></figure>

<h2 id="whl文件安装"><a href="#whl文件安装" class="headerlink" title="whl文件安装"></a>whl文件安装</h2><ol>
<li>下载<a href="http://www.lfd.uci.edu/-gohlke/pythonlibs">whl</a>文件到本地</li>
<li>输入命令<code>pip3 install wheel</code></li>
<li>执行命令<code>pip3 install whl文件完整路径</code></li>
</ol>
<p>这样就可以下载库到本地了，通过whl文件，可以自动安装依赖的包</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>抓包（二）</title>
    <url>/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>工作中发现，有些APP抓不到包，或者打开直接闪退，之前也有抓过包，一段时间没做后，有些方法用起来有些生疏，这里总结一下。</p>
<p>首先APP一般都会连网，没连网测着也没啥意思，说明功能也不杂多，既然会闪退就会有检测或者双向认证（后面说），抓不到包的情况要么检测代理要么vpn要么双向认证。。。。</p>
<span id="more"></span>

<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/02.png" alt="02" style="zoom:25%;">

<h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><h1 id="抓包工具："><a href="#抓包工具：" class="headerlink" title="抓包工具："></a>抓包工具：</h1><p>BurpSuite, Charles, Fildder, mitmproxy，R0cmptuter（需要frida）</p>
<h2 id="添加证书到系统目录"><a href="#添加证书到系统目录" class="headerlink" title="添加证书到系统目录"></a>添加证书到系统目录</h2><p>没装证书时的样子</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315214953630.png" alt="image-20220315214953630"></p>
<p>首先导出证书</p>
<p>打开chales找到help选择ssl proxying点击名字最长的那个</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315211235678.png" alt="image-20220315211235678"></p>
<p>在手机中配置上图所示IP，端口</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01.png" alt="01" style="zoom:25%;">

<p>可以看到“链接”是灰色的，这是因为手机跟电脑没在一个网段，下面就改回来了</p>
<p>连接好之后在浏览器中输入<code>chls.pro/ssl</code>，然后电脑端会显示是否允许远程链接，选择是，会下载证书。下载后安装就行，这时会把证书安装到用户目录。可以使用Magisk模块<code>move certificates</code>移动到系统目录。（步骤就是首先有模块，安装完用户证书后，手机关机重启就行）</p>
<h2 id="手动安装证书到系统目录"><a href="#手动安装证书到系统目录" class="headerlink" title="手动安装证书到系统目录"></a>手动安装证书到系统目录</h2><p>首先把证书导来，charles可以导出pem格式，其他工具虽然导不出pem格式，可以使用openssl转换</p>
<p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform DER -in burp.der -out burp.pem</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315215723332.png"></p>
<p>charles</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315215240068.png" alt="image-20220315215240068"></p>
<p>查看pem证书的hash值并记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -subject_hash_old -in charles.pem</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315220058741.png" alt="image-20220315220058741"></p>
<p>将证书名修改为：红色标记的值.0（因为系统证书目录里的证书是这样命名的<code>证书Hash.数字</code>，数字可以可以设置为别的，防止命名冲突）</p>
<p>下一步将证书移动到手机里使用如下命令或者其他方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push ec936cb1.0 /sdcard</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315221016089.png" alt="image-20220315221016089"></p>
<p>修改系统目录权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o rw,remount /system</span><br><span class="line">mount -o rw,remount /</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315221328562.png" alt="image-20220315221328562"></p>
<p>移动证书到系统目录</p>
<p>系统证书目录：<code>/system/etc/security/cacerts/</code>,修改权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv sdcard/ec936cb1.0 /system/etc/security/cacerts/ 移动</span><br><span class="line">chmod 644 /system/etc/security/cacerts/ec936cb1.0 修改权限</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315221819946.png" alt="image-20220315221819946"></p>
<p>PS: 如果觉得上面的操作比较复杂，推荐一款软件<code>MT管理器</code>直接移动证书到系统证书目录，记得还是要修改权限</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16473543764381.png" alt="01-16473543764381" style="zoom:25%;">

<p>重启手机验证。</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315224800107.png" alt="image-20220315224800107"></p>
<h1 id="Magisk模块"><a href="#Magisk模块" class="headerlink" title="Magisk模块"></a>Magisk模块</h1><p><code>move certificates</code>：移动用户目录证书到系统证书目录</p>
<h1 id="xposed模块"><a href="#xposed模块" class="headerlink" title="xposed模块"></a>xposed模块</h1><p><code>SSLUnpinning</code>：在SSL类中创建了几个钩子来绕过特定应用程序的证书验证</p>
<p>PS: 就是客户端并不会默认信任系统根证书目录中的证书，而是在代码里再加一层校验，这就是证书绑定机制——<code>SSL pinning</code>，如果这段代码的校验过不了，那么客户端还是会报证书错误</p>
<h1 id="VPN工具："><a href="#VPN工具：" class="headerlink" title="VPN工具："></a>VPN工具：</h1><h2 id="Postern"><a href="#Postern" class="headerlink" title="Postern:"></a>Postern:</h2><p>网络流量可以通过配置的代理服务器重定向。不需要为每个应用程序配置代理，不支持代理的应用程序也将遵循代理配置。需要做的就是将你的代理服务器放在Postern 中，并指定应该通过代理访问哪些主机&#x2F;目的地。Postern 支持所有流行的代理服务器</p>
<p>第一步: 打开配置代理，配置如下</p>
<p>名称：随便</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16473567161993.png" alt="01-16473567161993" style="zoom:25%;">

<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16473566520102.png" alt="01-16473566520102" style="zoom:25%;">

<p>第二部：配置规则如下</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16473568107464.png" alt="01-16473568107464" style="zoom:25%;">

<h2 id="Proxydroid"><a href="#Proxydroid" class="headerlink" title="Proxydroid:"></a><strong>Proxydroid:</strong></h2><p>在安卓设备上设置代理（http&#x2F;https &#x2F; socks4 &#x2F; socks5）的应用程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">** 功能 **</span><br><span class="line">1. 支持 HTTP / HTTPS / SOCKS4 / SOCKS5 代理</span><br><span class="line">2. 支持基本 / NTLM / NTLMv2 身份验证方法</span><br><span class="line">3. 仅一个或多个应用程序的单独代理</span><br><span class="line">4. 支持多个配置文件</span><br><span class="line">5. 绑定配置到 WIFI 的 SSID / 移动网络 (2G / 3G)</span><br><span class="line">6. 用于快速打开/关闭代理的小部件</span><br><span class="line">7. 低电池和内存消耗（用 C 编写并编译为本地二进制文件）</span><br><span class="line">8. 绕过自定义 IP 地址</span><br><span class="line">9. 防火墙后面的人的 DNS 代理，不允许解析外部地址</span><br><span class="line">10. PAC 文件支持（仅基本支持）</span><br></pre></td></tr></table></figure>

<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-1647395429928.png" alt="01-1647395429928" style="zoom:25%;">

<p>Proxy Type可以选中代理类型</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/02-1647395438752.png" alt="02-1647395438752" style="zoom:25%;">



<h2 id="Httpcannary："><a href="#Httpcannary：" class="headerlink" title="Httpcannary："></a>Httpcannary：</h2><p>一款功能强大的 HTTP&#x2F;HTTPS&#x2F;HTTP2&#x2F;WebSocket&#x2F;TCP&#x2F;UDP 数据包捕获和分析应用程序，专为 Android 平台设计。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 内容概览</span><br><span class="line">HttpCanary 显示多维会话概览。包括 URL、http 协议、http 方法、响应码、服务器主机、服务器 ip 和端口、内容类型、keep-alive、时序、数据大小等。</span><br><span class="line"></span><br><span class="line">* 数据包过滤和搜索</span><br><span class="line">HttpCanary多维过滤器，可以按app、host、protocol、method、ip、port、关键字过滤数据包。此外，您可以在数据包的内容中搜索关键字。</span><br><span class="line"></span><br><span class="line">* 阻止设置</span><br><span class="line">您可以选择阻止请求和响应，很容易调试您的 REST API。</span><br><span class="line"></span><br><span class="line">* 插件</span><br><span class="line">HttpCanary 支持许多插件，包括实验插件和扩展插件。现在，应用程序中集成了一些实验性插件，例如 HostBlock、Mime-TypeBlock、Downloader 和 OverviewStatistics。未来，我们将为开发者发布扩展插件-sdk，并支持扩展插件。</span><br></pre></td></tr></table></figure>

<p>傻瓜式安装，按照提示安装就行</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/02-1647574743715.png" alt="02" style="zoom:25%;">

<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-1647574758775.png" alt="01" style="zoom:25%;">

<h2 id="Drony："><a href="#Drony：" class="headerlink" title="Drony："></a>Drony：</h2><p>绕过SSLPinning检测</p>
<p>繁体版：</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-1647397020211.png" alt="01-1647397020211" style="zoom:25%;">



<p>英文版：</p>
<p>使用步骤：</p>
<p>1、打开Drony看到LOG页，右滑到SETTING页，选择Networks 下：Wi-Fi，点击当前在用的wifi名，进入Network details设置页</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220316105249660.png" alt="image-20220316105249660" style="zoom: 50%;">

<p>2、点击Hostname，输入当前电脑的局域网IP和端口( Proxy type页面会变成 Manual 手动模式)</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/02-1647399191677.png" alt="02-1647399191677" style="zoom:25%;">

<p>3、点击Filter default value，选择Direct all<br>（这步如果没加，log页面会看到很多信息）</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/03.png" alt="03" style="zoom:25%;">



<p>4、点击Rules，进入Rules详情页，点击右上角的加号，进入Add filter rule，action选择Local proxy chain，Application选择需要抓包的应用，然后保存，返回主页</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220316105602353.png" alt="image-20220316105602353" style="zoom: 50%;">

<p>5、左滑到LOG标签页，点击底部到OFF按钮，启用Drony</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/06.png" alt="06" style="zoom:25%;">



<h1 id="双向认证："><a href="#双向认证：" class="headerlink" title="双向认证："></a>双向认证：</h1><p>双向认证，顾名思义，客户端和服务器端都需要验证对方的身份，在建立HTTPS连接的过程中，握手的流程比单向认证多了几步。单向认证的过程，客户端从服务器端下载服务器端公钥证书进行验证，然后建立安全通信通道。双向通信流程，客户端除了需要从服务器端下载服务器的公钥证书进行验证外，还需要把客户端的公钥证书上传到服务器端给服务器端进行验证，等双方都认证通过了，才开始建立安全通信通道进行数据传输。</p>
<p>单一通信已经分裂成两个互相独立的通信，这时候与服务器进行通信的已经不是<code>app</code>、而是<code>中间工具</code>了，所以我们要将<code>app</code>中内置的证书导入到<code>中间工具</code>中去。</p>
<p>双向认证解决办法就是找证书密码</p>
<p>手工找：</p>
<p>找证书文件，</p>
<p>找证书密码</p>
<p>步骤：</p>
<p>解压apk文件，找<code>后缀.p12</code>文件，有的apk会隐藏，得慢慢找，密码在源代码里搜索</p>
<p>演示：略</p>
<p>fridaHook：</p>
<h2 id="HOOK代码："><a href="#HOOK代码：" class="headerlink" title="HOOK代码："></a>HOOK代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Enter!&quot;</span>)</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">storeP12</span>(<span class="params">pri, p7, p12Path, p12Password</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;X509!&quot;</span>)</span><br><span class="line">            <span class="keyword">var</span> X509Certificate = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.cert.X509Certificate&quot;</span>)</span><br><span class="line">            <span class="keyword">var</span> p7X509 = <span class="title class_">Java</span>.<span class="title function_">cast</span>(p7, X509Certificate);</span><br><span class="line">            <span class="keyword">var</span> chain = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&quot;java.security.cert.X509Certificate&quot;</span>, [p7X509])</span><br><span class="line">            <span class="keyword">var</span> ks = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.KeyStore&quot;</span>).<span class="title function_">getInstance</span>(<span class="string">&quot;PKCS12&quot;</span>, <span class="string">&quot;BC&quot;</span>);</span><br><span class="line">            ks.<span class="title function_">load</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            ks.<span class="title function_">setKeyEntry</span>(<span class="string">&quot;client&quot;</span>, pri, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).$new(p12Password).<span class="title function_">toCharArray</span>(), chain);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">var</span> out = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.FileOutputStream&quot;</span>).$new(p12Path);</span><br><span class="line">              ks.<span class="title function_">store</span>(out, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).$new(p12Password).<span class="title function_">toCharArray</span>())</span><br><span class="line">            &#125; <span class="keyword">catch</span> (exp) &#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(exp)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//在服务器校验客户端的情形下，帮助dump客户端证书，并保存为p12的格式，证书密码为a1ili</span></span><br><span class="line">          <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.KeyStore$PrivateKeyEntry&quot;</span>).<span class="property">getPrivateKey</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">getPrivateKey</span>()</span><br><span class="line">            <span class="keyword">var</span> packageName = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.app.ActivityThread&quot;</span>).<span class="title function_">currentApplication</span>().<span class="title function_">getApplicationContext</span>().<span class="title function_">getPackageName</span>();</span><br><span class="line">            <span class="title function_">storeP12</span>(<span class="variable language_">this</span>.<span class="title function_">getPrivateKey</span>(), <span class="variable language_">this</span>.<span class="title function_">getCertificate</span>(), <span class="string">&#x27;/sdcard/Download/&#x27;</span> + packageName + <span class="string">&#x27;.p12&#x27;</span>, <span class="string">&#x27;a1ili&#x27;</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dumpClinetCertificate=&gt;&quot;</span> + <span class="string">&#x27;/sdcard/Download/&#x27;</span> + packageName + <span class="string">&#x27;.p12&#x27;</span> + <span class="string">&#x27;   pwd: a1ili&#x27;</span>);            </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.KeyStore$PrivateKeyEntry&quot;</span>).<span class="property">getCertificateChain</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">getCertificateChain</span>()</span><br><span class="line">            <span class="keyword">var</span> packageName = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.app.ActivityThread&quot;</span>).<span class="title function_">currentApplication</span>().<span class="title function_">getApplicationContext</span>().<span class="title function_">getPackageName</span>();</span><br><span class="line">            <span class="title function_">storeP12</span>(<span class="variable language_">this</span>.<span class="title function_">getPrivateKey</span>(), <span class="variable language_">this</span>.<span class="title function_">getCertificate</span>(), <span class="string">&#x27;/sdcard/Download/&#x27;</span> + packageName + <span class="string">&#x27;.p12&#x27;</span>, <span class="string">&#x27;a1ili&#x27;</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dumpClinetCertificate=&gt;&quot;</span> + <span class="string">&#x27;/sdcard/Download/&#x27;</span> + packageName + <span class="string">&#x27;.p12&#x27;</span> + <span class="string">&#x27;   pwd: a1ili&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure>

<p>Android10源代码中获取privateKey函数</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220319164234742.png" alt="image-20220319164234742"></p>
<p>通过hook这个函数，得到密码</p>
<p><strong>把dump下来的证书，拿到keyStore转换</strong></p>
<p>输入密码脚本上的密码查看</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220319164641522.png" alt="image-20220319164641522"></p>
<p>导出你需要的格式的证书</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220319165521114.png" alt="image-20220319165521114"></p>
<p>然后在你使用的工具上导入证书</p>
<p>在<code>Charles</code>中是位于<code>Proxy</code>→<code>SSL Proxy Settings</code>→<code>Client Certificates</code>→<code>Add</code>添加新的证书</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220319165808731.png" alt="image-20220319165808731"></p>
<h1 id="NetHunter"><a href="#NetHunter" class="headerlink" title="NetHunter:"></a>NetHunter:</h1><p>首先手机刷入nethunter</p>
<p>刷入后手机界面如下所示：</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16474425217752.png" alt="01-16474425217752" style="zoom:25%;">

<p>使用：</p>
<p>1，首先打开<code>netHunter</code>点击<code>kali Chroot Manager</code> 然后点击<code>start kali chroot</code>进行初始化，初始化后如下</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16474427115523.png" alt="01-16474427115523" style="zoom:25%;">

<p>2，点击<code>kex Manager</code>打开如下界面</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16474428709006.png" alt="01-16474428709006" style="zoom:25%;">

<p>3，把<code>Localhost only</code>的钩去掉，先点击 setup local server点击<code>start server</code>设置密码，设置好后点击<code>Kex Server Status</code>旁边得到刷新按钮由<code>stop</code>变为<code>RUNING</code></p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16474430660657.png" alt="01-16474430660657" style="zoom:25%;">

<p>4，打开<code>NetHunter Kex</code> 输入密码，点击<code>Connect</code>进行链接，手机就会出现kali界面</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16474432561229.png" alt="01-16474432561229" style="zoom:25%;">

<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16474431774788.png" alt="01-16474431774788" style="zoom:25%;">

<p>此时就和电脑上的kali一样</p>
<p>4，手机上操作毕竟不方便，键盘太小，使用<code>VNC Viewer</code>在电脑端操作，IP:端口，端口默认是5901，然后你输入你设置的密码</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220316231051095.png" alt="image-20220316231051095"></p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220316232238328.png" alt="image-20220316232238328"></p>
<p>至此，手机就是移动版的<code>kali</code> ，渗透测试人员推荐使用<code>andrax</code></p>
<p>wlan0就是你手机的IP</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220316234558516.png" alt="image-20220316234558516"></p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220316234502250.png" alt="image-20220316234502250"></p>
<h1 id="网卡抓包："><a href="#网卡抓包：" class="headerlink" title="网卡抓包："></a>网卡抓包：</h1><p>需要使用网卡，wifi共享大师等第三方软件（电脑端），发射出来wifi，手机连这个wifi，然后抓这个wifi的包，由于我的网卡只支持windows系统就不演示了，没在kali上演示好看</p>
<h1 id="证书："><a href="#证书：" class="headerlink" title="证书："></a>证书：</h1><h2 id="证书标准："><a href="#证书标准：" class="headerlink" title="证书标准："></a>证书标准：</h2><ol>
<li><p>X.509</p>
<p>这是一种证书标准，主要定义了证书中应该包含哪些内容。其详情可以参考 <code>RFC5280</code>，SSL 使用的就是这种证书标准。</p>
<p>同样的 <a href="https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/X.509">X.509</a> 证书，可能有不同的编码格式。最常见的就是 PEM 和 DER 两种格式。但是有个比较误导人的地方，这两种格式的文件，扩展名不一定就是 <code>.pem</code> 或 <code>.der</code>，还有其他一些常见格式。它们除了编码格式可能不同之外，内容也有差别。但是大多数都能相互转换编码格式。</p>
</li>
<li><p>作为文件形式存在的证书一般有这几种格式：</p>
<ul>
<li>带有私钥的证书（P12）<br>由 Public Key Cryptography Standards #12，PKCS#12 标准定义，包含了公钥和私钥的二进制格式的证书形式，以 pfx 作为证书文件后缀名。</li>
<li>二进制编码的证书（DER）<br>证书中没有私钥，DER 编码二进制格式的证书文件，以 <code>.cer</code> 作为证书文件后缀名。</li>
<li>Base64 编码的证书（PEM）<br>证书中没有私钥，Base64 编码格式的证书文件，也是以 <code>.cer</code> 作为证书文件后缀名。</li>
</ul>
</li>
</ol>
<h2 id="证书特点："><a href="#证书特点：" class="headerlink" title="证书特点："></a>证书特点：</h2><ol>
<li><p>PEM </p>
<ul>
<li>Base64 编码的 ASCII 文件</li>
<li>具备诸如 <code>.pem, .crt, .cer, .key</code> 这样的扩展名</li>
<li>Apache 和类似的服务器使用 PEM 格式的证书</li>
</ul>
<p>查看 PEM 格式证书的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in certificate.pem -text -noout</span><br></pre></td></tr></table></figure>
</li>
<li><p>DER</p>
<ul>
<li>二进制文件</li>
<li>扩展名为 <code>.cer</code> 和 <code>.der</code></li>
<li>DER 被典型地于 Java 平台</li>
</ul>
<p>查看 DER 格式证书的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in certificate.der -inform der -text -noout</span><br></pre></td></tr></table></figure>


</li>
<li><p>P7B&#x2F;PKCS#7</p>
<ul>
<li>Base64 编码的 ASCII 文件</li>
<li>扩展名为 <code>.p7b, .p7c</code></li>
<li>多平台支持。如：Windows OS、Java Tomcat</li>
</ul>
</li>
<li><p>PFX&#x2F;PKCS#12</p>
<ul>
<li>二进制文件</li>
<li>扩展名为 <code>.pfx, .p12</code></li>
<li>典型用于 Windows OS 导入导出证书和私钥</li>
</ul>
</li>
</ol>
<h2 id="证书间的转换："><a href="#证书间的转换：" class="headerlink" title="证书间的转换："></a>证书间的转换：</h2><p>PEM 转为 DER</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -outform der -in certificate.pem -out certificate.der</span><br></pre></td></tr></table></figure>

<p>PEM 转为 P7B</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl crl2pkcs7 -nocrl -certfile certificate.cer -out certificate.p7b -certfile CAcert.cer</span><br></pre></td></tr></table></figure>

<p>DER 转为 PEM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform der -in certificate.cer -out certificate.pem</span><br></pre></td></tr></table></figure>

<p><code>PKCS#12</code> 与 <code>PEM</code> 的相互转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从 cert.p12 中提取 私钥，不包含证书，私钥不加密，输出为 PEM 格式</span><br><span class="line">$ openssl pkcs12 -nocerts -nodes -in cert.p12 -out privatekey.pem</span><br><span class="line"></span><br><span class="line"># 从 cert.p12 中，只输出 client 证书，不输出私钥，输出为 PEM 格式</span><br><span class="line">$ openssl pkcs12 -clcerts -nokeys -in cert.p12 -out cert.pem</span><br><span class="line"></span><br><span class="line"># 将密钥与证书合成为 cert.p12</span><br><span class="line">$ openssl pkcs12 -export -in cert.pem -out cert.p12 -inkey key.pem</span><br></pre></td></tr></table></figure>

<p>从 <code>PFX</code> 格式文件中提取<code>私钥</code>格式文件（<code>.key</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -in mycert.pfx -nocerts -nodes -out mycert.key</span><br></pre></td></tr></table></figure>

<p>BKS</p>
<p>Android中，需要 BKS 格式证书。一般做法是将 P12 转为 BKS：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先使用 openssl 把 crt 和 key 转换为 p12 证书</span><br><span class="line">$ openssl pkcs12 -export -in client.crt -inkey client.key -out client.p12</span><br><span class="line"></span><br><span class="line"># 使用 keytool 把 p12 转换为 bks 证书</span><br><span class="line">$ keytool -importkeystore -srckeystore client.p12 -srcstoretype pkcs12 -destkeystore client.bks -deststoretype bks -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath bcprov-ext-jdk15on-158.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>抓包实战</tag>
      </tags>
  </entry>
  <entry>
    <title>文件结构</title>
    <url>/2022/04/23/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>APK结构</p>
<span id="more"></span>

<h1 id="APK打包流程"><a href="#APK打包流程" class="headerlink" title="APK打包流程"></a>APK打包流程</h1><p><img src="/2022/04/23/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-20220410124155850.png" alt="image-20220410124155850"></p>
<p><strong>1，打包资源文件，生成R.java文件</strong></p>
<p>打包工具是aapt，在这个过程中，项目中的AndroidManifest.xml文件和布局文件xml都会编译，然后生成相应的R.java，另外AndroidManifest.xml会被aapt编译成二进制</p>
<p><strong>2，处理aidl文件，生成相应的JAVA文件</strong></p>
<p>这一过程中使用的工具是aidl，即Android接口描述语言。</p>
<p>aidl工具解析接口定义文件然后生成相应的java代码接口供程序调用。如果在项目没有使用aidl文件，则可以跳过这一步。</p>
<p><strong>3，编译项目源代码，生成class文件</strong></p>
<p>使用javac工具把项目中所有的Java代码编译为class文件</p>
<p><strong>4，转换所有的class文件，生成classes.dex文件</strong></p>
<p>dx工具生成可供Android系统Dalvik虚拟机执行的classes.dex文件，任何第三方的libraries和.class文件都会被转换成.dex文件。dx工具的主要工作是将java字节码转成Dalvik字节码，压缩常量池，消除冗余信息等。</p>
<p><strong>5，打包生成apk文件</strong></p>
<p>所有没有被编译过的资源，如images，assets目录下资源（该类文件是一些原始文件，APP打包时并不会对其进行编译，而是直接打包到APP中，对于这一类资源文件的访问，应用层代码需要通过文件名对其进行访问）；编译过的资源和.dex文件都会被apkbuilder工具打包到最终的.apk文件中</p>
<p><strong>6，对apk文件进行签名</strong></p>
<p>在开发过程中，主要用到的就是两种签名的keystore。一种是用于调试的debug.keystore，它主要用于调试，在Android studio中直接run以后跑在手机上的就是使用的debug.keystore。</p>
<p>另一种就是用于发布正式版本的keystore。</p>
<p><strong>7，对签名后的apk文件进行对齐处理</strong></p>
<p>工具是zipalign，对齐的主要过程是将APK包中所有的资源文件距离文件起始偏移为4字节整数倍，这样通过内存映射访问apk文件时的速度会更快。对齐的作用就是减少运行时内存的使用</p>
<p><strong>七个步骤七个工具</strong></p>
<h1 id="APK文件结构"><a href="#APK文件结构" class="headerlink" title="APK文件结构"></a>APK文件结构</h1><p><img src="/2022/04/23/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/20200919181701974.png" alt="20200919181701974"></p>
<p><strong>assets 目录</strong>：assets 文件用来存放需要打包到 Android 应用程序的静态资源文件， 例如图片资源文件、JSON 配置文件、渠道配置文件、二进制数据文件、HTML5 离线资源 文件等。与 res&#x2F;raw 目录不同的是，assets 目录支持任意深度的子目录，同时该目录下 面的文件不会生成资源 ID。</p>
<p><strong>lib 目录</strong>：这里存放应用程序依赖的 native 库文件，一般是用 C&#x2F;C++编写，这里的 lib 库可能包含 4 中不同类型，根据 CPU 型号的不同，大体可以分为 ARM，ARMv7a，MIPS，X86，分别对应着 ARM 架构，ARM-V7 架构，MIPS 架构和 X86 架构。</p>
<p><strong>META-INF 目录</strong>：存放着应用程序的的签名信息，该信息可以验证 APK 的完整性。 META-INF 目录中包含的文件有 CERT.RSA(公钥、加密算法等信息)，CERT.SF(对摘要文 件的签名文件)和 MANIFEST.MF(摘要文件)。</p>
<p><strong>res 目录</strong>：存放应用的资源文件，如图片资源，xml 配置资源。存放这个文件夹下的 所有文件都会和上文所说的，映射到 Android 工程中的.R 文件中，生成对应的资源 ID， 访问的时候直接使用资源 ID，即 R.ID.FILENAME，res 文件夹下可以包含多个文件夹； anim 是存放动画文件的；drawable 目录存放图形资源；layout 目录存放布局文件； values 目录存放一些特征值；colors.xml 存放 color 的颜色值等</p>
<p><strong>AndroidManifest.xml 文件</strong>：Android 应用程序的配置文件，Android 应用的四 大组件 （Activity、Service、BroadcastReceiver 和 ContentProvider ）都在此配置和声明。</p>
<p><strong>classes.dex 文件</strong>：应用程序的可执行文件，Android 的所有 java 代码都在这，通 过反编译工具可以查看其代码。当文件中的方法数超过 65535 就会进行分包处理，若未 超过则只有一个 dex</p>
<p><strong>resources.arsc 文件</strong>:资源索引表，用来记录资源文件和资源 ID 之间的映射关系， 用来根据资源 ID 寻找资源</p>
<h1 id="APK-安装流程"><a href="#APK-安装流程" class="headerlink" title="APK 安装流程"></a>APK 安装流程</h1><ol>
<li><p>复制 apk 到 data&#x2F;app 、</p>
</li>
<li><p>解压扫描安装包 </p>
</li>
<li><p>把 apk 的 dex 文件复制到 data&#x2F;dalvik-cache 加快运行速度，缓存起来</p>
</li>
</ol>
<p>4）在 data&#x2F;data 目录中以包名生成文件夹，该文件夹作为应用程序的数据存 放目录，在安装 apk 的过程中，会解析 apk 的 AndroidManifest.xml 文件， 将 apk 的权限、应用包名、apk 的安装位置、版本、userID 等重要信息保存 在&#x2F;data&#x2F;system&#x2F;packages.xml 文件中。这些操作都是在 PackageManagerService 中完成的。</p>
<p>5）显示 icon 图标</p>
<p>APK 安装的预备知识点 </p>
<p>（1）PackageManagerService 是由 SystemServer 启动，PMS 负责应用 的安装、卸载、权限检查等工作 </p>
<p>（2）在&#x2F;system&#x2F;app 和&#x2F;data&#x2F;app 目录下的 apk 文件，PMS 在启动过程中， 都会扫描安装 （3）每次开机时，PMS 都会在构造函数中对指定目录下的 apk 进行扫描，没 有安装的 apk 就会触发安装。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫基础-从零开始</title>
    <url>/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul>
<li>模拟计算机对服务器发起的Request请求</li>
<li>接受服务器端的Response内容并解析，提取所需的信息</li>
</ul>
<span id="more"></span>

<h1 id="常用Python语法"><a href="#常用Python语法" class="headerlink" title="常用Python语法"></a>常用Python语法</h1><h2 id="字符串的切片和索引"><a href="#字符串的切片和索引" class="headerlink" title="字符串的切片和索引"></a>字符串的切片和索引</h2><p>字符串的切片和索引就是通过<code>string[x]</code>，获取字符串的一部分信息</p>
<h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><p><strong>split()方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a.split(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line"><span class="comment">#result[&#x27;www&#x27;,&#x27;baidu&#x27;,&#x27;com&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>split()方法就是通过给定的分割符，将一个字符串分割为一个列表。<br><strong>repalce()方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;There is apples&#x27;</span></span><br><span class="line">b = a.replace(<span class="string">&#x27;is&#x27;</span>,<span class="string">&#x27;are&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">#result There are apples</span></span><br></pre></td></tr></table></figure>

<p>类似文本中的”查找替换”功能<br><strong>strip()方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27; python is cool &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a.strip())</span><br><span class="line"><span class="comment">#result python is cool</span></span><br></pre></td></tr></table></figure>

<p>strip()方法返回去除两侧空格的字符串，也可以指定需要去除的字符，将他们列为参数中即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;***python**is**good***&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a.strip(<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="comment">#result python**is**good</span></span><br></pre></td></tr></table></figure>

<p><strong>format()方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;&#123;&#125; is my love&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#result Python is my love</span></span><br></pre></td></tr></table></figure>

<p>字符串格式化符就像是做选择题，留了空给做题者选择。在爬虫过程中，有些网页链接的部分参数是可变的，这时使用字符串格式化符可以减少代码的使用量。<br>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conten = <span class="built_in">input</span>(<span class="string">&#x27;请输入搜索内容&#x27;</span>)</span><br><span class="line">url_path = <span class="string">&#x27;https://www.pexels/com/search/&#123;&#125;/&#x27;</span>.<span class="built_in">format</span>(content)</span><br><span class="line"><span class="built_in">print</span>(url_path)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/8afbde6f337b785ddbe1e3c89cb1605aa0b0b0f53098ecf6cb99fc8fbc494567.png" alt="图 1">  </p>
<h2 id="Python数据结构"><a href="#Python数据结构" class="headerlink" title="Python数据结构"></a>Python数据结构</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>特征：</p>
<ul>
<li>列表中的每一个元素都是可变的</li>
<li>列表的元素都是有序的，也就是说每个元素都有对应的位置（类似字符串的切片和索引）</li>
<li>列表可以容纳所有的对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;peter&#x27;</span>,<span class="string">&#x27;lilei&#x27;</span>,<span class="string">&#x27;wangwu&#x27;</span>,<span class="string">&#x27;xiangming&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">2</span>:])</span><br><span class="line"><span class="comment">#resutl</span></span><br><span class="line">wangwu</span><br><span class="line">[<span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;xiangming&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>如果是切片，返回的也是列表的数据结构<br>列表会经常用到多重循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;xiaoming&#x27;</span>,<span class="string">&#x27;wanggu&#x27;</span>,<span class="string">&#x27;peter&#x27;</span>]</span><br><span class="line">ages = [<span class="number">23</span>,<span class="number">15</span>,<span class="number">58</span>]</span><br><span class="line"><span class="keyword">for</span> name,age <span class="keyword">in</span> <span class="built_in">zip</span>(name.ages)</span><br><span class="line">    <span class="built_in">print</span>(name,age)</span><br><span class="line"><span class="comment">#result</span></span><br><span class="line">xiaoming <span class="number">23</span></span><br><span class="line">wanggu <span class="number">15</span></span><br><span class="line">peter <span class="number">58</span></span><br></pre></td></tr></table></figure>

<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Python的字典数据结构与现实中的字典类似，以键值对（‘key’-‘value’）的形式出现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_info=&#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;23&#x27;</span></span><br><span class="line">    <span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;man&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元组和集合"><a href="#元组和集合" class="headerlink" title="元组和集合"></a>元组和集合</h3><p>元组类似于列表，但是元组的元素不能修改只能查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tuple = (1,2,3)</span><br></pre></td></tr></table></figure>

<p>集合的概念类似数学中的集合。每个集合中的元素是无序的，不可以有重复的对象。因此可通过集合把重复的数据去除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;xiaoming&#x27;</span>,<span class="string">&#x27;zhangyu&#x27;</span>,<span class="string">&#x27;xiaoming&#x27;</span>]</span><br><span class="line"><span class="built_in">set</span> = <span class="built_in">set</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>)</span><br><span class="line"><span class="comment">#result &#123;&#x27;zhangyu&#x27;, &#x27;xiaoming&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>Python中通过open()函数打开文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(name[,mode[,buffering]])</span><br></pre></td></tr></table></figure>

<p>open()函数使用文件名作为唯一的强制参赛，然后返回一个文件对象。模式（mode）和缓冲（buffering）是可选参数。</p>
<p>如果在本机上有名为file.txt的文件，其存储路径为<code>C:\User\Administrator\Desktop</code>，那么可以通过下面代码打开文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;C:\User\Administrator\Desktop\file.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果open()函数只是加入文件的路径这一个参数，则只能打开文件并读取文件的相关内容。如果要向文件中写入内容，则必须加入模式这个参赛了。<br>模式参赛的常用值</p>
<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/cd5e7b38fe329e81b4cdfe20540f2653826e80ee7dcb7566667e896aeffbf701.png" alt="图 2">  </p>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>python读取文件通过read()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span> (<span class="string">&#x27;/home/a1ili/Desktop/1.txt&#x27;</span>)</span><br><span class="line">content = f.read()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br><span class="line"><span class="comment">#result</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/aabc0daff737955f57121884ceb93631578010ab39f9121b790f75c9e575d989.png" alt="图 3">  </p>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>当完成读写工作后，应该使用close()方法关闭文件。这样可以保证python进行缓冲的清理和文件的安全性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span> (<span class="string">&#x27;/home/a1ili/Desktop/1.txt&#x27;</span>)</span><br><span class="line">content = f.read()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Python面向对象"><a href="#Python面向对象" class="headerlink" title="Python面向对象"></a>Python面向对象</h2><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bike</span>:</span><br><span class="line">    compose = [<span class="string">&#x27;frame&#x27;</span>,<span class="string">&#x27;wheel&#x27;</span>,<span class="string">&#x27;pedal&#x27;</span>]</span><br><span class="line"></span><br><span class="line">my_bike = Bike()</span><br><span class="line">you_bike = Bike()</span><br><span class="line"><span class="built_in">print</span>(you_bike.compose)</span><br></pre></td></tr></table></figure>

<p>my_bike就是类的实例，通过<code>.</code>加上类的属性，就是类属性的引用。类的属性会被类的实例共享</p>
<h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bike</span>:</span><br><span class="line">    compose = [<span class="string">&#x27;frame&#x27;</span>,<span class="string">&#x27;wheel&#x27;</span>,<span class="string">&#x27;pedal&#x27;</span>]</span><br><span class="line"></span><br><span class="line">my_bike = Bike()</span><br><span class="line">my_bike.anoter = <span class="string">&#x27;basket&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(my_bike.anoter)</span><br><span class="line"><span class="comment">#result basket</span></span><br></pre></td></tr></table></figure>

<p>通过给类的实例属性进行赋值，也就是实例属性。compose属性属于所有的该款自行车，而other属性只属于my_bike这个类的实例。</p>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bike</span>:</span><br><span class="line">    compose = [<span class="string">&#x27;frame&#x27;</span>,<span class="string">&#x27;wheel&#x27;</span>,<span class="string">&#x27;pedal&#x27;</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">use</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;you are riding&#x27;</span>)</span><br><span class="line"></span><br><span class="line">my_bike=Bike()</span><br><span class="line">my_bike.use()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/4179604d4357269cd0803c45a3114da6bcc6bcd5a65fd933c6af17279aefe1c5.png" alt="图 4">  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bike</span>:</span><br><span class="line">    compose = [<span class="string">&#x27;frame&#x27;</span>,<span class="string">&#x27;wheel&#x27;</span>,<span class="string">&#x27;pedal&#x27;</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">use</span>(<span class="params">self,time</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;you are ride &#123;&#125;m&#x27;</span>.<span class="built_in">format</span>(time*<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">my_bike=Bike()</span><br><span class="line">my_bike.use(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/e02eb1df0bb076c304c84e8343b3d4b5a257f41de908c4c79bd8536604fbc355.png" alt="图 5">  </p>
<p>python的类中有一些“魔法方法”，<code>__init__()</code>方法就是其中之一。在我们创造实例的时候，不需要引用该方法也会被自动执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bike</span>:</span><br><span class="line">    compose = [<span class="string">&#x27;frame&#x27;</span>,<span class="string">&#x27;wheel&#x27;</span>,<span class="string">&#x27;pedal&#x27;</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">use</span>(<span class="params">self,time</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;you are ride &#123;&#125;m&#x27;</span>.<span class="built_in">format</span>(time*<span class="number">100</span>))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.other = <span class="string">&#x27;basket&#x27;</span></span><br><span class="line"></span><br><span class="line">my_bike=Bike()</span><br><span class="line"><span class="built_in">print</span>(my_bike.other)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/e54945d1278c258fd0de4af76832a3e493943485a5c4aeeb6d67f6fa67a55d75.png" alt="图 7">  </p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bike</span>:</span><br><span class="line">    compose = [<span class="string">&#x27;frame&#x27;</span>,<span class="string">&#x27;wheel&#x27;</span>,<span class="string">&#x27;pedal&#x27;</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">use</span>(<span class="params">self,time</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;you are ride &#123;&#125;m&#x27;</span>.<span class="built_in">format</span>(time*<span class="number">100</span>))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.other = <span class="string">&#x27;basket&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Share_bike</span>(<span class="title class_ inherited__">Bike</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cost</span>(<span class="params">self,hour</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;you spent &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(hour))</span><br><span class="line"></span><br><span class="line">my_bike=Share_bike()</span><br><span class="line"><span class="built_in">print</span>(my_bike.other)</span><br><span class="line">my_bike.cost(<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/6e37d345e26c874d67c98383ea661cda972ed0151e9439bc7a52f23ff2fcbebf.png" alt="图 8">  </p>
<h1 id="多页面爬虫流程"><a href="#多页面爬虫流程" class="headerlink" title="多页面爬虫流程"></a>多页面爬虫流程</h1><p>有的网页存在多页的情况，每页的网页结构都相同或类似，这种流程为</p>
<ol>
<li>手动翻页并观察各网页的URL构成特点，构造出所有的URL存入列表中。</li>
<li>根据URL列表依次循环取出URL</li>
<li>定义爬虫函数</li>
<li>循环调用爬虫函数，存储数据</li>
<li>循环完毕，结束爬虫程序</li>
</ol>
<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/e2d15bbe0adef3531865a6d4fae414c018aac727657896deb762b7cfc0104af7.png" alt="图 1">  </p>
<h1 id="跨页面爬虫流程"><a href="#跨页面爬虫流程" class="headerlink" title="跨页面爬虫流程"></a>跨页面爬虫流程</h1><ol>
<li>定义爬虫函数爬取列表页所有专题的URL</li>
<li>将专题URL存入列表中</li>
<li>定义爬取详细页数据函数</li>
<li>进入专题详细页面爬取详细页数据</li>
<li>存储数据，循环完毕，结束爬虫程序</li>
</ol>
<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/0a7ebde500e1077798346af020b5733b2d0c244fbc50dedc415fcc1b963b4329.png" alt="图 2">  </p>
<h1 id="网页构造"><a href="#网页构造" class="headerlink" title="网页构造"></a>网页构造</h1><p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/1edb085d880b0f18d7a503c2e437446001797c769e08b9fa41ef950965f74a6a.png" alt="图 3"><br>图中左侧为HTML文件，右侧为CSS样式，用<code>&lt;script&gt;&lt;/script&gt;</code>标签的就是<code>JavaScript</code>代码。用户浏览的网页就是浏览器选然后的结果，如果把网页比喻成房子的话，那么HTML为房子的框架和格局（几室几厅)，css就是房子的样式（地板、房漆）, JavaScript 就是房子中的电器 。</p>
<h1 id="爬虫三大库"><a href="#爬虫三大库" class="headerlink" title="爬虫三大库"></a>爬虫三大库</h1><h2 id="Requests库"><a href="#Requests库" class="headerlink" title="Requests库"></a>Requests库</h2><p>使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">res = requests.get(<span class="string">&#x27;http://bj.xiaozhu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<p>返回的结果就是网页的源代码<br>有时爬虫需要加入请求头来伪装成浏览器，以便更好地抓取数据。在Chrome浏览器中按F12键打开Chrome开发者工具，刷新网页后找到 User-Agent 进行复制<br>请求头的使用方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">res = requests.get(<span class="string">&#x27;http://bj.xiaozhu.com&#x27;</span>,headers=headers)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<p>Requests 库不仅有get()方法，还有post()等方法。post()方法用于提交表单来爬取需要登录才能获得数据的网站</p>
<h2 id="Requests库的错误和异常"><a href="#Requests库的错误和异常" class="headerlink" title="Requests库的错误和异常"></a>Requests库的错误和异常</h2><ul>
<li>Requests抛出一个ConnectionError异常，原因为网络问题（如 DNS 查询失败、拒绝连接等）</li>
<li>Response.raise_for_status（）抛出一个HTTPError异常，原因为HTTP请求返回了不成功的状态码（如网页不存在，返回 404 错误)</li>
<li>Requests抛出一个Timeout异常，原因为请求超时。</li>
<li>Requests抛出一个TooMa町Redirects异常，原因为请求超过了设定的最重定向次数。</li>
</ul>
<p>所有Requests显式抛出的异常都继承自requests.exceptions.RequestException，这时，可通过Python中的try来避免异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">res = requests.get(<span class="string">&#x27;https://bj.xiaozhu.com/&#x27;</span>,headers=headers)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(res.text)</span><br><span class="line"><span class="keyword">except</span> ConnectionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;连接失败&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="BeautifulSoup库"><a href="#BeautifulSoup库" class="headerlink" title="BeautifulSoup库"></a>BeautifulSoup库</h2><p>通过 BeautifulSoup 库可以轻松地解析 Requests 库请求的网页，并把网页源代码解析为 Soup 文档，以便过滤提取数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">res = requests.get(<span class="string">&#x27;https://bj.xiaozhu.com/&#x27;</span>,headers=headers)</span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br><span class="line">soup = BeautifulSoup(res.text,<span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.prettify())</span><br></pre></td></tr></table></figure>

<p>Beautifulsoup除了支持Python标准库中的HTML解析器外，还支持一些第三方的解析器</p>
<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/98cdeb8165b2b10f16bf3395f8e8e8947c9264d3de8d4e36d69dc56c86381cc2.png" alt="图 1">  </p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><strong>find_all()</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_all(tag,attibutes,recursive,text,limit,keywords)</span><br><span class="line"></span><br><span class="line">soup.find_all(<span class="string">&#x27;div&#x27;</span>,<span class="string">&quot;item&quot;</span>)<span class="comment">##查找div标签，class=&quot;item&quot;</span></span><br><span class="line">soup.find_all(<span class="string">&#x27;div&#x27;</span>,<span class="keyword">class</span>=<span class="string">&#x27;item&#x27;</span>)</span><br><span class="line">soup.find_all(<span class="string">&#x27;div&#x27;</span>,attrs=&#123;<span class="string">&#x27;class&#x27;</span>:<span class="string">&quot;item&quot;</span>&#125;) <span class="comment"># attrs参数定义一个字典来搜索包含特殊属性的tag</span></span><br></pre></td></tr></table></figure>

<p><strong>find()方法</strong></p>
<p>find()方法与find_all()方法类似，只是find_all()方法返回的是文档中符合条件的所有tag ，是一个集合(class’bs4.element.ResultSet’),find()方法返回的一个Tag(class’bs4 .element.Tag’)<br><strong>selector()方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.selector(div.item&gt;a&gt;h1) <span class="comment">#括号内容通过Chorm复制得道</span></span><br></pre></td></tr></table></figure>

<ul>
<li>鼠标定位到想要提取的数据位置，右击，在弹出的快捷菜单中选择“检查”命令。</li>
<li>在网页源代码中右击所选元素</li>
<li>在弹出的快捷菜单中选择Copy selector。</li>
</ul>
<p>案例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_info</span>(<span class="params">url</span>):</span><br><span class="line">    wb_data = requests.get(<span class="string">&#x27;http://www.kugou.com/yy/rank/home/1-8888.html&#x27;</span>,headers=headers)</span><br><span class="line">    soup = BeautifulSoup(wb_data.text,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    ranks = soup.select(<span class="string">&#x27;span.pc_temp_num&#x27;</span>)</span><br><span class="line">    titles = soup.select(<span class="string">&#x27;div.pc_temp_songlist &gt; ul &gt; li&gt; a&#x27;</span>)</span><br><span class="line">    times = soup.select(<span class="string">&#x27;div.pc_temp_songlist &gt; ul &gt; li&gt; span.pc_temp_tips_r &gt; span&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> rank,title,time <span class="keyword">in</span> <span class="built_in">zip</span>(ranks,titles,times):</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;rank&#x27;</span>:rank.get_text().strip(),</span><br><span class="line">            <span class="string">&#x27;singer&#x27;</span>:title.get_text().split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>],</span><br><span class="line">            <span class="string">&#x27;song&#x27;</span>:title.get_text().split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">1</span>],</span><br><span class="line">            <span class="string">&#x27;time&#x27;</span>:time.get_text().strip()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    urls = [<span class="string">&#x27;http://www.kugou.com/yy/rank/home/&#123;&#125;-8888.html&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">24</span>)]</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        get_info(url)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/96d7eb1f96d9cb2947a2ecfb50ae8fee040538860db4ee0ce317d97cf7979626.png" alt="图 2">  </p>
<p>本案例并未完全使用“Copy selector”，的全部信息，由于有些标签是固定的,因此选用部分路径即可。</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>Python中的re模块拥有着全部的正则表达式功能，为网络爬虫提供了可能。</p>
<h2 id="一般字符"><a href="#一般字符" class="headerlink" title="一般字符"></a>一般字符</h2><table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>匹配任意单个字符（不包括换行符\n）</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义字符（把有特殊含义的字符转换成字面意思）</td>
</tr>
<tr>
<td><code>[...]</code></td>
<td>字符集。对应字符集中的任意字符</td>
</tr>
</tbody></table>
<p>说明：</p>
<ol>
<li><code>.</code>字符为匹配任意单个字符。例如， <code>a.b</code> 可以的匹配结果为 abc、aic、a&amp;c等，但不包括换行符。</li>
<li><code>\</code>字符为转义字符，可以把字符改变为原来的意思。听上去不是很好理解，例如<code>.</code>字符是匹配任意的单个字符,但有时不需要这个功能，只想让它代表一个点，这时就可以使用<code>\.</code>，就能匹配为<code>.</code>了。</li>
<li><code>[...］</code>为字符集，相当于在中括号中任选一个。例如 a[bcd］，匹配的结果为ab、ac和ad 。</li>
</ol>
<h2 id="预定以字符集"><a href="#预定以字符集" class="headerlink" title="预定以字符集"></a>预定以字符集</h2><table>
<thead>
<tr>
<th>预定以字符集</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\d</code></td>
<td>匹配一个数字字符，等价于<code>[0-9]</code></td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配一个非数字字符，等价于<code>[^0-9]</code></td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任何空白字符，包括空格，制表符，换页符等，等价于<code>[\f\n\r\t\v]</code></td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任何非空白字符，等价于<code>[^\f\n\r\t\v]</code></td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配包括下划线的任何单词字符，等价于<code>[A-Za-z0-9]</code></td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配任何非单词字符。等价于<code>[^A-Za-z0-9_]</code></td>
</tr>
</tbody></table>
<h2 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h2><table>
<thead>
<tr>
<th>数量词</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>匹配前一个字符0或无限次</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前一个字符1或无限次</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前一个字符0或1次</td>
</tr>
<tr>
<td><code>&#123;m&#125;</code></td>
<td>匹配前一个字符m次</td>
</tr>
<tr>
<td><code>&#123;m,n&#125;</code></td>
<td>匹配前一个字符m次至n次</td>
</tr>
</tbody></table>
<p>说明：</p>
<ol>
<li>“＊”数量词匹配前一个字符 0 或无限次。例如， ab*c 匹配 ac、abc、abbc和abbbc等。</li>
<li>“＋”与”*”很类似，只是至少匹配前一个字符一次。例如，ab+c匹配abc、abbc和 abbbc 等。</li>
<li>“?”数量词匹配前一个字符0或1次。例如，ab?c匹配ac和abc 。</li>
<li>“｛m｝”数量词匹配前一个字符 m 次 。例如，ab{3}c 匹配 abbbc 。</li>
<li>“{m,n}”数量词匹配前一个字符 m 至 n 次。例如， ab {1, 3}c 匹配 abc、abbc和abbbc</li>
</ol>
<h2 id="边界匹配"><a href="#边界匹配" class="headerlink" title="边界匹配"></a>边界匹配</h2><table>
<thead>
<tr>
<th>边界匹配</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>匹配字符串开头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配字符串结尾</td>
</tr>
<tr>
<td><code>\A</code></td>
<td>仅匹配字符串开头</td>
</tr>
<tr>
<td><code>\Z</code></td>
<td>仅匹配字符串结尾</td>
</tr>
</tbody></table>
<p>说明：</p>
<ol>
<li>“A”匹配字符串的开头。例如，让^abc匹配 abc 开头的字符串。</li>
<li>“$”匹配字符串的结尾 。 例如，abc$ 匹配 abc 结尾的字符串。</li>
<li>“\A”匹配字符串的结尾。例如， \Aabc。</li>
<li>“\Z”匹配字符串的结尾。例如， abc\Z 。</li>
</ol>
<h2 id="re模块及其方法"><a href="#re模块及其方法" class="headerlink" title="re模块及其方法"></a>re模块及其方法</h2><h3 id="search-函数"><a href="#search-函数" class="headerlink" title="search()函数"></a>search()函数</h3><p>匹配并提取第一个符合规律的内容，返回一个正则表达式对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.match(pattern,string,flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>pattern为匹配的正则表达式</li>
<li>string为要匹配的字符串</li>
<li>flags为标志位，用户控制正则表达式的匹配方式，如是否区分大小写，多行匹配等</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = <span class="string">&#x27;one1two2three3&#x27;</span></span><br><span class="line">infos = re.search(<span class="string">&#x27;\d+&#x27;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(infos) <span class="comment">#search方法返回的是正则表达式对象</span></span><br><span class="line"><span class="built_in">print</span>(infos.group())</span><br></pre></td></tr></table></figure>

<h3 id="sub-函数"><a href="#sub-函数" class="headerlink" title="sub()函数"></a>sub()函数</h3><p>用于替换字符串中的匹配项</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.sub(pattern,repl,string,count=<span class="number">0</span>,flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ol>
<li>pattern为匹配的正则表达式</li>
<li>repl为替换的字符串</li>
<li>string为要被查找替换的原始字符串</li>
<li>counts为模式匹配后替换的最大次数，默认0表示替换所有的匹配</li>
<li>flags为标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">phone = <span class="string">&#x27;123-456-789&#x27;</span></span><br><span class="line">new_phone = re.sub(<span class="string">&#x27;\D&#x27;</span>,<span class="string">&#x27;&#x27;</span>,phone)</span><br><span class="line"><span class="built_in">print</span>(new_phone) <span class="comment">#sub()方法用于替换</span></span><br></pre></td></tr></table></figure>

<h3 id="findall-函数"><a href="#findall-函数" class="headerlink" title="findall()函数"></a>findall()函数</h3><p>findall()函数匹配所有符合规律的内容，并以列表的形式返回。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a = <span class="string">&#x27;one1two2three3&#x27;</span></span><br><span class="line">infos = re.findall(<span class="string">&#x27;\d+&#x27;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(infos)</span><br></pre></td></tr></table></figure>

<h3 id="re模块修饰符"><a href="#re模块修饰符" class="headerlink" title="re模块修饰符"></a>re模块修饰符</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>re.I</td>
<td>使匹配对大小写不敏感</td>
</tr>
<tr>
<td>re.L</td>
<td>做本地化识别（local-aware）匹配</td>
</tr>
<tr>
<td>re.M</td>
<td>多行匹配，影响^和$</td>
</tr>
<tr>
<td>re.S</td>
<td>使匹配包括换行在内的所有字符</td>
</tr>
<tr>
<td>re.U</td>
<td>根据Unicode字符集解析字符。这个标志影响\w,\W,\b,\B</td>
</tr>
<tr>
<td>re.X</td>
<td>该标志通过给予更灵活的格式，以便将正则表达式写得更易理解</td>
</tr>
</tbody></table>
<p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:</span><br><span class="line">        <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;/home/a1ili/Y-A/doupo.txt&#x27;</span>,<span class="string">&#x27;a+&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_info</span>(<span class="params">url</span>):</span><br><span class="line">    res = requests.get(url,headers=headers)</span><br><span class="line">    <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">        contents = re.findall(<span class="string">&#x27;&lt;p&gt;(.*?)&lt;/p&gt;&#x27;</span>,res.content.decode(<span class="string">&#x27;utf-8&#x27;</span>),re.S)</span><br><span class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">            f.write(content+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    urls = [<span class="string">&#x27;http://www.doupoxs.com/doupocangqiong/&#123;&#125;.html&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1665</span>)]</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        get_info(url)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h1 id="LXML库与Xpath语法"><a href="#LXML库与Xpath语法" class="headerlink" title="LXML库与Xpath语法"></a>LXML库与Xpath语法</h1><p>Lxml库是基于libxml2的XML解析库的Python封装。该模块使用 C 语言编写，解析速度比 Beautiful Soup 更快。 Lxml 库使用 Xpath 语法解析定位网页数据。</p>
<h2 id="LXML库的使用"><a href="#LXML库的使用" class="headerlink" title="LXML库的使用"></a>LXML库的使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;red&quot;&gt;&lt;h1&gt;red flower&lt;/h1&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;yellow&quot;&gt;&lt;h2&gt;yellow flower&lt;/h2&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;white&quot;&gt;&lt;h3&gt;white flower&lt;/h3&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line"><span class="built_in">print</span>(html)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/0b1e53f6758ae790a333a394d56f4d9ca54d69bde372c9dafb5549e17af92075.png" alt="图 9">  </p>
<p>etree库把HTML文档解析为Element对象，可以通过下面代码输出解析过的HTML文档。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;red&quot;&gt;&lt;h1&gt;red flower&lt;/h1&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;yellow&quot;&gt;&lt;h2&gt;yellow flower&lt;/h2&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;white&quot;&gt;&lt;h3&gt;white flower&lt;/h3&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">html = etree.HTML(text)</span><br><span class="line">result = etree.tostring(html)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">#result</span></span><br><span class="line"><span class="string">b&#x27;&lt;html&gt;&lt;body&gt;&lt;div&gt;\n    &lt;ul&gt;\n        &lt;li class=&quot;red&quot;&gt;&lt;h1&gt;red flower&lt;/h1&gt;&lt;/li&gt;\n        &lt;li class=&quot;yellow&quot;&gt;&lt;h2&gt;yellow flower&lt;/h2&gt;&lt;/li&gt;\n        &lt;li class=&quot;white&quot;&gt;&lt;h3&gt;white flower&lt;/h3&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/div&gt;\n&lt;/body&gt;&lt;/html&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>lxml继承了libxml2的特性，具有自动修正html代码的功能。添加了html和body标签</p>
<h2 id="读取html文件"><a href="#读取html文件" class="headerlink" title="读取html文件"></a>读取html文件</h2><p>除了直接读取 字符串，lxml库还支持从文件中提取内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.parse(<span class="string">&#x27;color.html&#x27;</span>)</span><br><span class="line">result = etree.tostring(html,pretty_print=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>html文件与代码文件在同一层时，用相对路径，不再同一层时使用绝对路径</p>
<p>在同一路径新建color.html，文件内容如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>flower<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>red flower<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h2</span>&gt;</span>yellow flower<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;white&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>white flower<span class="tag">&lt;/<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解析html文件"><a href="#解析html文件" class="headerlink" title="解析html文件"></a>解析html文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:</span><br><span class="line">        <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">res= requests.get(<span class="string">&#x27;https://book.douban.com/top250&#x27;</span>,headers=headers)</span><br><span class="line">html = etree.HTML(res.text)</span><br><span class="line"><span class="built_in">print</span>(html)</span><br><span class="line">result = etree.tostring(html)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Xpath语法"><a href="#Xpath语法" class="headerlink" title="Xpath语法"></a>Xpath语法</h2><p>Xpath是一门在xml文档中查找信息的语言</p>
<h3 id="节点选择"><a href="#节点选择" class="headerlink" title="节点选择"></a>节点选择</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nodename</td>
<td>选取此节点的所有子节点</td>
</tr>
<tr>
<td><code>/</code></td>
<td>从根节点选取</td>
</tr>
<tr>
<td><code>//</code></td>
<td>从匹配选择的当前节点选择文档中的节点，而不考虑他们的位置</td>
</tr>
<tr>
<td><code>.</code></td>
<td>选取当前节点</td>
</tr>
<tr>
<td><code>..</code></td>
<td>选取当前节点的父节点</td>
</tr>
<tr>
<td><code>@</code></td>
<td>选取属性</td>
</tr>
</tbody></table>
<p><strong>节点选择实例</strong></p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>user_database</code></td>
<td>选取元素<code>user_database</code>的所有子节点</td>
</tr>
<tr>
<td><code>/user_database</code></td>
<td>选取根元素user_database。注释：假如路径起始于正斜杠（&#x2F;），则此路经始终代表到某元素的绝对路径</td>
</tr>
<tr>
<td>user_database&#x2F;user</td>
<td>选取属于user_database的子元素的所有user元素</td>
</tr>
<tr>
<td><code>//user</code></td>
<td>选取所有user子元素，而不管他们在文档中的位置</td>
</tr>
<tr>
<td><code>user_database//user</code></td>
<td>选择属于user_databae元素的后代的所有user元素，而不管他们位于user_database之下的什么位置</td>
</tr>
<tr>
<td><code>//@attribute</code></td>
<td>选取名为attibute的所有属性</td>
</tr>
</tbody></table>
<p>Xpath语法中的谓语用来查找某个特定的节点或者包含某个指定值的节点，谓语被嵌套在方括号中。</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>/user_database/user[1]</code></td>
<td>选取属于user_database子元素的第一个user元素</td>
</tr>
<tr>
<td><code>//li@attribute()</code></td>
<td>选取所有拥有名为attribute属性的li元素</td>
</tr>
<tr>
<td><code>//li[@attribute=&#39;red&#39;</code>]</td>
<td>选取所有li元素，且这些元素拥有值为red的attribute属性</td>
</tr>
</tbody></table>
<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p>步骤：</p>
<ol>
<li>鼠标定位到想要提取的数据位置，右击，从弹出的快捷菜单中选择“检查”命令。</li>
<li>在网页源码中右击所选元素</li>
<li>从弹出的快捷菜单中选择copy Xpath命令。</li>
</ol>
<p>当需要进行批量爬取时，通过类似Beautiful中的selector()方法删除谓语部分是不可行的。这时的思路为”先抓大后抓小，寻找循环点”。</p>
<p>有时候会遇到相同的字符开头的多个标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;tag-1&quot;</span>&gt;</span>需要的内容1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;tag-2&quot;</span>&gt;</span>需要的内容2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;tag-3&quot;</span>&gt;</span>需要的内容3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>想要同时爬取时，不需要构造多个Xpath路径，通过start-with()便可以获取多个标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;li class=&quot;tag-1&quot;&gt;需要的内容1&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li class=&quot;tag-2&quot;&gt;需要的内容2&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li class=&quot;tag-3&quot;&gt;需要的内容3&lt;/li&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">selector = etree.HTML(html)</span><br><span class="line">contents = selector.xpath(<span class="string">&#x27;//li[starts-with(@class,&quot;tag&quot;)]/text()&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/74b51a3caf99edb6561cfc1147d08365c77ff3babbb4c3dc70373eda0d3bbb0e.png" alt="图 10">  </p>
<p>当遇到标签套标签的情况时：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>需要的内容1</span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>需要的内容2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>向同时爬取文本内容，可以通过string(.)完成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;red&quot;&gt;需要的内容1</span></span><br><span class="line"><span class="string">    &lt;h1&gt;需要的内容2&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">selector = etree.HTML(html)</span><br><span class="line">content1 = selector.xpath(<span class="string">&#x27;//div[@class=&quot;red&quot;]&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">content2 = content1.xpath(<span class="string">&#x27;string(.)&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content2)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/25/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/3b5dbe9beef8e4dc98e0e94be6d3f4b953f5dac1c6b10b92f71f40f0d95f6306.png" alt="图 11">  </p>
<p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;douabn.csv&#x27;</span>,<span class="string">&#x27;wt&#x27;</span>,newline=<span class="string">&#x27;&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">writer = csv.writer(fp)</span><br><span class="line">writer.writerow((<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;url&#x27;</span>,<span class="string">&#x27;author&#x27;</span>,<span class="string">&#x27;publisher&#x27;</span>,<span class="string">&#x27;date&#x27;</span>,<span class="string">&#x27;price&#x27;</span>,<span class="string">&#x27;rate&#x27;</span>,<span class="string">&#x27;comment&#x27;</span>))</span><br><span class="line">urls = [<span class="string">&#x27;https://book.douban.com/top250?start=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">250</span>,<span class="number">25</span>)]</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:</span><br><span class="line">        <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">    html = requests.get(url,headers=headers)</span><br><span class="line">    selector = etree.HTML(html.text)</span><br><span class="line">    infos = selector.xpath(<span class="string">&#x27;//tr[@class = &quot;item&quot;]&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> info <span class="keyword">in</span> infos:</span><br><span class="line">        name = info.xpath(<span class="string">&#x27;td/div/a/@title&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        url = info.xpath(<span class="string">&#x27;//td/div/a/@href&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        book_infos = info.xpath(<span class="string">&#x27;td/p/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        auth = book_infos.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        publisher = book_infos.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">3</span>]</span><br><span class="line">        data = book_infos.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">2</span>]</span><br><span class="line">        price = book_infos.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        rate = info.xpath(<span class="string">&#x27;td/div/span[2]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        comments = info.xpath(<span class="string">&#x27;td/p/span/text()&#x27;</span>)</span><br><span class="line">        comment = comments[<span class="number">0</span>] <span class="keyword">if</span> <span class="built_in">len</span>(comments) != <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        writer.writerow((name,url,auth,publisher,data,price,rate,comment))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>书名：《从零开始学爬虫》</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Objection</title>
    <url>/2022/05/01/Objection/</url>
    <content><![CDATA[<p>Objection是基于frida的命令行hook工具</p>
<span id="more"></span>

<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install objection</span><br></pre></td></tr></table></figure>

<p>使用</p>
<ol>
<li>启动对应版本的frida-server</li>
<li>转发端口</li>
<li>附加需要调试的app，进入交互界面</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objection -g [packageName] explore</span><br></pre></td></tr></table></figure>

<h1 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h1><h2 id="空格键"><a href="#空格键" class="headerlink" title="空格键"></a>空格键</h2><p>直接输入空格，会有提示与补全</p>
<h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">help + command</span><br><span class="line">提示详细介绍指定命令的作用与例子</span><br></pre></td></tr></table></figure>

<h2 id="sqlite"><a href="#sqlite" class="headerlink" title="sqlite"></a>sqlite</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite connect [sqlite数据库]</span><br></pre></td></tr></table></figure>

<h2 id="env"><a href="#env" class="headerlink" title="env"></a>env</h2><p><img src="/2022/05/01/Objection/2433b72143c160f0ffc0a6dfeb44f22ac95f38e41169f0601776cd2f695c3efb.png" alt="图 1">  </p>
<h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><p>退出</p>
<h2 id="reconnect"><a href="#reconnect" class="headerlink" title="reconnect"></a>reconnect</h2><p>从新连接</p>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除命令</p>
<h2 id="frida"><a href="#frida" class="headerlink" title="frida"></a>frida</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command: frida</span><br><span class="line"></span><br><span class="line">Usage: frida</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">   frida</span><br></pre></td></tr></table></figure>

<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: import &lt;path to local fridascript&gt; (optional: &lt;job name&gt;) (optional: --no-exception-handler)</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">   import ~/home/myscript.js</span><br><span class="line">   import ~/home/hooks/custom.js custom-hook-name</span><br><span class="line">   import ~/home/hooks/custom.js custom-hook-name --no-exception-handler</span><br><span class="line">   import ~/home/script.js --no-exception-handler</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memory list modules</span><br><span class="line">列出当前进程加载的所有so模块</span><br><span class="line"></span><br><span class="line">memory list exports XX.so</span><br><span class="line">列出XX.so的导出函数</span><br></pre></td></tr></table></figure>

<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: memory search &quot;&lt;pattern eg: 41 41 41 ?? 41&gt;&quot; (--string) (--offsets-only)</span><br><span class="line">在当前内存中查找某一模块</span><br></pre></td></tr></table></figure>

<h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: memory write &quot;&lt;address&gt;&quot; &quot;&lt;pattern eg: 41 41 41 41&gt;&quot; (--string)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: </span><br><span class="line">memory dump all &lt;local destination&gt;</span><br><span class="line">memory dump from_base &lt;base_address&gt; &lt;size_to_dump&gt; &lt;local_destination&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ui"><a href="#ui" class="headerlink" title="ui"></a>ui</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ui alert </span><br><span class="line">#show an alert message</span><br></pre></td></tr></table></figure>

<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: plugin load &lt;plugin path&gt; (&lt;plugin namespace&gt;)</span><br><span class="line"># 加载插件</span><br></pre></td></tr></table></figure>

<h2 id="evaluate"><a href="#evaluate" class="headerlink" title="evaluate"></a>evaluate</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入js脚本编写界面</span><br></pre></td></tr></table></figure>

<h2 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h2><h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file cat filename</span><br><span class="line">#查看文件</span><br><span class="line"></span><br><span class="line">file download &lt;remote location&gt; (optional: &lt;local destination&gt;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file http start [端口号]</span><br></pre></td></tr></table></figure>

<h2 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commands clear </span><br><span class="line"># 清除命令</span><br><span class="line">commands history</span><br><span class="line">commands save [path]</span><br></pre></td></tr></table></figure>

<h2 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jobs list</span><br><span class="line">jobs kill</span><br></pre></td></tr></table></figure>

<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android clipboard monitor </span><br><span class="line">#监听剪切板</span><br><span class="line">android deoptimize</span><br><span class="line">#暴力执行</span><br></pre></td></tr></table></figure>

<h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: </span><br><span class="line">android heap execute js &lt;hashcode&gt; (eg: 24688232)</span><br><span class="line"></span><br><span class="line">android heap execute method &lt;hashcode&gt; &lt;method&gt; (eg: 24688232)</span><br><span class="line"></span><br><span class="line">android heap search instances &lt;class&gt; (eg: com.example.test)</span><br></pre></td></tr></table></figure>

<h3 id="hooking"><a href="#hooking" class="headerlink" title="hooking"></a>hooking</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android hooking generate class</span><br><span class="line"></span><br><span class="line">android hooking generate simple [classname]</span><br><span class="line"></span><br><span class="line">android hooking get current_activity</span><br><span class="line"></span><br><span class="line">android hooking list activities</span><br><span class="line"></span><br><span class="line">android hooking list class_loaders</span><br><span class="line"></span><br><span class="line">android hooking list class_methods [class_name]</span><br><span class="line"></span><br><span class="line">android hooking list classes</span><br><span class="line"></span><br><span class="line">android hooking list receivers</span><br><span class="line"></span><br><span class="line">android hooking list services</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="search-1"><a href="#search-1" class="headerlink" title="search"></a>search</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android hooking search classes &lt;name&gt;</span><br><span class="line"></span><br><span class="line">android hooking search methods &lt;name&gt; (optional: &lt;package-filter&gt;)</span><br></pre></td></tr></table></figure>

<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android hooking set return_value &quot;&lt;fully qualified class method&gt;&quot; &quot;&lt;optional overload&gt;&quot; (eg: &quot;com.example.test.doLogin&quot;) &lt;true/false&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android hooking watch class &lt;class&gt; (eg: com.example.test)</span><br><span class="line"></span><br><span class="line">android hooking watch class_method &lt;fully qualified class method&gt; &lt;optional overload&gt; (optional: --dump-args) (optional: --dump-backtrace) (optional: --dump-return)</span><br></pre></td></tr></table></figure>

<h3 id="intent"><a href="#intent" class="headerlink" title="intent"></a>intent</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android intent launch_activity &lt;activity_class&gt;</span><br><span class="line"></span><br><span class="line">android intent launch_service &lt;service_class&gt;</span><br></pre></td></tr></table></figure>

<h3 id="keystore"><a href="#keystore" class="headerlink" title="keystore"></a>keystore</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android keystore list</span><br><span class="line">android keystore watch</span><br><span class="line">android keystore clear</span><br></pre></td></tr></table></figure>

<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android proxy set [ip] [port]</span><br></pre></td></tr></table></figure>

<h3 id="root"><a href="#root" class="headerlink" title="root"></a>root</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android root disable</span><br><span class="line">android root simulate</span><br></pre></td></tr></table></figure>

<h3 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec"></a>shell_exec</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android shell_exec</span><br></pre></td></tr></table></figure>

<h3 id="sslpinning"><a href="#sslpinning" class="headerlink" title="sslpinning"></a>sslpinning</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android sslpinning disable</span><br></pre></td></tr></table></figure>

<h3 id="ui-1"><a href="#ui-1" class="headerlink" title="ui"></a>ui</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android ui FLAG_SECURE [true/false]</span><br><span class="line"></span><br><span class="line">android ui screenshot [1.png]</span><br></pre></td></tr></table></figure>

<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastboot</title>
    <url>/2022/05/01/Fastboot/</url>
    <content><![CDATA[<p>一些常用命令</p>
<span id="more"></span>

<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><ul>
<li>system:系统分区</li>
<li>userdata:数据分区</li>
<li>cache:缓存分区</li>
<li>recovery:Recovery分区</li>
<li>boot:存放内核和ramdisk的分区</li>
<li>hboot:这个是SPL所在的分区，也是fastboot所在的分区.刷错就真的变砖了</li>
<li>splash1:这个就是开机第一屏幕了</li>
<li>radio:这个是radio所在的分区</li>
</ul>
<h1 id="刷分区"><a href="#刷分区" class="headerlink" title="刷分区"></a>刷分区</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash &#x27;对应分区&#x27; &#x27;镜像&#x27;</span><br><span class="line">ep: fastboot flash system system.img</span><br></pre></td></tr></table></figure>

<h1 id="清空分区"><a href="#清空分区" class="headerlink" title="清空分区"></a>清空分区</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot erase &#x27;分区名&#x27;</span><br><span class="line">ep: fastboot erase cache</span><br></pre></td></tr></table></figure>

<h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><p>解锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot oem unlock</span><br></pre></td></tr></table></figure>

<p>获取手机全部信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot getvar all</span><br></pre></td></tr></table></figure>

<p>引导启动外部镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot boot xxx.img</span><br></pre></td></tr></table></figure>

<p>查看手机是否连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot devices</span><br></pre></td></tr></table></figure>

<p>重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>decpry</title>
    <url>/2022/05/14/decpry/</url>
    <content><![CDATA[<p>CTF-ELF</p>
<span id="more"></span>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><strong>1</strong></p>
<p>拖入IDA直接F5看源码<br><img src="/2022/05/14/decpry/6d03c172cfc091a9972a022b0321875e483bff8f1fb8b8d6572e97d50197037d.png" alt="图 1">  </p>
<p><strong>2</strong><br>查看代码<br><img src="/2022/05/14/decpry/bd5cbd0d80a0ca2d4ddc5df9ff51c3dc88bdabcf5ff5b9bc6adb87ed3d6df182.png" alt="图 2"><br>可以看到decrypt函数，顾名思义就是解密函数，然后使用gdb动态调试（不知道为啥linux版本的gdb不行，要使用debian版的，这玩意卡了我一个小时）</p>
<p>使用调试命令如下<br><img src="/2022/05/14/decpry/2c068f3f4fe7956b4a9eabbbb2787430ecf0b93979fc87606cb9d657ef060a75.png" alt="图 3">  </p>
<p><img src="/2022/05/14/decpry/df741cd028b226a0b6850850338c0873484dd248fd81c393a583f0411724d7f3.png" alt="图 4">  </p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>win逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>x86_x64汇编</title>
    <url>/2022/05/14/x86-x64%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<p>x86汇编</p>
<span id="more"></span>

<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>通用寄存器8个</p>
<table>
<thead>
<tr>
<th>16位</th>
<th>32位</th>
<th>64位</th>
</tr>
</thead>
<tbody><tr>
<td>AX</td>
<td>EAX</td>
<td>RAX</td>
</tr>
<tr>
<td>BX</td>
<td>EBX</td>
<td>RBX</td>
</tr>
<tr>
<td>CX</td>
<td>ECX</td>
<td>RCX</td>
</tr>
<tr>
<td>DX</td>
<td>EDX</td>
<td>RDX</td>
</tr>
<tr>
<td>SP</td>
<td>ESP</td>
<td>RSP</td>
</tr>
<tr>
<td>BP</td>
<td>EBP</td>
<td>RBP</td>
</tr>
<tr>
<td>DI</td>
<td>EDI</td>
<td>RDI</td>
</tr>
<tr>
<td>SI</td>
<td>ESI</td>
<td>RSI</td>
</tr>
</tbody></table>
<p>AX&#x2F;EAX&#x2F;RAX、BX&#x2F;EBX&#x2F;RBX、CX&#x2F;ECX&#x2F;RCX、DX&#x2F;EDX&#x2F;RDX在一般情况下作为通用的数据寄存器，用来暂时存放计算过程中所用到的操作数、结果或其他信息。它们还可分为两个独立的8位寄存器使用，命名为AL、AH、BL、BH、CL、CH、DL和DH。</p>
<ul>
<li>AX&#x2F;EAX&#x2F;RAX作为累加器，算术运算的主要寄存器，在乘法指令中指定用来存放操作数，另外，所有的I&#x2F;O指令都使用AX或AL与外部设备传送信息。</li>
<li>BX&#x2F;EBX&#x2F;RBX在计算存储器地址时，可作为基址寄存器使用。</li>
<li>CX&#x2F;ECX&#x2F;RCX常用来保存计数值，如在移位指令、循环指令和串处理指令中用作隐含的计数器。DX在作双字长运算时，可把DX和AX组合在一起存放一个双字长数，DX用来存放高16位数据。此外，对某些I&#x2F;O操作，DX可用来存放I&#x2F;O的端口地址。</li>
<li>SP&#x2F;ESP&#x2F;RSP、BP&#x2F;EBP&#x2F;RBP、SI&#x2F;ESI&#x2F;RSI、DI&#x2F;EDI&#x2F;RDI四个16&#x2F;32位寄存器可以象数据寄存器一样在运算过程中存放操作数，但它们只能以字（16&#x2F;32位&#x2F;64位）为单位使用。此外，它们更经常的用途是在存储器寻址时，提供偏移地址。因此，它们可称为指针或变址寄存器。</li>
<li>SP&#x2F;ESP称为堆栈指针寄存器，用来指出栈顶的偏移地址。</li>
<li>BP&#x2F;EBP称为基址指针寄存器，在寻址时作为基地址寄存器使用，但它必须与堆栈段寄存器SS联用来确定堆栈段中的存储单元地址。</li>
</ul>
<h2 id="标志寄存器FLAG"><a href="#标志寄存器FLAG" class="headerlink" title="标志寄存器FLAG"></a>标志寄存器FLAG</h2><p>条件码标志用来记录程序中运行结果的状态信息，它们是根据有关指令的运行结果由(CPU)自动设置的。由于这些状态信息往往作为后续条件转移指令的转移控制条件，所以称为条件码。</p>
<ul>
<li>进位标志CF，记录运算时最高有效位产生的进位值</li>
<li>符号标志SF，记录运算结果的符号，结果为负时置1，否则置0</li>
<li>零标志ZF，运算结果为0时ZF位置1，否则0</li>
<li>溢出标志OF，在运算过程中，如操作数超出了机器可表示数的范围称为溢出，溢出时OF值为1否则为0</li>
<li>辅助进位标志AF，记录运算时第3位（半个字节）产生的进位值。</li>
<li>奇偶标志PF，用来为机器中传送信息时可能产生的代码出错情况提供检验条件。当结果操作数中1的个数为偶数时值为1，否则为0</li>
</ul>
<h1 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h1><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><h3 id="传送指令mov"><a href="#传送指令mov" class="headerlink" title="传送指令mov"></a>传送指令mov</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov reg/mem,reg/mem/imm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中：Reg—Register(寄存器)，Mem—Memory(存储器)，Imm—Immediate(立即数)，它们可以是8位、16位或32位(特别指出其位数的除外)。</p>
<h3 id="传送-填充指令"><a href="#传送-填充指令" class="headerlink" title="传送-填充指令"></a>传送-填充指令</h3><p>传送—填充指令是把位数短的源操作数传送给位数长的目的操作数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOVSX/MOVZX  Reg/Mem, Reg/Mem/Imm　</span><br></pre></td></tr></table></figure>

<p>指令的主要功能和限制与MOV指令类似，不同之处是：在传送时，对目的操作数的高位进行填充。根据其填充方式，又分为：符号填充和零填充。</p>
<p><strong>符号填充指令movsx</strong><br>movsx的填充方式是：用源操作的符号来填充目的操作数的高位数据位</p>
<p><strong>零填充指令movzx</strong><br>movzx的填充方式是：横用0来填充目的操作数的高位数据位</p>
<h3 id="交换指令XCHG"><a href="#交换指令XCHG" class="headerlink" title="交换指令XCHG"></a>交换指令XCHG</h3><p>交换指令XCHG是两个寄存器，寄存器和内存变量之间内容的交换指令，两个操作数的数据类型要相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XCHG  Reg/Mem, Reg/Mem</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AX=5678H，BX=1234H，指令XCHG  AX, BX执行后,(AX)=1234H，(BX)=5678H</span><br></pre></td></tr></table></figure>

<h3 id="取有效地址指令"><a href="#取有效地址指令" class="headerlink" title="取有效地址指令"></a>取有效地址指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea reg,mem</span><br></pre></td></tr></table></figure>

<h3 id="取段寄存器指令"><a href="#取段寄存器指令" class="headerlink" title="取段寄存器指令"></a>取段寄存器指令</h3><p>该组指令的功能是把内存单元的一个“低字”传送给指令中指定的16位寄存器，把随后的一个“高字”传给相应的段寄存器(DS、ES、FS、GS和SS)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDS/LES/LFS/LGS/LSS　Reg, Mem</span><br></pre></td></tr></table></figure>

<h2 id="堆栈操作指令"><a href="#堆栈操作指令" class="headerlink" title="堆栈操作指令"></a>堆栈操作指令</h2><p>堆栈是一个重要的数据结构，它具有“先进后出”的特点，通常用来保存程序的返回地址。它主要有两大类操作：进&#x2F;压栈操作和出&#x2F;弹栈操作。</p>
<h3 id="PUSH"><a href="#PUSH" class="headerlink" title="PUSH"></a>PUSH</h3><p>指令格式：PUSH　Reg&#x2F;Mem  PUSH　Imm　　　<br>　　　<br>一个字进栈，系统自动完成两步操作：SP←SP-2，(SP)←操作数； </p>
<p>一个双字进栈，系统自动完成两步操作：ESP←ESP-4，(ESP)←操作数。 </p>
<h3 id="PUSHA"><a href="#PUSHA" class="headerlink" title="PUSHA"></a>PUSHA</h3><p>指令格式：PUSHA</p>
<p>其功能是依次把寄存器AX、CX、DX、BX、SP、BP、SI和DI等压栈。</p>
<h3 id="PUSHAD"><a href="#PUSHAD" class="headerlink" title="PUSHAD"></a>PUSHAD</h3><p>指令格式：PUSHAD</p>
<p>其功能是把寄存器EAX、ECX、EDX、EBX、ESP、EBP、ESI和EDI等压栈。</p>
<h2 id="出栈操作"><a href="#出栈操作" class="headerlink" title="出栈操作"></a>出栈操作</h2><h3 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h3><p>指令格式：POP　Reg&#x2F;Mem</p>
<p>弹出一个字，系统自动完成两步操作：操作数←(SP)，SP←SP-2；</p>
<p>弹出一个双字，系统自动完成两步操作：操作数←(ESP)，ESP←ESP-4。</p>
<h3 id="POPA"><a href="#POPA" class="headerlink" title="POPA"></a>POPA</h3><p>指令格式：POPA</p>
<p>其功能是依次把寄存器DI、SI、BP、SP、BX、DX、CX和AX等弹出栈。其实，程序员不用记住它们的具体顺序，只要与指令PUSHA对称使用就可以了。</p>
<h3 id="POPAD"><a href="#POPAD" class="headerlink" title="POPAD"></a>POPAD</h3><p>指令格式：POPAD　　</p>
<p>其功能是依次把寄存器EDI、ESI、EBP、ESP、EBX、EDX、ECX和EAX等弹出栈，它与PUSHAD对称使用即可。</p>
<h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD  Reg/Mem, Reg/Mem/Imm</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：AF、CF、OF、PF、SF和ZF</p>
<p>指令的功能是把源操作数的值加到目的操作数中。</p>
<h3 id="带进位加指令ADC-见得较少"><a href="#带进位加指令ADC-见得较少" class="headerlink" title="带进位加指令ADC(见得较少)"></a>带进位加指令ADC(见得较少)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADC  Reg/Mem, Reg/Mem/Imm</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：AF、CF、OF、PF、SF和ZF</p>
<p>指令的功能是把源操作数和进位标志位CF的值(0&#x2F;1)一起加到目的操作数中。</p>
<h3 id="加1指令INC"><a href="#加1指令INC" class="headerlink" title="加1指令INC"></a>加1指令INC</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INC  Reg/Mem</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：AF、OF、PF、SF和ZF，不影响CF</p>
<p>指令的功能是把操作数的值加1。</p>
<h3 id="交换加指令XADD-见得较少"><a href="#交换加指令XADD-见得较少" class="headerlink" title="交换加指令XADD(见得较少)"></a>交换加指令XADD(见得较少)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XADD  Reg/Mem, Reg　</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：AF、CF、OF、PF、SF和ZF</p>
<p>指令的功能是先交换两个操作数的值，再进行算术“加”法操作</p>
<h3 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUB  Reg/Mem, Reg/Mem/Imm</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：AF、CF、OF、PF、SF和ZF</p>
<p>指令的功能是从目的操作数中减去源操作数。</p>
<h3 id="带借位减SBB-见得较少"><a href="#带借位减SBB-见得较少" class="headerlink" title="带借位减SBB(见得较少)"></a>带借位减SBB(见得较少)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SBB  Reg/Mem, Reg/Mem/Imm</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：AF、CF、OF、PF、SF和ZF</p>
<p>指令的功能是把源操作数和标志位CF的值从目的操作数中一起减去。</p>
<h3 id="减1指令DEC"><a href="#减1指令DEC" class="headerlink" title="减1指令DEC"></a>减1指令DEC</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEC  Reg/Mem</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：AF、OF、PF、SF和ZF，不影响CF</p>
<p>指令的功能是把操作数的值减去1。</p>
<h3 id="求补指令NEG"><a href="#求补指令NEG" class="headerlink" title="求补指令NEG"></a>求补指令NEG</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEG  Reg/Mem</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：AF、CF、OF、PF、SF和ZF</p>
<p>指令的功能：操作数＝0－操作数，即改变操作数的正负号</p>
<h3 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h3><p>计算机的乘法指令分为无符号乘法指令和有符号乘法指令，它们的唯一区别就在于：数据的最高位是作为“数值”参与运算，还是作为“符号位”参与运算。<br>乘法指令的被乘数都是隐含操作数，乘数在指令中显式地写出来。CPU会根据乘数是8位、16位，还是32位操作数，来自动选用被乘数：AL、AX或EAX。<br>指令的功能是把显式操作数和隐含操作数相乘，并把乘积存入相应的寄存器中。</p>
<h3 id="无符号乘法指令mul-x2F-fmul"><a href="#无符号乘法指令mul-x2F-fmul" class="headerlink" title="无符号乘法指令mul&#x2F;fmul"></a>无符号乘法指令mul&#x2F;fmul</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MUL  Reg/Mem</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：CF和OF(AF、PF、SF和ZF无定义)</p>
<p>指令的功能是把显式操作数和隐含操作数(都作为无符号数)相乘</p>
<h3 id="有符号乘法指令IMUL-x2F-FIMUL"><a href="#有符号乘法指令IMUL-x2F-FIMUL" class="headerlink" title="有符号乘法指令IMUL&#x2F;FIMUL"></a>有符号乘法指令IMUL&#x2F;FIMUL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMUL Reg/Mem </span><br><span class="line"></span><br><span class="line">IMUL Reg, Imm</span><br><span class="line">IMUL Reg, Reg, Imm </span><br><span class="line">IMUL Reg, Reg/Mem</span><br></pre></td></tr></table></figure>

<h3 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h3><p>除法指令的被除数是隐含操作数，除数在指令中显式地写出来。CPU会根据除数是8位、16位，还是32位，来自动选用被除数AX、DX-AX，还是EDX-EAX。</p>
<p>除法指令功能是用显式操作数去除隐含操作数，可得到商和余数。当除数为0，或商超出数据类型所能表示的范围时，系统会自动产生0号中断。</p>
<h3 id="无符号除法指令DIV-x2F-FDIV"><a href="#无符号除法指令DIV-x2F-FDIV" class="headerlink" title="无符号除法指令DIV&#x2F;FDIV"></a>无符号除法指令DIV&#x2F;FDIV</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DIV  Reg/Mem</span><br></pre></td></tr></table></figure>

<p>指令的功能是用显式操作数去除隐含操作数(都作为无符号数)。指令对标志位的影响无定义。</p>
<h3 id="有符号除法指令IDIV-x2F-FIDIV"><a href="#有符号除法指令IDIV-x2F-FIDIV" class="headerlink" title="有符号除法指令IDIV&#x2F;FIDIV"></a>有符号除法指令IDIV&#x2F;FIDIV</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDIV  Reg/Mem</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：AF、CF、OF、PF、SF和ZF</p>
<h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><p>逻辑运算指令是另一组重要的指令，它包括：逻辑与(AND)、逻辑或(OR)、逻辑非(NOT)和异或指令(XOR)，逻辑运算指令也是经常使用的指令。</p>
<h3 id="逻辑与操作指令"><a href="#逻辑与操作指令" class="headerlink" title="逻辑与操作指令"></a>逻辑与操作指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND　Reg/Mem, Reg/Mem/Imm</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：CF(0)、OF(0)、PF、SF和ZF(AF无定义)</p>
<p>指令的功能是把源操作数中的每位二进制与目的操作数中的相应二进制进行逻辑“与操作”，操作结果存入目标操作数中。</p>
<h3 id="逻辑或操作指令OR"><a href="#逻辑或操作指令OR" class="headerlink" title="逻辑或操作指令OR"></a>逻辑或操作指令OR</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OR　Reg/Mem, Reg/Mem/Imm</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：CF(0)、OF(0)、PF、SF和ZF(AF无定义)<br>指令的功能是把源操作数中的每位二进制与目的操作数中的相应二进制进行逻辑”或操作”，操作结果存入目标操作数中。</p>
<h3 id="逻辑非操作指令NOT"><a href="#逻辑非操作指令NOT" class="headerlink" title="逻辑非操作指令NOT"></a>逻辑非操作指令NOT</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NOT　Reg/Mem</span><br></pre></td></tr></table></figure>

<p>其功能是把操作数中的每位变反，即：1←0，0←1。指令的执行不影响任何标志位。</p>
<h3 id="逻辑异或指令XOR"><a href="#逻辑异或指令XOR" class="headerlink" title="逻辑异或指令XOR"></a>逻辑异或指令XOR</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XOR　Reg/Mem, Reg/Mem/Imm</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：CF(0)、OF(0)、PF、SF和ZF(AF无定义)</p>
<p>指令的功能是把源操作数中的每位二进制与目的操作数中的相应二进制进行逻辑”异或操作”，操作结果存入目标操作数中。</p>
<h2 id="检测位指令TEST"><a href="#检测位指令TEST" class="headerlink" title="检测位指令TEST"></a>检测位指令TEST</h2><p>检测位指令是把二个操作数进行逻辑“与”操作，并根据运算结果设置相应的标志位，但并不保存该运算结果，所以，不会改变指令中的操作数。在该指令后，通常用JE、JNE、JZ和JNZ等条件转移指令。</p>
<p>指令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEST  Reg/Mem, Reg/Mem/Imm</span><br></pre></td></tr></table></figure>

<p>受影响的标志位：CF(0)、OF(0)、PF、SF和ZF(AF无定义)</p>
<h2 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h2><p>LOOP　  标号<br>LOOPW　 标号　　　　　 ;CX作为循环计数器<br>LOOPD　 标号　　　　　 ;ECX作为循环计数器</p>
<h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><h3 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h3><p>无条件转移指令包括：JMP、子程序的调用和返回指令、中断的调用和返回指令等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP  标号/Reg/Mem</span><br></pre></td></tr></table></figure>

<h3 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><p>条件转移指令是一组极其重要的转移指令，它根据标志寄存器中的一个(或多个)标志位来决定是否需要转移，这就为实现多功能程序提供了必要的手段。微机的指令系统提供了丰富的条件转移指令来满足各种不同的转移需要，在编程序时，要对它们灵活运用。</p>
<p>条件转移指令又分三大类：基于无符号数的条件转移指令、基于有符号数的条件转移指令和基于特殊算术标志位的条件转移指令。</p>
<h3 id="无符号的条件转移指令"><a href="#无符号的条件转移指令" class="headerlink" title="无符号的条件转移指令"></a>无符号的条件转移指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JE/JZ</span><br><span class="line">ZF=1 Jump Equal or Jump Zero </span><br><span class="line"></span><br><span class="line">JNE/JNZ</span><br><span class="line">ZF=0 Jump Not Equal or Jump Not Zero </span><br><span class="line"></span><br><span class="line">JA/JNBE</span><br><span class="line">CF=0 and ZF=0 Jump Above or Jump Not Below or Equal</span><br><span class="line"></span><br><span class="line">JAE/JNB</span><br><span class="line">CF=0 Jump Above or Equal or Jump Not Below </span><br><span class="line"></span><br><span class="line">JB/JNAE</span><br><span class="line">CF=1 Jump Below or Jump Not Above or Equal</span><br><span class="line"></span><br><span class="line">JBE/JNA</span><br><span class="line">CF=1 or AF=1 Jump Below or Equal or Jump Not Above </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="有符号的条件转移指令"><a href="#有符号的条件转移指令" class="headerlink" title="有符号的条件转移指令"></a>有符号的条件转移指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JE/JZ</span><br><span class="line">ZF=1 Jump Equal or Jump Zero </span><br><span class="line"></span><br><span class="line">JNE/JNZ</span><br><span class="line">ZF=0 Jump Not Equal or Jump Not Zero </span><br><span class="line"></span><br><span class="line">JG/JNLE</span><br><span class="line">ZF=0 and SF=OF Jump Greater or Jump Not Less or Equal </span><br><span class="line"></span><br><span class="line">JGE/JNL</span><br><span class="line">SF=OF Jump Greater or Equal or Jump Not Less </span><br><span class="line"></span><br><span class="line">JL/JNGE</span><br><span class="line">SF≠OF Jump Less or Jump Not Greater or Equal </span><br><span class="line"></span><br><span class="line">JLE/JNG</span><br><span class="line">ZF=1 or SF≠OF Jump Less or Equal or Jump Not Greater </span><br></pre></td></tr></table></figure>

<h3 id="特殊算术标志位的条件转移指令"><a href="#特殊算术标志位的条件转移指令" class="headerlink" title="特殊算术标志位的条件转移指令"></a>特殊算术标志位的条件转移指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JC</span><br><span class="line">CF=1 Jump Carry </span><br><span class="line"></span><br><span class="line">JNC</span><br><span class="line">CF=0 Jump Not Carry</span><br><span class="line"></span><br><span class="line">JO</span><br><span class="line">OF=1 Jump Overflow</span><br><span class="line"></span><br><span class="line">JNO</span><br><span class="line">OF=0 Jump Not Overflow</span><br><span class="line"></span><br><span class="line">JP/JPE</span><br><span class="line">PF=1 Jump Parity or Jump Parity Even</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JNP/JPO</span><br><span class="line">PF=0 Jump Not Parity or Jump Parity Odd </span><br><span class="line"></span><br><span class="line">JS</span><br><span class="line">SF=1 Jump Sign (negative)</span><br><span class="line"></span><br><span class="line">JNS</span><br><span class="line">SF=0 Jump No Sign (positive) </span><br></pre></td></tr></table></figure>

<h2 id="子程序的调用和返回指令"><a href="#子程序的调用和返回指令" class="headerlink" title="子程序的调用和返回指令"></a>子程序的调用和返回指令</h2><p>子程序的调用和返回是一对互逆操作，也是一种特殊的转移操作。</p>
<p>一方面，之所以说是转移，是因为当调用一个子程序时，程序的执行顺序被改变，CPU将转而执行子程序中的指令序列，在这方面，调用子程序的操作含有转移指令的功能，子程序的返回指令的转移特性与此类似；</p>
<p>另一方面，转移指令是一种“一去不复返”的操作，而当子程序完后，还要求CPU能转而执行调用指令之下的指令，它是一种“有去有回”的操作。</p>
<p>为了满足子程序调用和返回操作的特殊性，在指令系统中设置了相应的特定指令。</p>
<h3 id="调用指令（CALL）"><a href="#调用指令（CALL）" class="headerlink" title="调用指令（CALL）"></a>调用指令（CALL）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL　子程序名/Reg/Mem</span><br></pre></td></tr></table></figure>

<p>子程序的调用指令分为近(near)调用和远(far)调用。如果被调用子程序的属性是近的，那么，CALL指令将产生一个近调用，它把该指令之后地址的偏移量(用一个字来表示的)压栈，把被调用子程序入口地址的偏移量送给指令指针寄存器IP即可实现执行程序的转移</p>
<p>如果被调用子程序的属性是远的，那么，CALL指令将产生一个远调用。这时，调用指令不仅要把该指令之后地址的偏移量压进栈，而且也要把段寄存器CS的值压进栈。在此之后，再把被调用子程序入口地址的偏移量和段值分别送给IP和CS，这样完成了子程序的远调用操作</p>
<p>子程序调用指令本身的执行不影响任何标志位，但子程序体中指令的执行会改变标志位，所以，如果希望子程序的执行不能改变调用指令前后的标志位，那么，就要在子程序的开始处保护标志位，在子程序的返回前恢复标志位。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL  DISPLAY</span><br><span class="line"> DISPLAY是子程序名 </span><br><span class="line">CALL  BX</span><br><span class="line"> BX的内容是子程序的偏移量 </span><br><span class="line">CALL  WORD1</span><br><span class="line"> WORD1是内存字变量，其值是子程序的偏移量 </span><br><span class="line">CALL  DWORD1</span><br><span class="line"> DWORD1是双字变量，其值是子程序的偏移量和段值 </span><br><span class="line">CALL  word ptr [BX]</span><br><span class="line"> BX所指内存字单元的值是子程序的偏移量 </span><br><span class="line">CALL  dword ptr [BX]</span><br><span class="line"> BX所指内存双字单元的值是子程序的偏移量和段值 </span><br></pre></td></tr></table></figure>

<h3 id="返回指令（RET）"><a href="#返回指令（RET）" class="headerlink" title="返回指令（RET）"></a>返回指令（RET）</h3><p>当子程序执行完时，需要返回到调用它的程序之中。为实现此功能，指令系统提供了一条专用的返回指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RET/RETN/RETF [Imm]</span><br></pre></td></tr></table></figure>

<p>子程序的返回在功能上是子程序调用的逆操作。为了与子程序的远、近调用相对应，子程序的返回也分：远返回和近返回。返回指令在堆栈操作方面是调用指令的逆过程</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>常见加密算法原理--Base64</title>
    <url>/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/</url>
    <content><![CDATA[<p>常见加密算法原理–Base64</p>
<span id="more"></span>

<h1 id="Base64介绍"><a href="#Base64介绍" class="headerlink" title="Base64介绍"></a>Base64介绍</h1><p><strong>Base64</strong>（基底64）是一种基于64个可打印字符来表示二进制数据的表示方法。由于log264 &#x3D; 6，所以每6个比特为一个单元，对应某个可打印字符。3个字节相当于24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。在Base64中的可打印字符包括字母<code>A-Z</code>、<code>a-z</code>、数字<code>0-9</code>，这样共有62个字符，此外两个可打印符号在不同的系统中而不同</p>
<h1 id="Base64编码原理"><a href="#Base64编码原理" class="headerlink" title="Base64编码原理"></a>Base64编码原理</h1><p><img src="/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/image-20220514115909772.png" alt="image-20220514115909772"></p>
<p>编码时，每 3 个字节一组，共 8bit*3&#x3D;24bit，划分成 4 组，即每 6bit 代表一个编码后的索引值，划分如下图所示：</p>
<p><img src="/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/image-20220514115938457.png" alt="image-20220514115938457"></p>
<p>这样可能不太直观，举个例子就容易理解了。比如我们对 <code>cat</code> 进行编码：</p>
<p><img src="/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/image-20220514120006175.png" alt="image-20220514120006175"></p>
<p>可以看到 <code>cat</code> 编码后变成了 <code>Y2F0</code>。</p>
<p>如果待编码内容的字节数不是 3 的整数倍，那需要进行一些额外的处理。</p>
<p>如果最后剩下 1 个字节，那么将补 4 个 0 位，编码成 2 个 Base64 字符，然后补两个 <code>=</code>：</p>
<p><img src="/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/image-20220514120052354.png" alt="image-20220514120052354"></p>
<p>如果最后剩下 2 个字节，那么将补 2 个 0 位，编码成 3 个 Base64 字符，然后补一个 <code>=</code>：</p>
<p><img src="/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/image-20220514120118423.png" alt="image-20220514120118423"></p>
<p>NDK代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> base64en[] = &#123;</span><br><span class="line">        <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>,  <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>,  <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>,   <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>,  <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;/&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">base64_enc</span><span class="params">(<span class="type">char</span> *data, <span class="type">int</span> len, <span class="type">char</span> *out)</span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> last_c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        c = data[i];</span><br><span class="line">        <span class="comment">//刚好三个字符运算</span></span><br><span class="line">        <span class="keyword">switch</span> (i % <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                (c &gt;&gt; 2) &amp; 0x3f</span></span><br><span class="line"><span class="comment">                1）“&gt;&gt;” 取第一个字节的高六位</span></span><br><span class="line"><span class="comment">                2）“&amp;”  避免其他字符影响 把取得的高六位与0x3f(0011111)按位与</span></span><br><span class="line"><span class="comment">                &amp;按位与运算：只有对应的两个二进位都为1时，结果位才为1</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                out[index++] = base64en[(c &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3f</span> ];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                last_c保存上一个字符</span></span><br><span class="line"><span class="comment">                last_c &amp; 3 取最后两位，清除其他位</span></span><br><span class="line"><span class="comment">                &lt;&lt;4把上一个数的低两位放到第二个数的高两位</span></span><br><span class="line"><span class="comment">                | 或上第二个数的高四位，得到索引值</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                out[index++] = base64en[((last_c &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>) | ((c &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xf</span> )];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                out[index++] = base64en[( ( last_c &amp; <span class="number">0xf</span> ) &lt;&lt; <span class="number">2</span> ) | ((c &gt;&gt; <span class="number">6</span> ) &amp; <span class="number">0x3</span>)];</span><br><span class="line">                out[index++] = base64en[c &amp; <span class="number">0x3f</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        last_c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//补两个等号</span></span><br><span class="line">    <span class="keyword">if</span>(len % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        out[index++] = base64en[(c &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>];</span><br><span class="line">        out[index++] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        out[index++] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//补一个等号</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (len % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">        out[index++] = base64en[( c &amp; <span class="number">0xf</span> ) &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        out[index++] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line"><span class="title function_">Java_com_example_base64_MainActivity_base64_1enc</span><span class="params">(JNIEnv *env, jobject thiz, jstring data)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement base64_enc()</span></span><br><span class="line">    <span class="type">char</span> *c_data = const_cast&lt;<span class="type">char</span> *&gt;(env-&gt;GetStringUTFChars(data, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(c_data);</span><br><span class="line">    <span class="type">char</span> out[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    base64_enc(c_data, len, out);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(data,c_data);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line"><span class="title function_">Java_com_example_base64_MainActivity_stringFromJNI</span><span class="params">(JNIEnv *env, jobject thiz)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement stringFromJNI()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fridaHook</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">base_enc</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> base = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;libbase64.so&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(base)</span><br><span class="line">    <span class="keyword">var</span> func_addr = base.<span class="title function_">add</span>(<span class="number">0x89C</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(func_addr)</span><br><span class="line">    <span class="keyword">var</span> func = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(func_addr,<span class="string">&#x27;void&#x27;</span>,[<span class="string">&#x27;pointer&#x27;</span>,<span class="string">&#x27;int&#x27;</span>,<span class="string">&#x27;pointer&#x27;</span>])</span><br><span class="line">    <span class="keyword">var</span> arg1 = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="title function_">ptr</span>(arg1).<span class="title function_">writeUtf8String</span>(data)</span><br><span class="line">    <span class="keyword">var</span> arg3 = <span class="title class_">Memory</span>.<span class="title function_">alloc</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="title function_">func</span>(arg1,data.<span class="property">length</span>,arg3)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(arg3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/image-20220514142835427.png" alt="image-20220514142835427"></p>
<p><img src="/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/image-20220514142906978.png" alt="image-20220514142906978"></p>
<p>地址计算细节</p>
<p><img src="/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/image-20220514135359242.png" alt="image-20220514135359242"></p>
<p>如果opcode有两个字节的如下，说明是shum指令集地址要加1</p>
<p><img src="/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/image-20220514135442796.png" alt="image-20220514135442796"></p>
<p>如果指令集不对应会报以下错误</p>
<p><img src="/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/image-20220514142309697.png" alt="image-20220514142309697"></p>
<h1 id="左移和右移运算"><a href="#左移和右移运算" class="headerlink" title="左移和右移运算"></a>左移和右移运算</h1><p><img src="/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/image-20220512225743174.png" alt="image-20220512225743174"></p>
<p>在dbg中进行实践，给寄存器eax赋值0x8，然后左移两位，给eax重新赋值再右移两位</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>二级制</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td>1000</td>
<td>原数</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
<td>右移两位</td>
</tr>
<tr>
<td>32</td>
<td>100000</td>
<td>左移两位</td>
</tr>
</tbody></table>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x8</span>;</span><br><span class="line">    <span class="type">int</span> b =a &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c = a &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b&lt;&lt;<span class="string">&quot;\n&quot;</span> &lt;&lt;c ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/14/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86-Base64/image-20220512230124704.png" alt="image-20220512230124704"></p>
<p>左移n位，指 按2进制的 位 左移n位， （等于 乘 2的n次方），超出最高位的数则丢掉。</p>
<p>右移n位，指 按2进制的 位 右移n位， （等于 除以 2的n次方），低于最低位的数则丢掉。</p>
]]></content>
      <categories>
        <category>常见加密</category>
      </categories>
      <tags>
        <tag>加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title>cmp</title>
    <url>/2022/05/14/cmp/</url>
    <content><![CDATA[<p>CTF-win</p>
<span id="more"></span>

<p><strong>1</strong><br>查看文件为PE文件，直接脱OD调试，全局搜索字符串<br><img src="/2022/05/14/cmp/81f7720930deac20025cd036e3ad00aa4c40055c0a62bd10bd023b8d3ec49086.png" alt="图 1">  </p>
<p>搜到的结果<br><img src="/2022/05/14/cmp/21a63837f8ed2dca4ffcefe4fac120c9564ae45245ca8b92215811a7fefce0bb.png" alt="图 2">  </p>
<p><strong>2</strong><br>双击<code>%s</code>处，进入相应汇编代码位置，并下段<br><img src="/2022/05/14/cmp/5620e0fcc39596c3c96029be37339b153d25b1b28dcc949e6c1f38f16589bb08.png" alt="图 3">  </p>
<p><strong>3</strong><br>运行，随便输入一个字符串<br><img src="/2022/05/14/cmp/1fa395b7de6ee9684d17417a4235b922d390e21514b8e621ff6148374193cd00.png" alt="图 4">  </p>
<p><strong>4</strong><br>F8单步调试到比较代码处，观察寄存器<br><img src="/2022/05/14/cmp/4708b2db6c83b933cea9c50c7e5f45286220087785e3b428948a0142c865b81b.png" alt="图 5">  </p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>win逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>动、静态链接库</title>
    <url>/2022/05/22/%E5%8A%A8%E3%80%81%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
    <content><![CDATA[<p>库</p>
<span id="more"></span>

<h1 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h1><p>它是Microsoft在windows操作中实现共享函数库概念的一种实现方式。其中windows中 一些作为DLL实现的文件有：</p>
<ul>
<li>系统API模块（.dll）文件：如user32.dll，kernel32.dll</li>
<li>ActiveX控件（.ocx）文件：如widows上的日历控件</li>
<li>控制面板(.cpl)文件：控制面板中的每一项都是一个专用的DLL</li>
<li>设备驱动程序(.drv)文件：如控制打印到打印机的打印机驱动程序</li>
</ul>
<p>动态链接库不用重复编译或链接，一旦装入内存，DLL函数可以被系统中的任何正在运行的应用应用程序软件所使用</p>
<h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>对象库：（object  library）</p>
<p>对象库是一个扩展名为.LIB的文件，这个文件中的代码在运行连接器进行静态链接时被添加到程序的.EXE文件中例如，在Microsoft  Visual C++中，程序通常链接的C运行时对象库是LIBC.LIB。</p>
<p>导入库：（import  library）</p>
<p>导入库是一种特殊形式的对象库文件。如同对象库一样，导入库不包含任何代码。相反，他们只给连接器提供信息，以建立.EXE文件中用于动态链接的重定位表格。微软的编译器中的KFRNEL32.LIB，USER32.LIB及GDI32.LIB文件是Windows函数的导入库如果在程序中调用Rectangle函数，GDI32.LIB会告诉连接器这个函数是在GDI32.DLL动态链接库中。这一信息被存放在.EXE文件中。所以Windows可以在你的程序运行时与GDI32.DLL动态链接库进行动态链接。</p>
<p>对象库和导入库仅在程序开发时被使用，而动态链接库则是在运行时使用。当一个用到动态库的程序运行时，该库必须存在磁盘上。当Windows在运行程序前加载DLL模块的时候，该库文件必须存放在.EXE程序所在的目录下，或在当前目录，windows目录，Windows目录，MS-DOS环境下的PATH字符串中的某一目录下。（系统将按上述顺序来检索目录）</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>VS2019创建项目</p>
<p><img src="/2022/05/22/%E5%8A%A8%E3%80%81%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/image-20220515093744162.png" alt="image-20220515093744162"></p>
<p>使用默认生成的文件直接使用</p>
<p><img src="/2022/05/22/%E5%8A%A8%E3%80%81%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/image-20220515093842095.png" alt="image-20220515093842095"></p>
<p>编译后把生成的dll放到要调用项目的文件夹中，和exe在同一个目录</p>
<p><img src="/2022/05/22/%E5%8A%A8%E3%80%81%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/image-20220515094018496.png" alt="image-20220515094018496"></p>
<p>调用</p>
<p><img src="/2022/05/22/%E5%8A%A8%E3%80%81%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/image-20220515094040008.png" alt="image-20220515094040008"></p>
<p><img src="/2022/05/22/%E5%8A%A8%E3%80%81%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/image-20220515094103407.png" alt="image-20220515094103407"></p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>a，声明导出函数</p>
<ol>
<li>通过使用_declspec(dllexport)，添加到需要导出的函数前，进行声明</li>
</ol>
<p>（ extern “C” _declspec(dllexport) 调用约定 返回类型 函数名 (参数列表); ）</p>
<p>b，使用动态链接库</p>
<ol>
<li><p>​	定义函数指针(可有可无),如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef int (__stdcall *lpPlus)(int,int);					</span><br><span class="line"></span><br><span class="line">typedef int (__stdcall *lpSub)(int,int);	</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明函数指针变量,如：	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpPlus myPlus;					</span><br><span class="line">lpSub mySub;	</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态加载dll到内存中,如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HINSTANCE   hModule = LoadLibrary(&quot;DllDemo.dll&quot;); </span><br></pre></td></tr></table></figure>
</li>
<li><p>获取函数地址,如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myPlus = (lpPlus)GetProcAddress(hModule,   &quot;Plus&quot;);</span><br><span class="line">mySub = (lpSub)GetProcAddress(hModule,   (char*)0x10);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用函数,如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = myPlus(10,2);					</span><br><span class="line">int b = mySub(10,2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放动态链接库,如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FreeLibrary(hModule);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>代码示例</p>
<p>dll.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//_declspec(dllexport) DWORD g_nNum;</span></span><br><span class="line"><span class="comment">// 导出一个函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//str.Format(L&quot;fun : g_nNum=%d&quot;, g_nNum);</span></span><br><span class="line">	MessageBox(<span class="number">0</span>, <span class="string">L&quot;fun&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="type">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line">	MessageBox(<span class="number">0</span>, <span class="string">L&quot;fun2&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态（显示）调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*pfnfun)</span><span class="params">()</span>;</span><br><span class="line">	pfnfun fun = nullptr;</span><br><span class="line">	HINSTANCE hModule = LoadLibrary(<span class="string">L&quot;DllInstance.dll&quot;</span>);</span><br><span class="line">	<span class="comment">// 通过dll的句柄,获取保存在dll中的指定函数的地址</span></span><br><span class="line">	fun = (pfnfun)GetProcAddress(hModule, <span class="string">&quot;fun&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fun != nullptr) &#123;</span><br><span class="line">		fun();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="另一种方式导出函数"><a href="#另一种方式导出函数" class="headerlink" title="另一种方式导出函数"></a>另一种方式导出函数</h3><p> 通过模块定义文件<code>.DEF</code>来进行声明，在头文件中添加一个文件后缀名为<code>.def</code>，在其中添加如下格式代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPORTS	</span><br><span class="line">函数名	@编号</span><br><span class="line">函数名	@编号 	NONAME</span><br></pre></td></tr></table></figure>

<p>vs2019添加方法</p>
<p><strong>1</strong></p>
<p><img src="/2022/05/22/%E5%8A%A8%E3%80%81%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/image-20220516214933865.png" alt="image-20220516214933865"></p>
<p><strong>2</strong></p>
<p><img src="/2022/05/22/%E5%8A%A8%E3%80%81%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/image-20220516215003809.png" alt="image-20220516215003809"></p>
<p>注：LIBRARY 后面的名称与项目名一致</p>
<p>使用序号导出的好处:</p>
<ol>
<li>名字是一段程序的精华注释，通过名字可以直接猜测到函数的功能</li>
<li>通过使用序号，可以达到隐藏的目的</li>
</ol>
<h2 id="隐式调用"><a href="#隐式调用" class="headerlink" title="隐式调用"></a>隐式调用</h2><p>这种方法相比显示（动态）调用简单一些，只需要链接到.lib文件并将.dll文件置入你的新项目的路径中去。因此，创建一个新的默认win32控制台项目并添加一个源文件。将你做的dll放入你的新项目相同的目录下  </p>
<p>步骤</p>
<ol>
<li>将 *.dll  *.lib 放到工程目录下面	</li>
<li>将 #pragma comment(lib,”DLL名.lib”) 添加到调用文件中	</li>
<li>加入函数的声明	（可有可无）</li>
</ol>
<p>注意：</p>
<p>extern “C” _declspec(dllexport) 调用约定 返回类型 函数名 (参数列表); </p>
<p>extern “C” _declspec(dllimport) 调用约定 返回类型 函数名 (参数列表); </p>
<h1 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h1><p>静态库是将函数和数据编译进一个二进制文件，通常可以命名为*.lib，编译器在链接过程中，将这些二进制数据复制出来，并与调用库的其他模块数据组合在一起，形成最终的可执行文件，等以后使用这个可执行文件时，就不需要这个静态库的支持了。 </p>
<p>比起静态库的调用，静态库只有一种方法，即对应的隐试链接。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ol>
<li><p><strong>编写静态链接库文件</strong></p>
<ul>
<li><strong>在vs2015中创建新项目，项目类型：Win32 控制台程序-&gt;静态库.</strong></li>
<li><strong>在项目中创建xxxx.h和xxxx.cpp  编写代码 然后构建即可.</strong></li>
</ul>
</li>
<li><p><strong>静态链接库的使用</strong></p>
<ol>
<li><p><strong>将生成的.h与.lib文件复制到项目根目录，然后在代码中引用：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;xxxx.h&quot;</span><br><span class="line">#pragma comment(lib, &quot;xxxx.lib&quot;) </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将xxxx.H与xxxx.LIB文件复制到VS2015安装目录，与库文件放在一起</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Microsoft Visual Studio\VC98\Include(xxxx.h)</span><br><span class="line">C:\Program Files\Microsoft Visual Studio\VC98\Lib(xxxx.lib)</span><br></pre></td></tr></table></figure>

<p><strong>然后在工程-&gt;设置-&gt;连接-&gt;对象&#x2F;库模块中添加xxxx.lib</strong></p>
</li>
<li><p><strong>静态链接库的缺点</strong></p>
<ul>
<li><strong>使用静态链接生成的可执行文件体积较大</strong></li>
<li><strong>包含相同的公共代码，造成浪费</strong></li>
</ul>
</li>
</ol>
</li>
</ol>
<p><strong>名称粉碎</strong></p>
<p>假如想使用C++下导出的函数更具有通用性，需要在函数声明前加上extern  “C”,从而防止C++的名称粉碎机制造成dll文件不能供其他语言调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">					 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH:   使用LoadLibrary调用一次</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_ATTACH:    有线程创建的时候调用一次</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_DETACH:     线程结束调用</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_DETACH:   模块销毁调用</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>回忆录</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
</search>

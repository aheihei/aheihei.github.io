<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APP使用接口获取网图</title>
    <url>/2022/03/14/APP%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%BD%91%E5%9B%BE/</url>
    <content><![CDATA[<p>怎么从网络接口中获取数据，需要用到哪些框架，传哪些参数</p>
<span id="more"></span>

<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="okhttp"><a href="#okhttp" class="headerlink" title="okhttp"></a>okhttp</h2><p>网络请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * param1：请求地址</span></span><br><span class="line"><span class="comment">    * param2: 传输数据类型（此请求是键值对）</span></span><br><span class="line"><span class="comment">    * &#123;&quot;id&quot;:11,&quot;name&quot;:&quot;5bc01a39e7bce75ea7b2fb40&quot;,&quot;classify&quot;:&quot;yzmn&quot;,&quot;smallPic&quot;:</span></span><br><span class="line"><span class="comment">    * param3: 异步请求参数，回调</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(String url, Map&lt;String, String&gt; params, Callback callback)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//form表单形式传数据（其他有json）</span></span><br><span class="line">        FormBody.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormBody</span>.Builder();</span><br><span class="line">        <span class="comment">//遍历数据</span></span><br><span class="line">        <span class="keyword">for</span> (String key : params.keySet())&#123;</span><br><span class="line">            builder.add(key,params.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">FormBody</span> <span class="variable">body</span> <span class="operator">=</span> builder.build();</span><br><span class="line"></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .post(body)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//enqueue异步请求</span></span><br><span class="line">        <span class="comment">//需要callback回调</span></span><br><span class="line">        client.newCall(request).enqueue(callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*请求数据*/</span></span><br><span class="line">        <span class="keyword">if</span> (isLoading)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isLoading = <span class="literal">true</span>;</span><br><span class="line">        Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;classify&quot;</span>,<span class="string">&quot;dmdh&quot;</span>);</span><br><span class="line">        params.put(<span class="string">&quot;pageNum&quot;</span>,page+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        params.put(<span class="string">&quot;limit&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">        OkHttpUtil.post(<span class="string">&quot;http://www.dtasecurity.cn:18080/demo01/getWallpaper&quot;</span>,</span><br><span class="line">                params,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> IOException e)</span> &#123;</span><br><span class="line">                        isLoading = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">responseText</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">                        <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;ResponseEntity&lt;WallPaperEntity&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">                        <span class="comment">//匿名内部类</span></span><br><span class="line">                        ResponseEntity&lt;WallPaperEntity&gt; data = <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(responseText, responseType);</span><br><span class="line">                        wallPaperEntityList.addAll(data.getData());</span><br><span class="line">                        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">                        msg.what = <span class="number">1</span>;</span><br><span class="line">                        handler.sendMessage(msg);</span><br><span class="line">                        isLoading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        page++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h2><p>解析Json</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">responseText</span> <span class="operator">=</span> response.body().string();</span><br><span class="line">                        <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;ResponseEntity&lt;WallPaperEntity&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">                        ResponseEntity&lt;WallPaperEntity&gt; data = <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(responseText, responseType);</span><br><span class="line">                        wallPaperEntityList.addAll(data.getData());</span><br><span class="line">                        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">                        msg.what = <span class="number">1</span>;</span><br><span class="line">                        handler.sendMessage(msg);</span><br><span class="line">                        isLoading = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>Gson解析返回的对象类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.wallpaper.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseEntity</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//请求数据参数</span></span><br><span class="line">    Integer pageNum;</span><br><span class="line">    Boolean hasNext;</span><br><span class="line">    Integer limit;</span><br><span class="line">    String classify;</span><br><span class="line">    String message;</span><br><span class="line">    List&lt;T&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getPageNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPageNum</span><span class="params">(Integer pageNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pageNum = pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">getHasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHasNext</span><span class="params">(Boolean hasNext)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hasNext = hasNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getLimit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLimit</span><span class="params">(Integer limit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClassify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> classify;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassify</span><span class="params">(String classify)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classify = classify;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(List&lt;T&gt; data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h2><p>图像加载框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把从网络上获取的图片放到img_wallpaper</span></span><br><span class="line">       Glide.with(img_wallpaper).load(smallPicUrl).into(img_wallpaper);</span><br></pre></td></tr></table></figure>

<h1 id="项目："><a href="#项目：" class="headerlink" title="项目："></a>项目：</h1><h2 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h2><p>网格试图</p>
<p>属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android:columnWidth：设置列的宽度</span><br><span class="line">android:gravity：组件对其方式</span><br><span class="line">android:horizontalSpacing：水平方向每个单元格的间距</span><br><span class="line">android:verticalSpacing：垂直方向每个单元格的间距</span><br><span class="line">android:numColumns：设置列数</span><br><span class="line">android:stretchMode：设置拉伸模式，可选值如下： none：不拉伸；spacingWidth：拉伸元素间的间隔空隙 columnWidth：仅仅拉伸表格元素自身 spacingWidthUniform：既拉元素间距又拉伸他们之间的间隔空袭</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<p>1, 创建Item的布局：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/img_item_wallpaper&quot;</span></span><br><span class="line">        android:scaleType=<span class="string">&quot;fitXY&quot;</span></span><br><span class="line">        android:padding=<span class="string">&quot;5dp&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;120dp&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;200dp&quot;</span>/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>2, 写entity实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.wallpaper.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WallPaperEntity</span> &#123;</span><br><span class="line">    <span class="comment">//要获取的资源的各种属性</span></span><br><span class="line">    String id;</span><br><span class="line">    String name;</span><br><span class="line">    String smallPic;</span><br><span class="line">    String bigPic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSmallPic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> smallPic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSmallPic</span><span class="params">(String smallPic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smallPic = smallPic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBigPic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bigPic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBigPic</span><span class="params">(String bigPic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bigPic = bigPic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3，MainActivity的布局和Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;GridView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/gv_main&quot;</span></span><br><span class="line">        android:numColumns=<span class="string">&quot;3&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initViews</span><span class="params">()</span> &#123;</span><br><span class="line">        gv_main = findViewById(R.id.gv_main);</span><br><span class="line">        <span class="comment">//初始化adapater</span></span><br><span class="line">        adapter = <span class="keyword">new</span> <span class="title class_">WallpaperAdapter</span>(<span class="built_in">this</span>,wallPaperEntityList);</span><br><span class="line">        <span class="comment">//使用适配器展示图片</span></span><br><span class="line">        gv_main.setAdapter(adapter);</span><br><span class="line">        <span class="comment">//监听是否到底部</span></span><br><span class="line">        gv_main.setOnScrollChangeListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnScrollChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onScrollChange</span><span class="params">(View v, <span class="type">int</span> scrollX, <span class="type">int</span> scrollY, <span class="type">int</span> oldScrollX, <span class="type">int</span> oldScrollY)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (((GridView)v).getLastVisiblePosition() &gt; wallPaperEntityList.size() - <span class="number">6</span>)&#123;</span><br><span class="line">                    getData();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        getData();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>adapater数据适配器，数据想要怎样展示到屏幕上时用，拿到数据后怎么去展示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WallpaperAdapter</span> <span class="keyword">extends</span> <span class="title class_">BaseAdapter</span> &#123;</span><br><span class="line">    <span class="comment">//UI传递消息使用</span></span><br><span class="line">    Context context;</span><br><span class="line">    <span class="comment">//存储数据,解析时可以使用</span></span><br><span class="line">    List&lt;WallPaperEntity&gt;wallPaperEntityList;</span><br><span class="line">    <span class="comment">//添加构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WallpaperAdapter</span><span class="params">(Context context, List&lt;WallPaperEntity&gt; wallPaperEntityList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">        <span class="built_in">this</span>.wallPaperEntityList = wallPaperEntityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//数量</span></span><br><span class="line">        <span class="keyword">return</span> wallPaperEntityList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getItem</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wallPaperEntityList.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getItemId</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="type">int</span> position, View convertView, ViewGroup parent)</span> &#123;</span><br><span class="line">        <span class="comment">// 每拿到一个图片初始化一个</span></span><br><span class="line">        <span class="comment">//初始化xml的view</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">inflate</span> <span class="operator">=</span> View.inflate(context, R.layout.item_wallpaper,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置图片的view</span></span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">img_wallpaper</span> <span class="operator">=</span> inflate.findViewById(R.id.img_item_wallpaper);</span><br><span class="line">        <span class="comment">//设置数据，最后返回就行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">smallPicUrl</span> <span class="operator">=</span> wallPaperEntityList.get(position).getSmallPic();</span><br><span class="line">        <span class="comment">//把从网络上获取的图片放到img_wallpaper</span></span><br><span class="line">        Glide.with(img_wallpaper).load(smallPicUrl).into(img_wallpaper);</span><br><span class="line">        <span class="keyword">return</span> inflate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/14/APP%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E7%BD%91%E5%9B%BE/bTzp1e.md-1647221046750.png" alt="bTzp1e.md"></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>1，怎么从网络上获取</p>
<p>2，怎么在界面上显示</p>
<p>3，显示在界面上过程中怎么处理</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>APP抓包</title>
    <url>/2022/03/14/APP%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/ecd76310d9e45803ce329fb61db870eb.jpg" alt="ecd76310d9e45803ce329fb61db870eb" style="zoom:200%;">

<span id="more"></span>

<p>代理的原理：</p>
<p>它是网络信息的中转站。在我们正常请求一个网站时，是发送了请求给Web服务器，Web服务器把响应传回给我们。如果设置了代理服务器，实际上就是在本机和服务器之间搭建了一个桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发出请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机。这样我们同样可以正常访问网页，但这个过程中Web服务器识别出的真实IP就不再是我们本机的IP了，就成功实现了IP伪装，这就是代理的基本原理。</p>
<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/web_proxy-1647220738454.jpg" alt="web_proxy"></p>
<p><strong>mac地址</strong>：发送端和接收端的地址便是指网卡的地址</p>
<p>每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）</p>
<p><strong>IP地址</strong>：由于mac地址很难记忆，所以又出现了IP地址</p>
<p>身份证（mac地址）和名字（IP地址）</p>
<p><strong>arp协议功能</strong>：广播的方式发送数据包，获取目标主机的mac地址</p>
<p>网络通信流程图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://images2018.cnblogs.com/blog/988061/201809/988061-20180909111944359-1323196399.png</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/988061-20180909111944359-1323196399.png" alt="988061-20180909111944359-1323196399"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://images2018.cnblogs.com/blog/988061/201809/988061-20180909112504683-1737949469.png</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/988061-20180909112504683-1737949469.png" alt="988061-20180909112504683-1737949469"></p>
<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII形式给出；而消息内容则具有一个类似MIME的格式</p>
<h2 id="怎么通信"><a href="#怎么通信" class="headerlink" title="怎么通信"></a>怎么通信</h2><p>HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。请求报文格式如下： </p>
<p>请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体</p>
<p>请求行以方法字段开始，后面分别是URL字段和HTTP协议版本字段，并以CRLF结尾。SP是分隔符。除了在最后的CRLF序列中CF和LF是必需的之外，其他都可以不要。有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。</p>
<p>应答报文格式如下：</p>
<p>状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体</p>
<h1 id="netcat模拟http协议"><a href="#netcat模拟http协议" class="headerlink" title="netcat模拟http协议"></a>netcat模拟http协议</h1><p>Get:</p>
<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220313155434123.png" alt="image-20220313155434123"></p>
<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220313160049200.png" alt="image-20220313160049200"></p>
<p>POST:</p>
<p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220313161517748.png" alt="image-20220313161517748"></p>
<h1 id="telnet模拟http协议"><a href="#telnet模拟http协议" class="headerlink" title="telnet模拟http协议"></a>telnet模拟http协议</h1><p><img src="/2022/03/14/APP%E6%8A%93%E5%8C%85/image-20220313161900522.png" alt="image-20220313161900522"></p>
<h1 id="r0capture的使用"><a href="#r0capture的使用" class="headerlink" title="r0capture的使用"></a>r0capture的使用</h1><p>拉跨</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>抓包原理</tag>
      </tags>
  </entry>
  <entry>
    <title>C++（一）</title>
    <url>/2022/03/25/C-%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>函数重载，默认参数，引用，应用传参，指针和引用的区别，C++的输入输出机制，类的声明、定义和应用，定义对象，this指针，类的构造与析构</p>
<span id="more"></span>

<h2 id="C与C-区别"><a href="#C与C-区别" class="headerlink" title="C与C++区别"></a>C与C++区别</h2><p>C++是C的扩展，C是C++的额子集，C++包括C的全部特征，属性和优点。同时增加了对面向对象编程的完全支持 </p>
<h2 id="关于堆的使用"><a href="#关于堆的使用" class="headerlink" title="关于堆的使用"></a>关于堆的使用</h2><p>C++中申请空间用的是new与delete运算符，这两个类似于c语言中的malloc于free函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new</span><br><span class="line">语法：</span><br><span class="line">        指针变量=new 数据类型；</span><br><span class="line">        指针变量=new 数据类型[长度]；</span><br><span class="line">例如：</span><br><span class="line">        <span class="type">int</span> *p; p=new <span class="type">int</span></span><br><span class="line">        <span class="type">char</span> *pstr=new <span class="type">char</span>[<span class="number">50</span>]; </span><br><span class="line">delete</span><br><span class="line">语法：c</span><br><span class="line">        delete  指针变量；</span><br><span class="line">        delete[] 指针变量；</span><br><span class="line">例如：</span><br><span class="line">        delete  p;</span><br><span class="line">        delete  []  pStr; <span class="comment">//对于数组  </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> using  namespace  <span class="built_in">std</span>;</span><br><span class="line"> <span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> *p = new  <span class="type">int</span>(<span class="number">33</span>);<span class="comment">//分配一个整数空间4字节，圆括号代表初始化值</span></span><br><span class="line">     count&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="type">int</span> * p2=new  <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//分配连续的10个整数空间40字节</span></span><br><span class="line">     delete  p;</span><br><span class="line">     delete[] p2;</span><br><span class="line">     <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针p</p>
<p><img src="/2022/03/25/C-%EF%BC%88%E4%B8%80%EF%BC%89/image-20220325150626060.png" alt="image-20220325150626060"></p>
<p>释放指针p</p>
<p><img src="/2022/03/25/C-%EF%BC%88%E4%B8%80%EF%BC%89/image-20220325150656517.png" alt="image-20220325150656517"></p>
<p>指针p2</p>
<p><img src="/2022/03/25/C-%EF%BC%88%E4%B8%80%EF%BC%89/image-20220325150730671.png" alt="image-20220325150730671"></p>
<ol>
<li>从示例中可以看出使用new申请空间并不是以字节为单位的，而是以数据类型，从而也无需强制转换 </li>
<li>要申请多个数据，需要使用了中括号，释放这块内存的时候也需要中括号 </li>
<li>注意中括号和圆括号的差别，圆括号是初始化，中括号是申请多个的意思</li>
</ol>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>相同的作用域，如果两个函数名称相同，而参数不同，我们把他们称为函数重载，函数重载又称为函数的多态性<br>一下几种方式会构成函数重载</p>
<ul>
<li>形参数量不同 </li>
<li>形参类型不同 </li>
<li>形参的顺序不同 </li>
<li>形参的数量和形参的类型都不同</li>
</ul>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>函数声明或者定义的时候，可以给形参赋一些默认值，调用函数时，若没有给出实参，则按指定的默认值进行工作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">Addition</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b, <span class="type">int</span> c=<span class="number">0</span>,<span class="type">int</span> d=<span class="number">0</span>,<span class="type">int</span> e=<span class="number">0</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span>  a+b+c+d+e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上这个例子中，调用函数的时候，可以传递两个参数，也可以传递三个，四个，五个。传递的参数不足五个的时候，后面的会默认的被传递0. </p>
<p>需要注意的问题 </p>
<ol>
<li>函数没有声明时，在函数定义中指定形参的默认值 </li>
<li>函数即又定义又有声明时，申明指定后，定义后就不能再指定默认值 </li>
<li>当使用了默认参数的同时还使用了重载容易造成二义性 </li>
<li>默认值的定义必须遵守从右到左的顺序，如果某个形参没有默认值，则它左边的参数就不能有默认值 ，函数调用时，实参与形参按从左到右的顺序进行匹配</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用是给一个变量起别名，定义引用的一般格式：<br>类型&amp;引用名&#x3D;变量名<br>int nSize;<br>int &amp;nNum&#x3D;nSize; </p>
<ol>
<li>由于引用就是变量的一个别名，因此上例中nSize的地址与nNum的地址是完全一样的 </li>
<li>定义引用时一定要初始化，指明该引用变量是谁的别名</li>
<li>引用一经初始化不能再引用其他对象 </li>
<li>不能引用常量</li>
</ol>
<h3 id="引用传参"><a href="#引用传参" class="headerlink" title="引用传参"></a>引用传参</h3><p>引用传递方式是再函数定义时在形参前面加上引用运算符“&amp;” </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：int swap(int &amp;nNumA, int &amp;nNumB); </span><br></pre></td></tr></table></figure>

<p>按值传递方式容易理解，但形参值的改变不同对实参产生影响，地址传递通过形参的改变使相应的实参改变<br>引用作为参数对形参的任何操作都能改变相应的实参的数据，又使函数调用显得方便自然</p>
<h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><p>引用访问一个变量是直接访问，而指针里面需要保存变量的地址，所以是间接访问<br>引用是一个变量的别名，本身不单独分配自己的内存空间，它不是一个单独的变量，而指针有自己的内存空间<br>引用一经初始化不能再引用其他变量，而指针可以（非const指针）<br>尽可能使用引用，不得已时使用指针 </p>
<p><strong>三种传参方式比较</strong></p>
<p><strong>值传递：</strong>实参要初始化形参要分配空间，将实参内容拷贝到形参<br><strong>指针传递：</strong>传递的是指针，能够间接修改函数外部的变量，其本质仍是值传递<br><strong>引用传递：</strong>实参初始化形参的时候不分配空间，而是形参融为一体，修改了形参就是改变了实参</p>
<h2 id="作用域符号"><a href="#作用域符号" class="headerlink" title="作用域符号"></a>作用域符号</h2><p>在C++有一个新的符号随处可见，由两个冒号<code>::</code>，它被称之为作用域符号，变量，在解决C++中变量，函数重名等问题，起到了关键的作用</p>
<h2 id="输入输出机制"><a href="#输入输出机制" class="headerlink" title="输入输出机制"></a>输入输出机制</h2><p><code>I/O</code>流是指输入输出的一系列数据流，输出使用插入操作符<code>&lt;&lt;</code>向<code>cout</code>输出流中插入字符<br>在使用<code>cout</code>和<code>cin</code>的时候，需要包含<code>iostream</code>这个头文件，并且使用<code>std</code>这个命名空间<br>输入使用抽取操作符<code>&gt;&gt;</code>从<code>cin</code>输入流中抽取字符</p>
<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>面向对象的三要素</p>
<p>对象，类和继承<br><strong>什么是对象？</strong><br>概念上:在问题空间中，将客观世界的实体称为对象，对象可以是某人，某物<br>实现上:把一系列数据和处理数据的过程(操作或方法)当成一个整体，这个封装体就称为对象<br><strong>什么是类？</strong><br>类是创建对象的样板，它包含着所创建对象的状态描述和方法的定义，对象是由特定的类创造的，某个类所创建的对象也称为这个类的实例<br><strong>什么是继承</strong><br>C++采用继承机制重用，不仅可重用具有特定功能的类，而且继承可以由已有的类创造新的类<br>新类共享已有类的属性，自己还具有额外添加的属性，新类是从已有类派生的，称为派生类或子类，已有类称为父类或基类<br>面向对象的三大特性</p>
<p>封装，继承，多态</p>
<h2 id="类的声明、定义与应用"><a href="#类的声明、定义与应用" class="headerlink" title="类的声明、定义与应用"></a>类的声明、定义与应用</h2><p><strong>类的定义格式</strong></p>
<p>类是对现实世界中的客观事物的抽象，将具有相同属性的一类事物称作类，类的实例称为对象，类是一种复杂的数据类型，它是将不同类型的数据和与这些数据相关的操作封装在一起的集合体，类具有对数据的抽象性，隐藏性和封装性。类对象的行为由类的内部数据结构和相关的操作确定，外部行为通过操作接口实现。 </p>
<p><strong>类定义包括两个部分</strong></p>
<p>说明部分（做什么）<br>数据成员(名称，类型)<br>实现部分（方法）<br>成员函数的定义和实现 </p>
<h3 id="类定义的一般形式"><a href="#类定义的一般形式" class="headerlink" title="类定义的一般形式"></a>类定义的一般形式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  &lt;</span>类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">           公有数据及成员函数</span><br><span class="line">  protected:</span><br><span class="line">           保护数据及成员函数</span><br><span class="line">  private:</span><br><span class="line">            私有数据及成员函数</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现部分</span></span><br><span class="line">&lt;各成员函数的实现&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CLocation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  public:</span><br><span class="line">        <span class="type">void</span>  <span class="title function_">init</span><span class="params">(<span class="type">int</span> nNumA,<span class="type">int</span> nNumB)</span></span><br><span class="line">        &#123;</span><br><span class="line">                  m_X=nNumA;</span><br><span class="line">                  m_Y=nNumB;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">getx</span><span class="params">()</span>&#123;<span class="keyword">return</span>  m_X;&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">gety</span><span class="params">()</span>&#123;<span class="keyword">return</span>  m_Y;&#125;</span><br><span class="line">private:</span><br><span class="line">  <span class="type">int</span>  m_X,m_Y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明如下：</strong> </p>
<p>关键字class表示类<br>CLocation是自定义的类名，一般首字母用大写字母表示，与对象名相区别<br>关键字public,private,protected为访问权限控制符，规定成员的访问权限，他们出现的顺序和次数无限制 </p>
<ul>
<li>公有(public)成员提供了类的接口功能，不仅可以被成员函数访问，而且可以在程序中被访问 </li>
<li>私有(private)成员是被类隐藏的数据，外部无法访问，派生类的函数也无法访问，通常将数据成员定义为私有 成员 </li>
<li>保护(protected)成员外部无法访问，派生类的函数可以访问</li>
</ul>
<h3 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h3><p>对象是类的实例，任何一个对象都是属于某个已知类的，当定义一个类后，在C++编码的角度来看，就产生了一个新的数据类型，之后便可以使用这个数据类型定义新的变量。 </p>
<p>&lt;类名&gt;&lt;对象名表&gt; </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLocation objLocation; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：定义 Location类的对象如下 </span><br><span class="line">CLocation objA,objB,objC[10],*pobjD; </span><br></pre></td></tr></table></figure>

<ol>
<li>objA,objB为两个一般对象 </li>
<li>objC[10]是对象数组 </li>
<li>objD是指向类Location对象的指针 </li>
<li>对象的成员与它所属类成员一样，有数据成员和成员函数，创建对象时，每个对象的数</li>
<li>成员具有不同的存储空间，以存放不同的数据，但成员函数的代码为每个对象所共享</li>
</ol>
<h3 id="对象及成员的引用"><a href="#对象及成员的引用" class="headerlink" title="对象及成员的引用"></a>对象及成员的引用</h3><p>当定义好对象后，我们需要访问对象中的成员，对象访问成员的方法与结构变量访问成员变量的方法相同<br>访问一般对象的成员：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;对象名&gt;.&lt;数据成员名&gt;</span><br><span class="line">&lt;对象名&gt;.&lt;成员函数名&gt;（&lt;参数表&gt;）</span><br></pre></td></tr></table></figure>

<p>访问指向对象的指针的成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;对象指针名&gt;-&gt;&lt;数据成员名&gt;</span><br><span class="line">&lt;对象指针名&gt;-&gt;&lt;成员函数名&gt;(&lt;参数表&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="定义成员函数"><a href="#定义成员函数" class="headerlink" title="定义成员函数"></a>定义成员函数</h3><p>定义类中的成员函数可以采用以下三种方式： </p>
<ol>
<li>成员函数的定义及实现在类体中完成 </li>
<li>成员函数的定义及实现在类体外完成 </li>
<li>成员函数的定义及实现与类体在不同的文件中完成<br>调用成员函数</li>
</ol>
<p>一个对象要表现其行为，就要调用它的成员函数， </p>
<h3 id="用成员访问符调用"><a href="#用成员访问符调用" class="headerlink" title="用成员访问符调用"></a>用成员访问符调用</h3><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数必须使用对象来调用，一个类的所有对象调用的成员函数都是同一个代码段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTdate</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> d, <span class="type">int</span> y)</span>;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> m_Month;</span><br><span class="line">    <span class="type">int</span> m_Day;</span><br><span class="line">    <span class="type">int</span> m_Year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">CTdate::set</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> d, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  m_Month = m;</span><br><span class="line">  m_Day = d;</span><br><span class="line">  m_Year = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>成员函数如何识别m_Month，m_Day和m_Year是属于哪个调用对象呢<br>成员函数有一个隐含的附加形参，即指向该对象的指针，这个隐含的形参叫做this指针，通过this指针保证了每个对象可以拥有不同的数据成员，处理这些成员的代码可以被所有对象共享<br>当对象s调用s.set(2,15,1998)时，实际上传递了4个参数，除了接收传递的3个参数外，还接收到正在调用成员函数的对象s的地址，这个地址放入隐含的形参this指针中。等同于执行this &#x3D; &amp;s语句。所以对成员函数内数据成员的访问都隐含地加上了this指针<br>因此m_Month&#x3D;m;等价于this - &gt; m_Month&#x3D;m; </p>
<p>故而set()函数还可以表示成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">void</span>  <span class="title function_">CTdate::set</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> d,<span class="type">int</span> y)</span></span><br><span class="line"> &#123;</span><br><span class="line">   this - &gt;m_Month=m;</span><br><span class="line">   this - &gt;m_Day = d;</span><br><span class="line">   this -&gt; m_Year = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以无论对应哪个对象调用，成员函数从获得地参数(显示地实参和隐含地对象地址)来判断都不会弄错，可见，编译器设置this指针地作用是使成员函数记住当前访问成员函数地对象，以便于对对象中地数据成员进行访问 </p>
<ol>
<li>一个类对象所占据地内存空间由它地数据成员所占据地 数据空间总和决定 </li>
<li>类地成员函数不占据对象的内存空间</li>
</ol>
<h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><p>类的作用域简称类域，类域的范围是指在类所定义地类体中，该类的成员局部于该类所属的类域，一个类的任何成员都能访问同一类地任一其他成员，对类作用域外地一个类的数据成员和成员函数的访问受程序员编写程序的额控制，当把成员定义为私有和保护时，外界访问被限制，类域可以被包含在文件域中，可见类域小于文件域：而类域中又可包含函数域，可见类域又大于函数域，类域介于文件域和函数域之间</p>
<p>不同存储类的对象具有不同的生命期，对象的生命期是指对象从创建开始到被释放为止的存在时间，即刻对象的寿命，按生命期的不同，对象可分为如下三种(与介绍的变量划分情况相似) <strong>局部对象：</strong>定义在一个函数体内或程序块内，作用域和生命周期都是局部的</p>
<p> <strong>全局对象：</strong>定义在某个文件中，作用域为包含该文件的整个程序，生命期是全局的 </p>
<p><strong>静态对象：</strong>分为内部静态对象和外部静态对象，生命期都是全局的，前者作用域为定义他的函数体和程序块内；后者作用域为定义它的文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">类名允许与其他变量名或函数名同名 </span><br><span class="line"><span class="number">1</span>，如果一个非类型名隐藏了类型名，则类型名通过加前缀<span class="class"><span class="keyword">class</span>访问： </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span>&#123;</span> </span><br><span class="line"><span class="comment">//... </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> Sample)</span> 形参屏蔽了类型名 </span><br><span class="line">&#123; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="title">a</span>;</span> <span class="comment">//类型名前加class </span></span><br><span class="line">Sample++; <span class="comment">//形参自增运算 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="number">2</span>，如果一个类型名隐藏了一个非类型名，则用一般作用域规则访问 </span><br><span class="line"><span class="type">int</span> S=<span class="number">0</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="title">a</span>;</span> <span class="comment">//类S屏蔽了全局变量S定义类对象a </span></span><br><span class="line">::S=<span class="number">3</span>; <span class="comment">//引用全局变量前加作用域 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> g=S ; <span class="comment">//全局变量S给变量g初始化 </span></span><br><span class="line">定义一个类就是实现对创建一个对象的数据结构的描述，在类中，一些成员是保护的，被有效的屏蔽，以防外界的干扰和误操作，另一些成员是公共的，作为接口提供外界使用 </span><br></pre></td></tr></table></figure>

<h2 id="类与结构体的区别"><a href="#类与结构体的区别" class="headerlink" title="类与结构体的区别"></a>类与结构体的区别</h2><p>默认访问区别:<br>类的定义中默认情况下的成员访问级别是private<br>结构体定义中默认情况下的成员访问级别是public<br>初始化的区别：<br>类可以通过构造函数与析构函数初始化数据成员<br>结构体的初始化依靠特定的语法格式</p>
<h2 id="类的构造与析构"><a href="#类的构造与析构" class="headerlink" title="类的构造与析构"></a>类的构造与析构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CDesk</span>&#123;</span>  <span class="comment">//定义一个办公桌类</span></span><br><span class="line">private:</span><br><span class="line">  <span class="type">int</span>  m_high;</span><br><span class="line">  <span class="type">int</span>  m_width;</span><br><span class="line">  <span class="type">int</span>  m_length;</span><br><span class="line">  <span class="type">int</span>  m_weight;</span><br><span class="line">&#125;;</span><br><span class="line">CDesk  g_objDesk;     <span class="comment">//全局对象</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CDesk  objDesk ; <span class="comment">//局部对象</span></span><br><span class="line">  CDesk  *pobjDesk = new CDesk; <span class="comment">//堆对象</span></span><br><span class="line">  delete  pobjDesk;</span><br><span class="line">  <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是特殊的成员函数，函数名和类名完全相同，没有返回值类型，即不能定义构造函数的返回类型，也不能使用void。通常情况下构造函数应声明为公有函数，构造函数被声明为私有有特殊的用途<br>全局对象，局部对象，堆中的对象，只有有对象被创建了，都会自动调用构造函数</p>
<p><strong>构造函数的注意点</strong></p>
<ol>
<li>构造函数是C++提供的一种机制，当对下行被创建的时候会自动调用。构造函数内写什么代码都可以，但是它提供的这种自动调用的机制，是为了方便程序编写者初始化对象 </li>
<li>类体外定义构造函数，其函数名前要加上”类::”，构造函数无返回类型，构造函数不能是虚函数</li>
<li>全局对象的构造函数先于main函数执行 </li>
<li>在定义时，若类的数据成员是另一个类的对象，则在调用构造函数创建对象时，对作为数据成员的对象先要自动调用其自身的构造函数，然后再构造本类的对象</li>
<li>New不仅仅分配了内存还调用了构造函数，这一点从上面的例子也能够看出。值得注意的是，malloc也能分配堆内存，但是无法识别对象，也就无法调用构造函数了</li>
<li>可以有参数，并且可以定义多个构造函数构成重载</li>
</ol>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>除了构造函数，C++还提供了析构函数，析构函数在对象被销毁的时候，会被自动调用，通常来说是用来回收对象内被申请出的资源，比如对象中有一个指针指向堆空间，可以在析构函数中释放掉 </p>
<p><strong>析构函数的特点</strong></p>
<ol>
<li>无返回类型 </li>
<li>无参数 </li>
<li>不能随意调用(是可以调用的)； </li>
<li>不能重载（而构造函数可以有参数，也可以重载） </li>
<li>析构函数与构造函数的功能相对应，所以析构函数名是构造函数名前加一个逻辑反运算符“~”</li>
</ol>
<p>当对象结束其生命期时，比如在函数体内定义的对象，当该函数调用结束时，或局部对象被释放，就调用了析构函数<br>下面情况下需要使用析构函数</p>
<ul>
<li>构造函数打开一个文件，使用完文件时，需要关闭文件 </li>
<li>从堆中分配了动态内存区，在对象消失之前必须释放</li>
</ul>
<p><strong>带参数的构造函数</strong></p>
<p>不带参数的构造函数不能完全满足初始化的要求，因为这样创建的类对象具有相同的初始化值，如果需要对类对象按不同特征初始化不同的值，应采用带参数的构造函数。<br>一个类可以拥有多个构造函数构成重载，这样可以多样化的对对象进行初始化。 </p>
<p><strong>缺省构造函数</strong></p>
<p>C++规定，每一个类必须有一个构造函数，没有构造函数就不能创建任何对象，若未定义一个类的构造函数，则C++提供了一个缺省的构造函数，该缺省构造函数是一个无参数的构造函数，仅仅负责创建对象，而不做任何初始化工作 ，只要一个类定义了一个构造函数，C++就不再提供缺省的构造函数。如还需要无参数构造函数，则必须自己定义，与变量定义类型类似，在用缺省构造函数创建对象时，如果创建的是全局对象或静态对象，则对象成员数据全为0；局部对象创建时，其成员数据是无意义的随机数 </p>
<p>一个类如果什么都没有则被称之为空类，一个空类的大小为1个字节，且编译器会为其隐式产生6个成员，假设有一个空类class Empty，则编译器会为其产生以下几个成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Empty();       <span class="comment">//默认构造函数</span></span><br><span class="line">Empty(<span class="type">const</span>  Empty&amp;);<span class="comment">//默认拷贝构造函数</span></span><br><span class="line">~Empty();    <span class="comment">//默认析构函数</span></span><br><span class="line">Empty&amp; operator=(<span class="type">const</span>  Empty&amp;); <span class="comment">//默认赋值运算符</span></span><br><span class="line">Empty*  opetator&amp;();    <span class="comment">//取地址运算符</span></span><br><span class="line"><span class="type">const</span>  Empty*  operator&amp;()  <span class="type">const</span>;   <span class="comment">//取地址运算符const</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h3><p>构造函数中给变量初始值的时候，实际上都不算初始化，在构造函数初始化列表中初始化才算上是初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CLacation</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">CLocaton(<span class="type">int</span>  nNumA,<span class="type">int</span> nNumB):m_X(nNumA),m_Y(nNumB)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;2个参数的构造函数&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">CLocation(<span class="type">int</span>  nNumA): m_X(nNumA), m_Y(nNumA*<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;1个参数的构造函数&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">getx</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span>  m_X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gety</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  m_Y;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line"> <span class="type">int</span> m_X,m_Y;<span class="comment">//数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> CLocation  <span class="title function_">objA</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>;</span><br><span class="line"> CLocation  <span class="title function_">objB</span><span class="params">(<span class="number">3</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数声明的后面，加上一个冒号，冒号后面就是初始化列表。在初始化列表中，你可以为成员变量初始化，初始化时可以使用一个表达式，表达式可以有形参，也可以没有形参 </p>
<p>在构造函数执行的时候，分为两个阶段： </p>
<p>1，初始化阶段（在分配内存的时候，直接填充数据）<br>2，普通计算阶段（函数体内的程序代码，在这里初始化操作，算是赋值操作） </p>
<p>初始化列表是在第一阶段中，而在构造函数中赋值，就属于第二阶段了，此时也不能称之为初始化，只能算是赋值了 </p>
<ul>
<li>const类型的成员，只能在初始化列表中初始化 </li>
<li>引用类型的成员，只能在初始化列表中初始化 </li>
<li>有参数的对象成员（对象所对应的类没有默认构造函数），也只能在构造函数初始化列表中初始化</li>
</ul>
<p>因为他们都必须在定义的时候就初始化 </p>
<p><strong>总结</strong> </p>
<ol>
<li>推荐初始化放在初始化列表中，包括普通数据成员，对象数据成员 </li>
<li>没有默认构造函数的对象成员的初始化，只能放在构造函数的初始化列表中进行，等到了构造函数体内，已经来不及了 </li>
<li>这一原则也适用于const型成员，引用型成员，都要在初始化列表中初始化 </li>
<li>当有参构造函数，参数全部有默认值，也可以相当于有默认构造函数 </li>
<li>对象成员的构造顺序按照在类中的定义顺序来决定，跟初始化列表中的顺序无关、</li>
</ol>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>在C++中，提供了用一个对象值创建并初始化另一个对象的方法，完成该功能的是 拷贝构造函数（也叫复制构造函数）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;拷贝构造函数名&gt;(&lt;类名&gt;&amp;&lt;引用名&gt;)</span><br><span class="line">&#123; &lt;函数体&gt; &#125;</span><br><span class="line">CLocation::CLocation(CLocation  &amp;obj)</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   public:</span><br><span class="line">      <span class="type">int</span> <span class="title function_">getLength</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">      Line( <span class="type">int</span> len );             <span class="comment">// 简单的构造函数</span></span><br><span class="line">      Line( <span class="type">const</span> Line &amp;obj);      <span class="comment">// 拷贝构造函数</span></span><br><span class="line">      ~Line();                     <span class="comment">// 析构函数</span></span><br><span class="line"> </span><br><span class="line">   private:</span><br><span class="line">      <span class="type">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 为指针分配内存</span></span><br><span class="line">    ptr = new <span class="type">int</span>;</span><br><span class="line">    *ptr = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::Line(<span class="type">const</span> Line &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用拷贝构造函数并为指针 ptr 分配内存&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ptr = new <span class="type">int</span>;</span><br><span class="line">    *ptr = *obj.ptr; <span class="comment">// 拷贝值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Line::~Line(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;释放内存&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    delete ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Line::getLength</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(Line obj)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;line 大小 : &quot;</span> &lt;&lt; obj.getLength() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   Line <span class="title function_">line</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line"> </span><br><span class="line">   display(line);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中&lt;拷贝构造函数名&gt;与该类名相同 ,如果一个类中没有定义拷贝构造函数，则系统自动生成一个缺省拷贝构造函数，其功能是将已知对象的所有数据成员的值拷贝给对应对象的数据成员 </p>
<p><strong>拷贝构造函数的特点</strong></p>
<ul>
<li>拷贝构造函数名字与类同名，没有返回类型 </li>
<li>拷贝构造函数只有一个形参数，该参数是该类的对象的引用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CLocation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    CLocation(CLocation&amp; obj) <span class="comment">//拷贝构造</span></span><br><span class="line">        :m_X(obj.m_X), m_Y(obj.m_Y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CLocation(<span class="type">int</span>  nX, <span class="type">int</span>  nY)<span class="comment">//普通带参构造</span></span><br><span class="line">        :m_X(nX), m_Y(nY)</span><br><span class="line">      </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;普通构造&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span>  m_X, m_Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    CLocation  <span class="title function_">objA</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>;</span><br><span class="line">    CLocation  <span class="title function_">objB</span><span class="params">(objA)</span>; <span class="comment">//此时调用的是拷贝构造函数</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/25/C-%EF%BC%88%E4%B8%80%EF%BC%89/image-20220325172828862.png" alt="image-20220325172828862"></p>
<p>拷贝构造函数除了用于使用已知对象的值创建一个同类的新对象外，还有两个主要用处 </p>
<ol>
<li>把对象作为实参数进行函数调用时，系统自动调用拷贝构造函数实现把对象值传递给形参 </li>
<li>当函数的返回值为对象时，系统自动调用拷贝函数对返回对象值创建一个临时对象，然后再将这个临时对象值赋给接收函数返回值的对象</li>
</ol>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2>]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>C</title>
    <url>/2022/03/15/C/</url>
    <content><![CDATA[<img src="/2022/03/15/C/images1.jpg" alt="images1" style="zoom:200%;">

<span id="more"></span>

<h1 id="计算机中的数据"><a href="#计算机中的数据" class="headerlink" title="计算机中的数据"></a>计算机中的数据</h1><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><p>逢16进1，每一位都是16的整数次幂（基数16），符号：“H”</p>
<h2 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h2><p>逢10进1</p>
<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>逢2进1，每一位都是2的整数次幂(基数2) ，符号：“B” </p>
<h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><p>逢8进1，每一位都是8的整数次幂(基数是8) ，符号：”O” </p>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><p>逆序取余</p>
<p>二进制数得到每一位就是十进制数每次除以2得到余数，最后把所有的余数倒着排列，就得到二进制数 </p>
<p>10的二进制</p>
<p>10除以2得5余0</p>
<p>5除以2得2余1</p>
<p>2除以2得1余0</p>
<p>1除以2得0余1</p>
<p>整数10的二进制就是1010</p>
<h3 id="八进制转十六进制"><a href="#八进制转十六进制" class="headerlink" title="八进制转十六进制"></a>八进制转十六进制</h3><p>方法：</p>
<p>以二进制位中介，即先将八进制数按照一位拆三位的方法转换为二进制，在对这个二进制数使用四位合一位的方法转换为十六进制</p>
<p>规则：</p>
<p>整数部分从低位向高位每3位用一个等值的八进制来替换，不足3位时在高位补0凑满3位<br>小数部分从高位向低位每3位用一个等值八进制数来替换，不足3位时在低位补0凑满3位 </p>
<p>十进制：16</p>
<p>八进制：20</p>
<p>二进制：010 000</p>
<p>十六进制：10</p>
<h2 id="计算机中存储单位"><a href="#计算机中存储单位" class="headerlink" title="计算机中存储单位"></a>计算机中存储单位</h2><p>位是计算机中数据最小单位，它表示一个二进制数，0或者1，英文是Bit </p>
<p>字长是CPU的主要技术指标之一，指的是一次最大能并行处理的二进制位数</p>
<p>Byte 表示字节，一个字节是8位<br>word是两个字节，也就是16位<br>dword是四个字节，也就是32位</p>
<h2 id="源码反码补码关系"><a href="#源码反码补码关系" class="headerlink" title="源码反码补码关系"></a>源码反码补码关系</h2><p><strong>正数：</strong></p>
<p>​	三码合一 </p>
<p><strong>负数：</strong><br>    原码：最高位不变，后面数据和其绝对值相同<br>    反码：将源码除最高位，其余安位取反<br>    补码：将反码+1 </p>
<p><strong>例如：</strong><br>1 010 1010 （原）<br>1 101 0101 （反码：符号位不变，其他位按位取反）<br>1 101 0110 （补码:反码+1）<br>在计算机中保存的都是补码，使用补码的目的是将减法运算转换为加法运算</p>
<h1 id="C基础"><a href="#C基础" class="headerlink" title="C基础"></a>C基础</h1><p>一个程序包含哪些东西</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include //编译预处理命令 </span><br><span class="line">#include //编译预处理命令 </span><br><span class="line">int main(void) //程序启动函数 </span><br><span class="line">&#123; //函数开始标志 </span><br><span class="line">	printf(&quot;Hello world&quot;); //库函数输出信息 </span><br><span class="line">	system(&quot;pause&quot;); //让程序暂停一下 </span><br><span class="line">	return 0； //函数退出返回0 </span><br><span class="line">&#125; //程序结束标志</span><br></pre></td></tr></table></figure>

<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>1，编写好源代码<br>2，编译前，进行预处理<br>3，进行编译，生成obj文件<br>4，进行连接，生成可执行文件<br>5，生成目标程序，即可以运行<br>其中，预处理，编译，连接可以使用VS一键完成，也就是只要你写好了源代码，直接可以生成能够执行的程了。</p>
<p>（main 函数 ，预处理 ，库函数 ，关键字，注释）</p>
<p><strong>VS中的默认main函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int  _tmain(int argc, _TCHAR*  argv[])</span><br><span class="line">&#123;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>预处理</strong></p>
<p>以#号开头的命令(通常称为指令)，他是在程序编译之前进行的处理，通常会对文件做一些复制，替换等操作</p>
<p><strong>为什么要使用#includ</strong> </p>
<p>对于本程序而言#include的作用是包含stdio函数库，包含了函数库头文件之后，就可以使用其中的函数。<br><code>#include</code>有两种形式<br>1)#include “文件名” 在当前工程目录中会找到该头文件<br>2)#include &lt;文件名&gt; 在vs自带的头文件夹中去找该头文件</p>
<p><strong>库函数</strong></p>
<p>C语言已经写好的代码，直接提供给开发者使用，提供的代码就叫做库函数，使用相应的库函数，必须要先包含相应的头文件</p>
<p><strong>关键字</strong></p>
<p>被赋予了某些特殊含义的单词，不能用于其他任何目的，所有的关键字小写，C语言中的关键字32个</p>
<p><img src="/2022/03/15/C/image-20220315163741780.png" alt="image-20220315163741780"></p>
<h2 id="数据类型及变量"><a href="#数据类型及变量" class="headerlink" title="数据类型及变量"></a>数据类型及变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>整型，就是整数</li>
<li>浮点型，就是小数 </li>
<li>字符型，就是文本符号</li>
</ul>
<h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><p><strong>常量</strong><br>常量就是固定不变的数据，根据类型有以下四种:<br>1、整形常量<br>所有整数（正整数，负整数，零）<br>2、浮点型常量<br>所有小数。<br>3、字符常量<br>普通字符，用单引号括起来的一个字符(不包括单引号本身)如：’A’，’1‘.<br>4、字符串常量<br>用双引号括起来的若干个字符串（不包括双引号本身）如：“hello world”</p>
<p><strong>变量</strong> </p>
<p>变量就是一块有名字的内存空间，我们可以通过变量的名字来为其背后的内存空间填充数据，或者使用内存空间中的数据</p>
<p>定义变量<br>变量类型 变量名 &#x3D; 初始值</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int num =10;</span><br><span class="line">  num=200;</span><br><span class="line">  printf(&quot;%d&quot;,num+100);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int 是整数型，num就是变量名，10就是变量的初始值，变量可以被修改，也可以参与运算。当变量被定义之后，自动就开辟出了空间，变量名就代表这片空间了 ，可以通过VS的自动窗口，局部变量窗口，监视窗口动态的查看变量的值</p>
<p><strong>变量类型</strong></p>
<p>整数：int short long<br>小数：float double<br>字符：char wchar_t<br>另外还有一个关键字：unsigned可以修饰整数和字符，可以表示无符号数（就是正数）</p>
<h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a><strong>字符类型</strong></h2><p>字符类型本质上说，也是数字。有一个美国国家标准协会指定了一个标准，用0<del>127之间的数字代表不同的字符。所以每一个字符都和一个数字一一对应。美国人制定的这个标准称之为ASCII ，一个字节能表示0</del>255，所以存储一个普通的英文符只需要一个字节，故而char也就是1个字节大小， wchar就是用来存储复杂字符的，而且他是两个字节，共有65536个状态。 </p>
<p>定义char型字符变量，直接使用char即可，赋值的但字符需要用’ ‘括起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char  ch  = &#x27;A&#x27;</span><br></pre></td></tr></table></figure>

<p>定义wchar_t型字符变量，直接使用wchar_t，需要注意的是字符要用这种格式L’ ‘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wchar_t   ch  = L&#x27;A&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="标识符的命名规则"><a href="#标识符的命名规则" class="headerlink" title="标识符的命名规则"></a>标识符的命名规则</h2><p>1，只能由字母（A<del>Z，a</del>z)，数字(0~9),下划线(_)组成<br>2，数字不能开头<br>3，不可以使用关键字<br>4，C语言中的标识符区分大小写 </p>
<p><strong>字符型与数字</strong></p>
<p>字符型与整数类型没有本质的区别，都表示数字，只是，字符类型所能表示的数字被人为设计与不同的字符一一对应，所以字符类型的变量也可以用于数学计算，只是它表示的数据范围有限。有符号的情况下<br>(char -128<del>127,wchar_t -32768</del>32767) </p>
<p><strong>字符串</strong></p>
<p>C语言中还有一种类型叫做字符串常量，但是没有一个变量能够存储字符串常量，需要借助于字符数组或指针<br>字符串的表示方式：使用双引号扩起来<br>列如:char szCh[]&#x3D;”adsfgh23435” </p>
<p><strong>标识符</strong></p>
<p>编程的时候，有许多需要命名的对象，比如函数名，变量名等，这些名称叫做标识符 </p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>匈牙利命名法的变量名由一个或多个小写字母开始，这些字母由助于记忆变量的类型和用途，紧跟着的就是程序员 选择的任何名称，而在最前面加入前缀m_,s_,g_表示变量的作用域类型<br>匈牙利命名法的目标是便于记忆，而且使变量名清晰易懂，（一看变量名就知道他是什么类型，知道是干什么用的），增强了代码的可读性，方便程序员之间相互交流代码</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Windows</tag>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++（二）</title>
    <url>/2022/03/28/C-%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>派生与继承，多态性与虚函数，模板，STL的基本使用，静态成员</p>
<span id="more"></span>

<h2 id="派生与继承"><a href="#派生与继承" class="headerlink" title="派生与继承"></a>派生与继承</h2><p><strong>继承的优势</strong></p>
<ol>
<li>继承是使用已经编写好的类来创建新类，新的类具有原有类的所有属性和操作，也可以在原有类的基础上作一些修改和增补 </li>
<li>新类称为派生类或子类，原有类称为基类或父类 </li>
<li>派生类是基类的具体化，一般来说派生类比基类的表示范围小的多</li>
</ol>
<p><strong>C++的继承支持单继承和多继承</strong> </p>
<ul>
<li>单继承：派生类只有一个直接基类的继承方式 </li>
<li>多继承：派生类有多个直接基类的继承方式</li>
</ul>
<p>单继承的基本格式如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  &lt;</span>派生类名&gt;:&lt;继承方式&gt;&lt;基类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//&lt;派生类新成员的定义&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，派生类名就是派生类的名字，并且派生类是按指定的继承方式派生的，继承方式有： </p>
<ul>
<li>public 公有继承 </li>
<li>private 私有继承 </li>
<li>protected 保护继承<br>  多继承的定义方式和单继承差不多</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;</span>派生类名&gt;:&lt;继承方式&gt;&lt;基类名<span class="number">1</span>&gt;，&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;，...</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//派生类新成员定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多继承派生类有多个基类，基类名之间用逗号分隔，每个基类名前都应有一个该基类的继承方式说明，假如不写继承方式的话，默认的继承方式为私有继承</p>
<h3 id="派生类的继承方式"><a href="#派生类的继承方式" class="headerlink" title="派生类的继承方式"></a>派生类的继承方式</h3><p>类的继承方式有三种： </p>
<ul>
<li>公有继承(public)：基类中的每个成员在派生类中保持同样的访问权限 </li>
<li>私有继承(private)：基类中的每个成员在派生类中都是private成员，而且他们不能再被派生的子类所访问 </li>
<li>保护继承(protexted)：基类中的Public成员和protected成员在派生类中都是Protected成员，private成员在派生类中仍为private成员</li>
</ul>
<blockquote>
<p>不管是什么继承方式，派生类的成员函数和友元函数都可以访问基类中的公有成员和保护成员，但不能访问私有成员<br>在公有继承时，派生类的对象只能访问公有成员，在保护继承和私有继承时，派生类的对象不能访问基类中任何成员</p>
</blockquote>
<p><img src="/2022/03/28/C-%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220328190742096.png" alt="image-20220328190742096"></p>
<h3 id="接口继承与实现继承"><a href="#接口继承与实现继承" class="headerlink" title="接口继承与实现继承"></a>接口继承与实现继承</h3><p><strong>公有继承</strong>，基类的公有成员函数在派生类中仍然是公有的，换句话说是基类的接口称为了派生类的接口，因而将它称为接口继承<br><strong>实现继承</strong>，对于私有，保护继承，派生类不继承基类的接口，派生类将不再支持基类的公有接口，它希望能重用基类的实现而已，因而将它称为实现继承 </p>
<p><strong>总结</strong></p>
<p>公有继承使得父类的接口继承传承到子类，子类可以继续往孙子类派生，保护继承使得父类的接口全部失效，只能在内部调用，依然可以往孙子类派生，私有继承使得父类所有接口也是只能在内部调用，但是不能往孙子类派生了，私有继承阻断了爷爷类和孙子类间的联系 </p>
<h3 id="派生类的构造、析构函数"><a href="#派生类的构造、析构函数" class="headerlink" title="派生类的构造、析构函数"></a>派生类的构造、析构函数</h3><p>基类的构造函数不被继承，派生类中需要声明自己的构造函数，声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化要调用基类的构造函数完成。假如基类构造函数没有缺省的构造函数，派生类的构造函数需要给基类的构造函数传递参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;派生类名&gt;(&lt;总参数表&gt;)</span><br><span class="line">:&lt;基类构造函数名&gt;(&lt;参数<span class="number">1</span>&gt;),&lt;子对象名&gt;(&lt;参数表<span class="number">2</span>&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//&lt;派生类中数据成员的初始化&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>正常情况下，如果基类构造是无参构造函数，那么会自动去调用，而不用派生类构造显示调用，如果基类没有无参数构造函数，那么派生类必须显示调用基类的构造函数 </p>
</blockquote>
<p>假如同时有父类，又有类对象的数据成员的时候，构造函数的调用顺序</p>
<ol>
<li>基类构造函数 </li>
<li>数据成员的构造函数 </li>
<li>派生类构造函数</li>
</ol>
<p>执行派生类的析构函数时，也要调用基类及子类的析构函数，同时析构函数的调用顺序与构造函数是相反的。</p>
<ol>
<li>先调用派生类的析构函数 </li>
<li>数据成员的析构函数 </li>
<li>基类的析构函数</li>
</ol>
<h2 id="类的成员重定义"><a href="#类的成员重定义" class="headerlink" title="类的成员重定义"></a>类的成员重定义</h2><p>重定义是子类需要修改或扩展基类的某个成员的功能时需要利用的机制，可以分为两种 </p>
<ol>
<li><p>对基类的数据成员的重定义 </p>
</li>
<li><p>对基类成员函数的重定义</p>
<ul>
<li>与基类完全相同 </li>
<li>与基类成员函数名相同，参数不同</li>
</ul>
</li>
<li><p>对于基类与派生类重定义的数据成员。派生类对象调用的时候，应该是派生类的数据成员，也就是说数据成员重定义的时候隐藏了基类的数据成员 </p>
</li>
<li><p>对于与基类完全相同的成员函数，会隐藏基类的成员函数，调用的时候，调用的是派生类的成员函数 </p>
</li>
<li><p>对于与基类成员函数函数名相同，参数不同的成员函数，还是会隐藏基类的成员函数，这一点要注意 </p>
</li>
<li><p>注意在不同的作用域中定义的成员函数名相同，参数不同，这不叫重载，这叫重定义，重载说的是在相同作用域中的现象，也就是在一个类中定义的函数</p>
</li>
</ol>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p><strong>单重继承：</strong>一个派生类最多只能有一个基类<br><strong>多重继承：</strong>一个派生类可以有多个基类，如果派生类有两个或两个以上的直接基类，称为多继承 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  &lt;</span>派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//派生类的类体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CClassC</span>:</span>publlic  CClassB,privatee  CClassA</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多继承派生类的构造函数格式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;派生类名&gt;(&lt;总参数表&gt;)</span><br><span class="line">:&lt;基类名<span class="number">1</span>&gt;(&lt;参数表<span class="number">1</span>&gt;),&lt;基类名<span class="number">2</span>&gt;(&lt;参数表<span class="number">2</span>&gt;),&lt;子对象名<span class="number">3</span>&gt;(&lt;参数<span class="number">3</span>&gt;),....</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//派生类构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">CClassC(<span class="type">int</span> nNum)</span><br><span class="line">:CClassB(nNum),CClassA(nNum),m_nNum(<span class="number">15</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行顺序：先执行所有基类的构造函数，再执行派生类本身的构造函数，包含子对象在内</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">classA</span><br><span class="line">&#123;&#125;</span><br><span class="line">classB</span><br><span class="line">&#123;&#125;</span><br><span class="line">classC</span><br><span class="line">&#123;&#125;</span><br><span class="line">classD:public A,public B,public C</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>首先要顺序执行类A，类B和类C的构造函数，再执行派生类D本身的构造函数</p>
<h3 id="多继承中的二义性问题"><a href="#多继承中的二义性问题" class="headerlink" title="多继承中的二义性问题"></a>多继承中的二义性问题</h3><p>一般的，派生类成员的访问是唯一的，但是在多继承的情况下，可能出现派生类对其类成员访问的不唯一性，即二义性。<br><strong>虚基类</strong></p>
<p>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性–采用虚基类来解决</p>
<p>虚基类的引入：用于有共同基类的场合<br>虚基类(virtual base class)说明格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">virtual  &lt;继承方式&gt;&lt;基类名&gt;</span><br><span class="line">virtual  public  CClassA</span><br></pre></td></tr></table></figure>

<p>作用 </p>
<p>主要用于解决多继承时可能发生的对同一基类继承多次而产生的二义性问题<br>为最远的派生类提供唯一的基类成员，而不重复产生多个数据<br>如果一个派生类有多个直接基类，而这些直接基类又有一个共同的基类，则在最终的派生类中会保留该间接共同基类数据成员的多份同名成员，C++提供虚基类的方法，使得在继承间接共同基类时只保留一份成员 </p>
<p>总结</p>
<p>C++支持类继承机制，继承是面向对想想的重要概念之一，派生类的成员函数和友元函数可以访问基类的所有公有和保护的数据成员和成员函数<br>派生类对象只能访问基类的公有成员和成员函数，多重继承是一个类从多个基类派生而来的机制，派生类实际上获取了所有基类的特性<br>当一个类是两个或多个基类的派生类时，必须在派生类名和冒号之后，列出所有基类的类名，基类间用逗号隔开，派生类的构造函数必须激活所有基类的构造函数，并把相应的参数传递给它们<br>派生类可以是另一个类的基类，这样，相当于形成了一个继承链，当派生类的构造函数被激活时，它的所有基类的构造函数也会被激活，为解决多继承中的二义性问题，引进虚基类的概念，其目的是使公共基类在其派生对象中只产生一个基类子对象</p>
<h3 id="多态性与虚函数"><a href="#多态性与虚函数" class="headerlink" title="多态性与虚函数"></a>多态性与虚函数</h3><p>多态性是指对不同类的对象发出相同的消息将会有不同的行为，消息主要是指对类的成员函数的调用，不同的行为是指不同的实现 </p>
<p>**C++中实现多态有以下多种方式： **</p>
<ul>
<li>函数重载 </li>
<li>运算符重载 </li>
<li>模板 </li>
<li>虚函数 </li>
<li>子类型</li>
</ul>
<p>在继承关系中，若类B是类A以公有继承形式产生的派生类，则类B包含了父类A的行为，并且它本身还可具有新的行为，可称类B是类A的一个子类型 </p>
<h3 id="静态连编与动态联编"><a href="#静态连编与动态联编" class="headerlink" title="静态连编与动态联编"></a>静态连编与动态联编</h3><p>联编是指程序自身彼此关联的过程，按照联编所进行的阶段不同，可分为静态联编和动态联编，静态联编是指在程序编译连接阶段进行联编，也称为早期联编。这种联编工作由于在程序运行之前完成，所调用的函数与执行该函数的代码之间的关系已确定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CBase</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">   <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;CBase:fun&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyClass</span>:</span>public  CBase&#123;</span><br><span class="line">public:</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;CMyClass:fun&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CBase *p;</span><br><span class="line">  CBase  objA;</span><br><span class="line">  CMyClass  objB;</span><br><span class="line">  p = &amp;objA; p-&gt;fun();</span><br><span class="line">  p = &amp;objB; p-&gt;fun();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指向基类的指针p,在此程序运行前，p-&gt;fun()已确定为访问基类的成员函数fun()，所以不管p指向基类，还是派生类的对象，p-&gt;fun()都是基类绑定的成员函数，结果都相同，这就是静态联编的结果<br>动态联编是指在程序运行时进行的联编，也称晚期联编，动态联编要求在运行时解决程序中的函数调用与执行该函数代码间的关系</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数的概念：在基类中冠以关键字virtual的成员函数 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">virtual  &lt;类型说明符&gt;&lt;函数名&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">virtual  <span class="type">void</span> <span class="title function_">fun_a</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//&lt;函数体&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明： </p>
<ol>
<li>如果一个函数在基类中被声明为虚函数，则他在所有派生类中都是虚函数 </li>
<li>只有通过基类指针或引用调用虚函数才能引发动态绑定 </li>
<li>虚函数不能声明为静态，也不能是友元函数 </li>
<li>基类中的虚函数，在派生类中即使没有指定virtual关键字，它也是虚函数 </li>
<li>如果某个类中的一个成员函数被说明为虚函数，该成员函数可能在派生类中存在着不同的实现版本 </li>
<li>由于存在有虚函数，编译器将进行动态联编，使调用虚函数的对象在运行时确定，以实现动态联编的多态性</li>
</ol>
<p>特性：</p>
<p>当一个父类指针指向子类对象的时候，调用一个虚函数，将调用子类的虚函数</p>
<h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><p>纯需函数提供了基类指针指向派生类对象，调用的是派生类的虚函数这一特性，这就使得我们以一致的观点来看待不同的派生类对象，在运行时刻才确定函数的入口。 </p>
<p>但是思考一个问题，如果基类的接口使无法实现的怎么办？比如：<br>形状有一个求面积的函数，原型与矩形继承自形状类，那么圆形与矩形知道怎么算出面积。但是下形状是无法求得面积的，因为形状是一个抽象的概念，这个情况就用到了纯虚函数<br>包含纯虚函数的类就是抽象类，这样的类也不能实例化，纯虚函数是一种特殊的虚函数，是一种没有具体实现的虚函数，其定义格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">virtual</span> &lt;函数名&gt; &lt;函数名&gt;(&lt;参数表&gt;)=<span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> CClassA</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">virtual</span>  &lt;函数名&gt; &lt;函数名&gt;(&lt;参数表&gt;)=<span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做，这就是纯虚函数的作用 </p>
<p>一个类中如果定义了纯虚函数，则这个类就会变成抽象类，C++规定抽象类类型将不能再定义对象 </p>
<p>注意： </p>
<ul>
<li>抽象类只能作为基类来使用 </li>
<li>不能声明抽象类的对象 </li>
<li>构造函数不能是虚函数，析构函数可以是虚函数 </li>
<li>抽象类不能用于直接创建对象实例，可以声明抽象类的指针和引用 </li>
<li>可使用指向抽象类的指针支持运行时多态性 </li>
<li>派生类中必须实现基类中的纯虚函数，否则它仍将被看作一个抽象类</li>
</ul>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>构造函数不能说明为虚函数，而析构函数可以说明为虚函数，其方法是在析构函数前加上关键字virtual说明符，如果一个基类的析构函数被说明为虚函数，则其派生类中的析构函数，可省略virtual说明符</p>
<p><strong>为什么要将析构函数声明为虚函数</strong></p>
<p>基类指针指向子类对象，是多态中常见的做法，那么delete基类指针去释放空间，也会经常出现，但是delete基类指针只会调用父类的析构函数，子类的析构函数不会被调用，这样就有可能会出现内存泄漏<br>基类的析构函数为虚函数，且派生类有自定义析构函数实现时，delete基类指针时会同时调用派生类的析构函数，派生类析构的时候，会自动调用基类的析构函数</p>
<h3 id="重载、重定义与重写"><a href="#重载、重定义与重写" class="headerlink" title="重载、重定义与重写"></a>重载、重定义与重写</h3><p><img src="/2022/03/28/C-%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220329102929322.png" alt="image-20220329102929322"></p>
<p>成员函数被重载的特征： </p>
<ol>
<li>相同的范围(在同一个类中) </li>
<li>函数名字相同 </li>
<li>参数不同 </li>
<li>virtual关键字可有可无</li>
</ol>
<p>重写是指派生类函数覆盖基类函数，特征是： </p>
<ol>
<li>不同的范围（分别位于派生类与基类） </li>
<li>函数名字相同 </li>
<li>参数相同 </li>
<li>基类函数必须有virtual关键字</li>
</ol>
<p>重定义（派生类与基类） </p>
<ol>
<li>不同的范围（分别位于派生类与基类） </li>
<li>函数名与参数都相同，无virtual关键字 </li>
<li>函数名相同，参数不同，virtual可有可无</li>
</ol>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板是一种工具模板可以使程序员能建立具有通用类型的函数库和类库模板也是C++语言支持参数多态性的工具<br>C++语言的程序结构主要是由函数和类构成的，模板具有两种不同的形势<br>A:函数模板<br>B:类模板</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>考察两个swap()函数，一个交换整形数，一个交换浮点数，尽管函数的功能一样，仅处理数据类型不同，但对有强数据类型校验的C++语言，必须使用函数重载，分别编写代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>                                   <span class="type">void</span>  <span class="title function_">swap</span><span class="params">(<span class="type">float</span>  &amp;a,<span class="type">float</span> &amp;b)</span></span><br><span class="line">&#123;                                                                         &#123;</span><br><span class="line">  <span class="type">int</span>  temp=a;                                                                <span class="type">float</span>  temp=a;</span><br><span class="line">  a=b;                                                                            a=b;</span><br><span class="line">  b=temp;                                                                      b=temp;</span><br><span class="line">&#125;                                                                          &#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数的参数个数，实现代码是相同的，只有形参的类型不同，如果将两个函数中的int 和float进行参数化，使用参数T替代，则交换任何一对数据类型的变量(包括类对象)可以定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Template&lt;T&gt;</span><br><span class="line"><span class="type">void</span>  <span class="title function_">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span><br><span class="line">&#123;</span><br><span class="line">   T  temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上述定义，对任一类型T的两个变量或类对象(x1,x2)，函数调用swap(x1,x2)编译器都能理解并执行函数模板所确定的功能<br>函数模板提供了具有处理相同功能的一类函数的抽象，它以任意类型T为参数，其定义形式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;参数化类型名表&gt;</span><br><span class="line">&lt;返回类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//&lt;函数体&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>  &lt;<span class="keyword">typename</span>  T_TYPE&gt;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">fun</span><span class="params">(T_TYPE  NumA,T_TYPE  NumB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，template是定义函数模板啊的关键字，&lt;参数化类型名表&gt;可以包括基本数据类型，也可以包含类类型<br>如果是类类型，则需加关键字class，例如： template </p>
<p>函数模板是对一组函数的描述，它不是一个实实在在的函数，表示每次它能单独处理在类型形式参数中说明的数据类型，编译器不会为其产生任何执行代码<br>当编译器发现有函数调用：函数名（实参数)，当实参数与函数模板形参数相匹配时，则产生一个重载函数。该重载函数与函数模板实现功能相同（函数体定义相同），该重载函数称为模板函数<br>函数模板是模板的定义，不是一个函数，定义中使用通用的类型参数<br>模板函数是用函数模板实例化的函数，它是一个实实在在的函数定义，它由编译器遇到模板函数调用时所生成，具有可执行的程序代码</p>
<h3 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h3><p>模板的特化也可以理解为实例化，模板的特化分为隐式实例化与显示实例化 </p>
<p>特化的目的是为了适应模板在实例化时会产生的一些特殊情况，模板的特化分为普通特化与偏特化，他们的特点分别如下： </p>
<p>普通特化：将此模板的所有替换类型的某一种类型进行特别处理<br>偏特化：将此模板的所有替身类型的某一种类型的某几项进行特别处理</p>
<h3 id="函数重载模板"><a href="#函数重载模板" class="headerlink" title="函数重载模板"></a>函数重载模板</h3><p>重载方法约定： </p>
<ol>
<li>查找参数完全匹配的函数； </li>
<li>查找函数模板，实例化产生一个匹配的模板函数 </li>
<li>通过类型转化可产生参数匹配的函数</li>
</ol>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>考虑定义一个一维数组的情况，不管数组元素是什么类型数据的类。数组类在所有类型数据上进行的基本操作都是相同的(如插入，删除，检索等)，链表情况也是如此。可以定义节点为不同类型数据的类，但链表类在所有类型数据上进行的基本操作也是i相同的。<br>如果要对功能相同，类的实现没有变化，仅类的数据类型不同的各种情况，都要重新定义一种新的类型，将带来较大的重复。为解决这一问题，可以引进类模板的概念。即将数组种的元素和链表中的节点的数据类型用一个通用参数T来替代 </p>
<p>类模板的定义格式为： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">templete &lt;模板参数表&gt; </span><br><span class="line"><span class="keyword">class</span> &lt;类名&gt; </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//类体说明 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其中templete是关键字，&lt;模板参数表&gt;中可以有多个参数，其间用逗号分隔<br>类模板是为具有相同特性的一组类，定义的一种模式，它说明单个类怎样建立，这与类型声明说明单个对象是怎样建立类似，用模板是参数数生成的类称为模板类，模板类可以生成对象 </p>
<p>总结</p>
<p>模板是一种安全的，搞笑的重用代码方式，它使用通用的参数化类型，在创建对象或函数时所传递的实参类型可以改变其行为，函数模板和类模板经实例化后，可生成具有不同类型的模板函数和模板类，尽管处理数据的类型不同，但其功能和实现是相同的 </p>
<p>每个模板类的实例是一个实际的对象，可以像其他类的对象一样使用<br>在C++中的一个发展趋势是使用标准模板类库(STL)，将其作为编译器的一部分，STL是一个基于模板的包容类库，包括向量，链表和队列，还包括一些通用的排序和查找算法等。STL为用户提供了那些需要重复编码的程序代码，提高了变成的效率。</p>
<h2 id="STL的基本使用"><a href="#STL的基本使用" class="headerlink" title="STL的基本使用"></a>STL的基本使用</h2><p>STL &#x3D; Staandard Template Library，标准模板库，它是由惠普实验室开发的一系列标准化的组件，目前是C++的一部i分。<br>STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内</p>
<h3 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h3><p>string类型支持长度可变的字符串，C++标准模板库将负责管理与存储字符相关的内存，以及提供各种有用的操作，<br>使用string需要包含它的头文件，并且using它 </p>
<p>string的构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1:   <span class="comment">//默认构造函数，s1为空串</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span>:   //将s2初始化为s1的一个副本</span></span><br><span class="line"><span class="function">string s3(<span class="string">&quot;value&quot;</span>):   //将s3初始化为一个字符串字面值副本</span></span><br><span class="line"><span class="function">string s4(n,<span class="string">&#x27;c&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string  s1;</span><br><span class="line">  <span class="function">string  <span class="title">s2</span><span class="params">(<span class="string">&quot;asdfgg&quot;</span>)</span></span>;</span><br><span class="line">  cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">  <span class="function">string  <span class="title">s4</span><span class="params">(<span class="string">&quot;abcdefg&quot;</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  cout&lt;&lt;s4&lt;&lt;endl;</span><br><span class="line">  <span class="function">string  <span class="title">s5</span><span class="params">(s2,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">  cout&lt;&lt;s5&lt;&lt;endl;</span><br><span class="line">  string::iterator first = s2.<span class="built_in">begin</span>() +<span class="number">1</span>; <span class="comment">//迭代器</span></span><br><span class="line">  string::iterator last = s2.<span class="built_in">begin</span>()+<span class="number">5</span>;  <span class="comment">//迭代器</span></span><br><span class="line">  <span class="function">string <span class="title">s6</span><span class="params">(first,last)</span></span>;</span><br><span class="line">  cout&lt;&lt;s6&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中出现了迭代器，迭代器是一种类似于指针的东西，目前暂可这么理解，他是用来指代容器中的某一个元素的，最常见的用法是遍历容器中的每一个元素 </p>
<p>常用的成员函数</p>
<p><img src="/2022/03/28/C-%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220329110632733.png" alt="image-20220329110632733"></p>
<h3 id="vector类"><a href="#vector类" class="headerlink" title="vector类"></a>vector类</h3><p>vector是动态数组，并且由于它是模板技术实现的，它支持任意类型 </p>
<p>vector的常用函数</p>
<p><img src="/2022/03/28/C-%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220329110812151.png" alt="image-20220329110812151"></p>
<p>vector的强大在于它支持很多的运算符，在数组中想要整体赋值愿望就这么被它实现了，并且它还是一个会无限扩张的数组。（前提是你的元素都是push_back添加进去的）<br>vector也是支持迭代器的，可以用于遍历vector中的每一个元素</p>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>全局对象是实现数据共享的一种方法，由于它处处可见，因此不够安全，应尽量在程序中少用全局对象，实现类的多个对象之间的数据共享，可使用静态成员<br>静态成员包括静态数据和静态成员函数，友元函数也是一种普通的C++函数，但是它可以访问类的保护或私有成员，方便编程，提高了效率，同时也破坏了类的封装性<br>在一个类中，若将一个数据说明为static，则该数据称为静态数据，它告诉编译器无论建立多个该类的对象，都只有一个静态数据的拷贝，这个拷贝被所有类对象共享，静态数据属于类而共享，不属于对象独有，它的值对每个对象都是一样的，对静态数据成员的值的更新，即是对所有对象的该静态数据成员值的更新，静态数据使用关键字static，静态数据成员在类体中说明，在类体外定义，以分配存储空间并初始化</p>
<h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">CCounter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  public:</span><br><span class="line">      <span class="type">void</span>  <span class="title function_">sercount</span><span class="params">(<span class="type">int</span> i)</span> &#123; m_nCount=i&#125;</span><br><span class="line">      <span class="type">void</span>   showcount()  &#123;<span class="built_in">cout</span>&lt;&lt;m_nCount&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">   private:</span><br><span class="line">      <span class="type">static</span>  <span class="type">int</span>  m_nCount;   <span class="comment">//在类体内说明静态数据</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="type">int</span>  CCounter::m_nCount = <span class="number">0</span>; <span class="comment">//在类体外定义静态数据</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  CCounter  objA,objB;</span><br><span class="line">  objA.showcount();</span><br><span class="line">  objB.showcount();</span><br><span class="line">  objA.setcount(<span class="number">15</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态数据成员可应用在以下几个方面：</p>
<ul>
<li>用来保存流动变化的对象个数(如学生人数) </li>
<li>作为一个标志，指示一个特定的动作是否发生 </li>
<li>指向一个链表第一成员或最后一个成员的指针</li>
</ul>
<p>对静态成员函数的访问，在程序中可使用如下方式： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;)； </span><br><span class="line">classA::<span class="built_in">Fun</span>(<span class="number">123</span>,<span class="number">456</span>); </span><br></pre></td></tr></table></figure>

<p>或 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;对象名&gt;.&lt;静态成员函数名&gt;(&lt;参数表&gt;)； </span><br><span class="line">objA.<span class="built_in">Fun</span>(<span class="number">123</span>,<span class="number">456</span>) </span><br></pre></td></tr></table></figure>

<p>静态成员函数只属于一个类，而不属于类中的任何对象<br>静态成员函数的说明和定义与静态数据成员一样，函数实现可在类体内，也可在类体外，与一般成员函数相同<br>在静态成员函数的实现中，可以直接使用静态成员，可以通过对象来使用非静态成员</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>C</title>
    <url>/2022/03/15/C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<img src="/2022/03/15/C%EF%BC%88%E4%B8%80%EF%BC%89/images1.jpg" alt="images1" style="zoom:200%;">

<span id="more"></span>

<h1 id="计算机中的数据"><a href="#计算机中的数据" class="headerlink" title="计算机中的数据"></a>计算机中的数据</h1><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><p>逢16进1，每一位都是16的整数次幂（基数16），符号：“H”</p>
<h2 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h2><p>逢10进1</p>
<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>逢2进1，每一位都是2的整数次幂(基数2) ，符号：“B” </p>
<h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><p>逢8进1，每一位都是8的整数次幂(基数是8) ，符号：”O” </p>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><p>逆序取余</p>
<p>二进制数得到每一位就是十进制数每次除以2得到余数，最后把所有的余数倒着排列，就得到二进制数 </p>
<p>10的二进制</p>
<p>10除以2得5余0</p>
<p>5除以2得2余1</p>
<p>2除以2得1余0</p>
<p>1除以2得0余1</p>
<p>整数10的二进制就是1010</p>
<h3 id="八进制转十六进制"><a href="#八进制转十六进制" class="headerlink" title="八进制转十六进制"></a>八进制转十六进制</h3><p>方法：</p>
<p>以二进制位中介，即先将八进制数按照一位拆三位的方法转换为二进制，在对这个二进制数使用四位合一位的方法转换为十六进制</p>
<p>规则：</p>
<p>整数部分从低位向高位每3位用一个等值的八进制来替换，不足3位时在高位补0凑满3位<br>小数部分从高位向低位每3位用一个等值八进制数来替换，不足3位时在低位补0凑满3位 </p>
<p>十进制：16</p>
<p>八进制：20</p>
<p>二进制：010 000</p>
<p>十六进制：10</p>
<h2 id="计算机中存储单位"><a href="#计算机中存储单位" class="headerlink" title="计算机中存储单位"></a>计算机中存储单位</h2><p>位是计算机中数据最小单位，它表示一个二进制数，0或者1，英文是Bit </p>
<p>字长是CPU的主要技术指标之一，指的是一次最大能并行处理的二进制位数</p>
<p>Byte 表示字节，一个字节是8位<br>word是两个字节，也就是16位<br>dword是四个字节，也就是32位</p>
<h2 id="源码反码补码关系"><a href="#源码反码补码关系" class="headerlink" title="源码反码补码关系"></a>源码反码补码关系</h2><p><strong>正数：</strong></p>
<p>​	三码合一 </p>
<p><strong>负数：</strong><br>    原码：最高位不变，后面数据和其绝对值相同<br>    反码：将源码除最高位，其余安位取反<br>    补码：将反码+1 </p>
<p><strong>例如：</strong><br>1 010 1010 （原）<br>1 101 0101 （反码：符号位不变，其他位按位取反）<br>1 101 0110 （补码:反码+1）<br>在计算机中保存的都是补码，使用补码的目的是将减法运算转换为加法运算</p>
<h1 id="C基础"><a href="#C基础" class="headerlink" title="C基础"></a>C基础</h1><p>一个程序包含哪些东西</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include //编译预处理命令 </span><br><span class="line">#include //编译预处理命令 </span><br><span class="line">int main(void) //程序启动函数 </span><br><span class="line">&#123; //函数开始标志 </span><br><span class="line">	printf(&quot;Hello world&quot;); //库函数输出信息 </span><br><span class="line">	system(&quot;pause&quot;); //让程序暂停一下 </span><br><span class="line">	return 0； //函数退出返回0 </span><br><span class="line">&#125; //程序结束标志</span><br></pre></td></tr></table></figure>

<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>1，编写好源代码<br>2，编译前，进行预处理<br>3，进行编译，生成obj文件<br>4，进行连接，生成可执行文件<br>5，生成目标程序，即可以运行<br>其中，预处理，编译，连接可以使用VS一键完成，也就是只要你写好了源代码，直接可以生成能够执行的程了。</p>
<p>（main 函数 ，预处理 ，库函数 ，关键字，注释）</p>
<p><strong>VS中的默认main函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int  _tmain(int argc, _TCHAR*  argv[])</span><br><span class="line">&#123;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>预处理</strong></p>
<p>以#号开头的命令(通常称为指令)，他是在程序编译之前进行的处理，通常会对文件做一些复制，替换等操作</p>
<p><strong>为什么要使用#includ</strong> </p>
<p>对于本程序而言#include的作用是包含stdio函数库，包含了函数库头文件之后，就可以使用其中的函数。<br><code>#include</code>有两种形式<br>1)#include “文件名” 在当前工程目录中会找到该头文件<br>2)#include &lt;文件名&gt; 在vs自带的头文件夹中去找该头文件</p>
<p><strong>库函数</strong></p>
<p>C语言已经写好的代码，直接提供给开发者使用，提供的代码就叫做库函数，使用相应的库函数，必须要先包含相应的头文件</p>
<p><strong>关键字</strong></p>
<p>被赋予了某些特殊含义的单词，不能用于其他任何目的，所有的关键字小写，C语言中的关键字32个</p>
<p><img src="/2022/03/15/C%EF%BC%88%E4%B8%80%EF%BC%89/image-20220315163741780.png" alt="image-20220315163741780"></p>
<h2 id="数据类型及变量"><a href="#数据类型及变量" class="headerlink" title="数据类型及变量"></a>数据类型及变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>整型，就是整数</li>
<li>浮点型，就是小数 </li>
<li>字符型，就是文本符号</li>
</ul>
<h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><p><strong>常量</strong><br>常量就是固定不变的数据，根据类型有以下四种:<br>1、整形常量<br>所有整数（正整数，负整数，零）<br>2、浮点型常量<br>所有小数。<br>3、字符常量<br>普通字符，用单引号括起来的一个字符(不包括单引号本身)如：’A’，’1‘.<br>4、字符串常量<br>用双引号括起来的若干个字符串（不包括双引号本身）如：“hello world”</p>
<p><strong>变量</strong> </p>
<p>变量就是一块有名字的内存空间，我们可以通过变量的名字来为其背后的内存空间填充数据，或者使用内存空间中的数据</p>
<p>定义变量<br>变量类型 变量名 &#x3D; 初始值</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int num =10;</span><br><span class="line">  num=200;</span><br><span class="line">  printf(&quot;%d&quot;,num+100);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int 是整数型，num就是变量名，10就是变量的初始值，变量可以被修改，也可以参与运算。当变量被定义之后，自动就开辟出了空间，变量名就代表这片空间了 ，可以通过VS的自动窗口，局部变量窗口，监视窗口动态的查看变量的值</p>
<p><strong>变量类型</strong></p>
<p>整数：int short long<br>小数：float double<br>字符：char wchar_t<br>另外还有一个关键字：unsigned可以修饰整数和字符，可以表示无符号数（就是正数）</p>
<h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a><strong>字符类型</strong></h2><p>字符类型本质上说，也是数字。有一个美国国家标准协会指定了一个标准，用0<del>127之间的数字代表不同的字符。所以每一个字符都和一个数字一一对应。美国人制定的这个标准称之为ASCII ，一个字节能表示0</del>255，所以存储一个普通的英文符只需要一个字节，故而char也就是1个字节大小， wchar就是用来存储复杂字符的，而且他是两个字节，共有65536个状态。 </p>
<p>定义char型字符变量，直接使用char即可，赋值的但字符需要用’ ‘括起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char  ch  = &#x27;A&#x27;</span><br></pre></td></tr></table></figure>

<p>定义wchar_t型字符变量，直接使用wchar_t，需要注意的是字符要用这种格式L’ ‘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wchar_t   ch  = L&#x27;A&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="标识符的命名规则"><a href="#标识符的命名规则" class="headerlink" title="标识符的命名规则"></a>标识符的命名规则</h2><p>1，只能由字母（A<del>Z，a</del>z)，数字(0~9),下划线(_)组成<br>2，数字不能开头<br>3，不可以使用关键字<br>4，C语言中的标识符区分大小写 </p>
<p><strong>字符型与数字</strong></p>
<p>字符型与整数类型没有本质的区别，都表示数字，只是，字符类型所能表示的数字被人为设计与不同的字符一一对应，所以字符类型的变量也可以用于数学计算，只是它表示的数据范围有限。有符号的情况下<br>(char -128<del>127,wchar_t -32768</del>32767) </p>
<p><strong>字符串</strong></p>
<p>C语言中还有一种类型叫做字符串常量，但是没有一个变量能够存储字符串常量，需要借助于字符数组或指针<br>字符串的表示方式：使用双引号扩起来<br>列如:char szCh[]&#x3D;”adsfgh23435” </p>
<p><strong>标识符</strong></p>
<p>编程的时候，有许多需要命名的对象，比如函数名，变量名等，这些名称叫做标识符 </p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>匈牙利命名法的变量名由一个或多个小写字母开始，这些字母由助于记忆变量的类型和用途，紧跟着的就是程序员 选择的任何名称，而在最前面加入前缀m_,s_,g_表示变量的作用域类型<br>匈牙利命名法的目标是便于记忆，而且使变量名清晰易懂，（一看变量名就知道他是什么类型，知道是干什么用的），增强了代码的可读性，方便程序员之间相互交流代码</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Windows</tag>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C（二）</title>
    <url>/2022/03/18/C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<img src="/2022/03/18/C%EF%BC%88%E4%BA%8C%EF%BC%89/images.jpg" alt="images" style="zoom: 200%;">

<span id="more"></span>

<p>输入输出函数，运算符，一维数组，二维数组，三大结构（顺序，选择，循环）</p>
<h2 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h2><p>输入输出函数</p>
<p><img src="/2022/03/18/C%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220321100851507.png" alt="image-20220321100851507"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;格式化字符串&quot;，参数列表)</span><br></pre></td></tr></table></figure>

<p><strong>格式化字符串：</strong></p>
<p>实际上就是一个字符串，然后printf会把字符串原封不动的打印到屏幕上，除非遇到格式控制符</p>
<p><strong>参数列表：</strong></p>
<p>参数列表可以传递各种各样的数据，参数和字符串的格式控制符是一一匹配的。参数列表中的参数，可以有任意多个，可以是常量，也可以是变量，但是需要和格式字符串中的控制符匹配上。</p>
<p><strong>printf作用:</strong></p>
<p>把格式字符串原样输出，除非遇到格式控制符，遇到格式控制符的时候，会去参数列表中匹配，把匹配到的参数替换到相应的格式控制符的位置输出出来 </p>
<p>格式控制符：</p>
<p><img src="/2022/03/18/C%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220321101327088.png" alt="image-20220321101327088"></p>
<p>转义字符：</p>
<p><img src="/2022/03/18/C%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220321101351593.png" alt="image-20220321101351593"></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>单目运算符 &#x3D;<br>算术运算符 +，-，*，&#x2F;<br>关系运算符 &lt;,&gt;,&lt;&#x3D;,&gt;&gt;&#x3D;,&#x3D;&#x3D;<br>逻辑运算符 !,!&#x3D;,&amp;&amp;,||<br>位运算符 <del>,&amp;,|,&lt;&lt;,&gt;&gt;&gt;,</del><br>逗号运算符 ，<br>求大小运算符 sizeof<br>sizeof 它能得到某一个数据或者数据类型所占用的内存大小</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li><p>自动类型转换<br>（1）当一个算数表达式中为类型不同的变量时，会进行自动类型转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double </span><br></pre></td></tr></table></figure>

<p>（2）进行赋值运算的时候，会将右值类型自动转换为左值，有可能会丢失数据 </p>
</li>
<li><p>强制类型转换<br>通过使用转换可以将一个表达式强制转换成一种类型<br>括号的优先级最高，逗号的优先级最低</p>
</li>
</ul>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>数据类型： 数组名[数组长度]    int arrTem[11]</p>
<p><strong>说明</strong><br>1，数组名的命名规则和变量名相同，遵循标识符命名规则<br>2，数组名后接一个或多个方括号，用以指定数组的维数(元素个数)<br>3，数组长度只能时常量和常量表达式(大于0)，不能是变量 </p>
<p><strong>使用</strong></p>
<p>数组可以通过下标来访问某一个元素，下标可以使用常量，变量，其他有整数值的表达式。通过下标对每个数组元素的使用和普通变量一样。</p>
<p><strong>数组的初始化</strong></p>
<ol>
<li>整体赋值<br>int ary[5]&#x3D;{1,2,3,4,5}; </li>
<li>部分赋值<br>int ary[5]&#x3D;{1,2,3} &#x2F;&#x2F;还有最后两个元素为0 </li>
<li>不给定数组长度，根据实际数组元素个数分配<br>Int arr[]&#x3D;{1,2,3,4,5,6}; &#x2F;&#x2F;共有6个元素，所以实际分配24个字节空间</li>
</ol>
<p>使用数组的时候，假如不小心下标超过了最大界限会发生什么？这种情况，编译器是不会检查的，称之为数组的越界问题。这种情况会破坏程序的内存，照成程序间接性的不稳定。（就是程序运行可能会出错，有可能不会出错） </p>
<p><strong>字符数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char ary[]=&#123;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;；//正确用法 </span><br><span class="line">char ary2[]=&quot;hello&quot;; //字符数组的特殊用法，可以用一个字符串初始化数组 </span><br></pre></td></tr></table></figure>

<p>在C语言中，字符串是以‘\0’为结尾的，所使用字符串的地方，都是检查字符串结尾的’\0’来判断字符串是不是结束了<br>注意：字符串的结尾是一个’\0’，这个字符的ASC||码是0.而字符‘0’的ASC||码是0x30 </p>
<p><strong>字符数组的输入与输出</strong></p>
<p>数组名就是数组的起始地址，他是一个常量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span>  <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line">  scanf_s(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>,<span class="number">10</span>);会检测输入的数据是不是超过了第三个参数</span><br><span class="line">  <span class="comment">//scanf(&quot;%s&quot;,string);//越界是不会检查的</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,<span class="built_in">string</span>);  <span class="comment">//为什么scanf中的string不用取地址？因为数组名就是首地址， </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于一些字符串的操作函数</strong></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>strlen</td>
<td>求字符串的长度</td>
</tr>
<tr>
<td>strcpy&#x2F;strcpy_s</td>
<td>字符串拷贝函数</td>
</tr>
<tr>
<td>strcmp</td>
<td>比较两个字符串是否一样</td>
</tr>
<tr>
<td>strcat&#x2F;strcat_s</td>
<td>将两个字符串拼接到一起</td>
</tr>
</tbody></table>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><strong>声明方式：</strong><br>类型说明符 数组名【常量表达式1】【常量表达式2】<code>int temp[3][4]</code></p>
<p>二维数组也可以看成是一个一维数组，它的每一个元素又是一个一维数组 </p>
<p><strong>初始化</strong></p>
<p>二维数组和一维数组一样，也可以在声明时对其进行初始化，二维数组的初始化方式比一维数组较为复杂，但都是一维数组初始化方法衍生而来的 </p>
<p>1, 分行给二维数组赋初值 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[2][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;//使用大括号分别把每行标记出来</span><br></pre></td></tr></table></figure>

<p>2，可以将所有数据写在一个花括号内，按数组排列的顺序对各元素赋初始值 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[2][3]=&#123;1,2,3,4,5,6&#125;; </span><br></pre></td></tr></table></figure>

<p>3，可以对部分元素赋初值 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int arr[2][3]=&#123;&#123;1&#125;,&#123;2&#125;,&#123;3&#125;&#125;; //分行方式初始化 </span><br><span class="line">int arr[2][3]=&#123;1,2,3&#125; //整体方式初始化 </span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<p>分行方式：至少每行都有值，不足的补0<br>整体方式：将第一行赋值完后，再赋值后面的内容，有可能该部分值只给了第一行，后面的值都默认为0 </p>
<p>4，如果对全部元素都赋初值（即提供全部初始数据），则定义数组时对第一维的长度可以不指定，但第二维的长度不能省 </p>
<p><strong>引用</strong></p>
<p>数组名【下标】【下标】<br>1，下标可以是普通的数值<br>2，下标可以是整形表达式<br><code>arrTem[2-1][2*2-1]</code>;&#x2F;&#x2F;无论什么表达式，只要满足结果大于0 </p>
<p><strong>使用</strong></p>
<p>数组元素使用的时候和普通变量一样，可以出现在表达式中，也可以被赋值 </p>
<p><strong>说明：</strong> </p>
<ol>
<li>二维数组可被看作是一种特殊的一维数组，它的元素又是一个一维数组 </li>
<li>二维数组中元素排列的顺序是按行存放的，即在内存中先顺序存放完第一行的元素后，再存放第二行的元素</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">打印杨辉三角</span><br><span class="line">思路</span><br><span class="line">说明：杨辉三角的边都为<span class="number">1</span></span><br><span class="line">中间的每一个值是它对应的左上角和正上方值之和</span><br><span class="line"><span class="number">1</span>，定义一个<span class="number">10</span>*<span class="number">10</span>的二维数组，将斜面和每一行中第一个元素赋值为<span class="number">1</span>；</span><br><span class="line"><span class="number">2</span>，其他元素根据<span class="number">1</span>中定义的值做加法得到</span><br><span class="line">例：<span class="type">int</span>  arrTem[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        arrTem[<span class="number">2</span>][<span class="number">1</span>]=arrTem[<span class="number">1</span>][<span class="number">0</span>]+arrTem[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>  arrTem[<span class="number">10</span>][<span class="number">10</span>]=&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">   &#123;</span><br><span class="line">           <span class="keyword">if</span>((j==<span class="number">0</span>)||(j==i))</span><br><span class="line">         &#123;</span><br><span class="line">              arrTem[i][j]=<span class="number">1</span>;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,arrTem[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">                  <span class="comment">//每一个值是它对应的左上角的值和正上方值之和</span></span><br><span class="line">              arrTem[i][j]=arrTem[i<span class="number">-1</span>][j<span class="number">-1</span>]+arrTem[i<span class="number">-1</span>][j];</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,arrTem[i][j]);</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/18/C%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220321111001724.png" alt="image-20220321111001724"></p>
<h2 id="三大结构"><a href="#三大结构" class="headerlink" title="三大结构"></a>三大结构</h2><p>顺序结构：顺序结构就是从上到下，一条一条语句的执行 </p>
<p>选择结构：是当满足一定条件的时候，执行某一段语句，满足条件或者不满足条件用真假来描述 </p>
<p>循环结构相比于选择结构，也是满足一定的条件，就执行某一些语句，不同的是 ，它执行完之后， 还会再回来，判断条件满足不满足，又要执行一遍语句序列 </p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>表示</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>当且仅当两个运算量的值都为‘真’时，运算结果为‘真’，否则为‘假’</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>当且仅当两个运算量的值都为“假”时，运算结果为“假”，否则为“真”</td>
</tr>
<tr>
<td>！</td>
<td>非</td>
<td>当运算量的值为“真”时，运算结果为“假”，当运算量的值为“假”时，运算结果</td>
</tr>
</tbody></table>
<p>与位运算符的区别：</p>
<p>（1）逻辑运算符用if条件或者循环条件判断，得到的是1或者0两个逻辑结果<br>（2）位运算是属于两个操作数转换位二进制之后，针对于特定位的操作，得到的是一个数字</p>
<p>运算顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!a&amp;&amp;b||x&gt;y&amp;&amp;c</span><br></pre></td></tr></table></figure>

<p>按以下的优先次序:<br>（1）！（非）-&gt;&amp;&amp;（与）-&gt;||（或），即”！“为三者中最高的<br>（2）逻辑运算符中的”&amp;&amp;“和”||“低于关系运算符，”！“高于算术运算符</p>
<p>在逻辑表达式中，并不是两边的表达式都被执行，只是在必须执行下一个表达式时才能求出表达式的解</p>
<p>“&amp;&amp;”与”| |”均为短路运算符<br>“&amp;&amp;”当确认左边表达式为假，则不再判断右边的表达式<br>“||”当确认左边表达式为真，则不再判断右边的表达式</p>
<h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>基本形式 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if--else （else条件为假时执行）</span><br><span class="line">if--else if </span><br><span class="line">switch-case</span><br></pre></td></tr></table></figure>

<p><strong>switch - case语句的一般形式为：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>()&#123;</span><br><span class="line">        <span class="keyword">case</span> 常量<span class="number">1</span>：</span><br><span class="line">            语句序列；</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> 常量<span class="number">2</span>：</span><br><span class="line">            语句序列；</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">default</span>:</span><br><span class="line">        	语句序列；</span><br><span class="line">            <span class="keyword">break</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>switch说明</strong></p>
<ol>
<li><p>switch后面括号内的表达式 的值与某一个case后面的常量表达式的值相等时，就执行此case后面的语句，如所有的case中的 常量表达式的值都没有与表达式的值匹配的，就执行default后面的语句 </p>
</li>
<li><p>每一个case的常量表达式的值必须互不相同，否则就会出现相互矛盾的现象 </p>
</li>
<li><p>各个case和default的出现次序不影响执行结果 </p>
</li>
<li><p>执行完一个case后面的语句后，流程控制转义到下一个case继续执行 </p>
</li>
<li><p>break语句使得执行完case语句后跳出switch语句。如果没有break语句，程序将与下一个case语句匹配， 直到遇到Break为止 </p>
</li>
<li><p>多个case可以共用一组执行语句 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">        <span class="keyword">case</span> 常量<span class="number">1</span>：</span><br><span class="line">        <span class="keyword">case</span> 常量<span class="number">2</span>：</span><br><span class="line">            语句序列：</span><br><span class="line">            <span class="keyword">break</span>；</span><br><span class="line">        defasult:</span><br><span class="line">        	语句序列：</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>在使用case进行语句时，不要忘记case的条件只能是常量或者常量表达式‘</p>
</li>
</ol>
<p><strong>if–else语句的优缺点</strong><br>（1）使用if结构可以实现较为复杂的逻辑判断<br>（2）用switch结构能够实现的结构，使用if结构都可以实现<br>（3）分支较少的情况使用if结构更简单<br>（4）分支较多的情况下使用if结构会使 此程序结构变得复杂<br>（5）如果if嵌套层次过深，也容易使程序结构变得复杂<br><strong>switch语句的优缺点</strong><br>（1）没有复杂的逻辑判断，程序结构简单<br>（2）对于分支很多的情况，特别适合用switch结构<br>（3）switch结构只能基于一个整数值进行分支选择<br>（4）switch只能判断是否相等，不能判断在某一区间的值<br>（5）虽然使用switch语句编写的程序有规律，可读性强，但是由于switch语句不能根据表达式的取值范围做出选 择，所以使用时也有很大的局限性</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while语句的一般形式</span><br><span class="line">while(表达式)             //while循环头</span><br><span class="line"> &#123;</span><br><span class="line">   语句                   //while循环体</span><br><span class="line"> &#125;</span><br><span class="line">执行过程：</span><br><span class="line"> （1）判断表达式的真假，求出表达式</span><br><span class="line"> （2）如果表达式的值不为0（真），则执行语句，然后程序转至步骤(1)，再次求出表达式的值；如果表达式为0，while循环语句结束</span><br></pre></td></tr></table></figure>

<h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line"> //循环体语句</span><br><span class="line">&#125;while(表达式);</span><br><span class="line">注：在使用do--while语句时，条件要放在while关键字的括号内，其后必须加上分号</span><br></pre></td></tr></table></figure>

<p>先执行循环体，在判断循环控制条件，循环体至少也要执行一次</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for语句可以分为两部分，即for循环头和for循环体</p>
<p>for 循环头由关键字for和包含在一个括号内由分号隔开的3个表达式组成 ，循环体可以是一条语句，也可以是包含在大括号内的复合语句。<br>关于for的三个表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for循环的三个语句的执行顺序</span><br><span class="line">  for(printf(&quot;我是语句1\n&quot;);printf(&quot;我是语句2\n&quot;);printf(&quot;我是语句3\n&quot;));</span><br><span class="line">   &#123; </span><br><span class="line">             printf(&quot;我是循环体&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li><p>表达式的省略问题</p>
<p>for语句的一般形式中的“表达式1”可以省略，此时应在for语句之前给循环变量赋初值<br>如果表达式2省略，即不判断循环条件，循环无终止地进行下去<br>表达式3也可以省略，但此时程序设计者应另外设法保证循环能正常结束<br>可以省略表达式1和表达式3，只有表达式2，即只给循环条件</p>
</li>
<li><p>表达式的填写问题</p>
<p>表达式1可以是设置循环变量初值得赋值表达式，也可以是与循环变量无关的其他表达式<br>表达式2一般是关系表达式或逻辑表达式，但也可以是任意表达式，只要其值为非零，就执行循环体<br>表达式3一般是修改循环变量的语句，但也可以是任意表达式</p>
</li>
</ol>
<h4 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h4><p><strong>break</strong><br>         break语句在switch-case语句中是跳出，break语句在循环中还有另外一种用法<br>         当循环中遇到break语句时，立即结束循环，跳到循环体外，执行循环结构后面的语句<br><strong>continue</strong><br>         对于continue来说，作用是跳过本次循环<br>continue与break多与if连用</p>
<p><strong>打印九九乘法表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdafx.h&gt;</span></span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%d&quot;</span>,j,i,j*i);</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>C（三）</title>
    <url>/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/veer-354426716.webp" alt="veer-354426716" style="zoom: 200%;">

<span id="more"></span>

<p>函数，预处理，指针，结构体和联合体，类型定义，堆内存，文件处理</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>什么是函数</strong> </p>
<p>（1）函数就是被定义的有特定功能的一小段独立程序。函数也被称为方法<br>（2）函数是C语言的基本构成单位<br>（3）函数都是平等的，没有谁等级更高一些这种说法，只有main()稍微特殊一些</p>
<p><strong>函数划分</strong></p>
<p>（1）标准C定义的标准库函数<br>符合标准的C编译器必须提供这些函数，函数的行为也要符合标准C的定义<br>（2）第三方库函数<br>由其它厂自行开发的C语言函数库，不在标准范围内，能扩充C语言的功能<br>（3）自定义函数<br>自己编写的函数包装后，也可成为函数库，供别人使用</p>
<p><strong>函数定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数的定义规则：</span><br><span class="line">返回值类型   函数名（参数类型   形式参数名1，参数类型  形式参数名2，···）</span><br><span class="line">&#123;</span><br><span class="line">  函数语句</span><br><span class="line">  return  返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ol>
<li>返回值类型：函数调用表达式的值类型，需和return之后的数据类型一致，假如函数没有返回值，则可以写 void </li>
<li>参数类型：形式参数的数据类型，调用函数的时候，可以给函数传递的数据类型。 </li>
<li>形式参数名：接到外部数据的变量，可以在函数内部直接使用，假如没有参数的话，写一个void即可 </li>
<li>return语句：有两个作用，第一个是用于结束函数，第二个是将返回值传递出函数。<br>注：假如函数中没有写return,则函数在最后一个}时结束 </li>
<li>返回值，就是函数会返回给调用者的一个数据。假如返回值类型时void的，那么就不用写返回值了，有没有 返回值这都是由设计者决定的</li>
</ol>
<p>实现一个函数，主要考虑的就是三个问题 </p>
<ul>
<li>你定义这个函数的主要功能是什么 </li>
<li>你实现这个函数的功能，需要外部给你传递什么参数？ </li>
<li>如何让调用者，得到最终的结果？</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><ol>
<li>函数语句<br>把函数调用作为一个语句，这时不要求函数带返回值，只要求函数完成一定的操作 </li>
<li>函数表达式<br>函数出现在一个表达式中，这种表达式称为函数表达式，这时要求函数带回一个确定的值以参加表达式的运算 </li>
<li>函数参数<br>函数嗲用作为一个函数的实参</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>，当定义在调用之前时，调用者不需要申明即可调用</span><br><span class="line"><span class="type">int</span>  <span class="title function_">print_message</span><span class="params">(<span class="type">int</span>  nNumb,<span class="type">int</span>  nNumA)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>  <span class="title function_">print_message_a</span><span class="params">(<span class="type">int</span>  nNumb,<span class="type">int</span>  nNumA)</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="type">int</span>  nTem=nNumb;</span><br><span class="line">    nNumb=nNumA;</span><br><span class="line">     nNumA=nTem;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">int</span>  nNumb=<span class="number">12</span>，nNumA=<span class="number">10</span>;</span><br><span class="line">  <span class="comment">//1,当定义在调用之前时，调用者不需要申明即可调用</span></span><br><span class="line">  print_message_a(nNumb,nNumA);</span><br><span class="line">  <span class="comment">//2,当函数定义在调用之后时，需要先声明函数声明必须要与该函数定义完全相同</span></span><br><span class="line">  <span class="comment">//(返回值，参数类型，参数个数)最后以分号结束</span></span><br><span class="line">  <span class="type">int</span>  <span class="title function_">FUN</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> b,<span class="type">int</span> c)</span>;</span><br><span class="line">  <span class="comment">//可以没有变量的名字，但是必须要有类型：int  FUN(int,int,int);</span></span><br><span class="line">  <span class="comment">//调用函数:</span></span><br><span class="line"> FUN(<span class="number">1</span>,print_message_a(nNumb,nNumA),<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span>  <span class="title function_">FUN</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> b, <span class="type">int</span> c)</span>;</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数调用注意事项：<br>在一个函数中调用另一个函数需要具备的条件如下</p>
<ol>
<li>首先被调用的函数必须是已经存在的函数(是库函数或用户自己定义的函数)。</li>
<li>如果使用库函数，还应该在本文件开头用#include命令将调用有关库函数时所需用到的信息”包含”到本文件中去</li>
<li>如果使用用户自己定义的函数，而该函数的位置在调用它的函数(即主调函数)的后面(同一个文件中，应该在主调函数中对被调用的函数作声明)</li>
<li>即使没有实现该函数，但有声明，在写的时候没有错误，但在编译时会出现错误(无法解析XXX外部符号)</li>
<li>将函数作为另一个函数的参数时该函数的返回值必须要和当前函数形参类型一致</li>
</ol>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>通过函数调用使主调函数能得到一个确定的值，这就是函数的返回值 </p>
<p>1，函数的返回值是通过函数中的return语句获得的。 </p>
<p>return语句将被调用函数中的一个确定值带回主调函数中去 </p>
<p>2，函数值的类型。既然函数有返回值，这个值当然应属于某一个确定的类型，应当在定义函数时指定函数值的 类型</p>
<p>3，在定义函数时指定的函数类型一般应该和return语句中的表达式类型一致<br>如果函数值的类型和return语句中表达式的值不一致，则以函数类型为准，对数值型数据，可以自动进行类型转换。即函数类型决定返回值类型</p>
<h3 id="形式参数与实际参数"><a href="#形式参数与实际参数" class="headerlink" title="形式参数与实际参数"></a>形式参数与实际参数</h3><p>在定义函数时函数名后面括号中的变量名称为”形式参数”（简称”形参“），在主调函数中调用一个函数时，函数名后面括号中的参数（可以是一个表达式）称为”实际参数“（简称”实参“） </p>
<p><strong>形式参数和实际参数说明</strong> </p>
<ol>
<li>在定义函数中指定的形参，在未出现函数调用时，他们并不占内存中的存储单元。只有在发生函数调用 时，函数中的形参才被分配内存单元，在调用结束后，形参所占的内存单元也被释放<br>注：因为当进入函数时，形参也相当于变量，是变量就要给它开辟空间。当调用结束后，形参所占的内存单元也被释放 </li>
<li>实参可以是常量，变量或表达式。但要求他们有确定的值 </li>
<li>在被定义的函数中，必须指定形参的类型 </li>
<li>实参与形参的类型应相同或赋值兼容 </li>
<li>实参向形参的数据传递是”值传递“，单向传递，只由实参传给形参，而不能由形参传回来给实参，在内存 中，实参单元与形参单元是不同的单元，在调用函数时，给形参分配存储单元，并将实参对应的值传递给 形参，调用结束后，形参单元被释放，实参单元仍保留并维持原值，因此，在执行一个被调用函数时，形 参的值如果发生改变，并不会改变主调函数的实参的值</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">通过函数实现两个数的交换</span><br><span class="line"><span class="type">int</span> <span class="title function_">print_message_a</span><span class="params">(<span class="type">int</span> nNumb,<span class="type">int</span> nNumA)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>  nTem = nNumb;</span><br><span class="line">  nNumb = nNumA;</span><br><span class="line">  nNumA = nTem;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;b=%d,A=%d&quot;</span>,nNumb,nNumA);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>  nNumb=<span class="number">12</span>,nNumA=<span class="number">10</span>;</span><br><span class="line">  print_message_a(nNumb, nNumA);  <span class="comment">//可以不接受返回值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;nNumb=%d,nNumA=%d&quot;</span>,nNumb,nNumA);</span><br><span class="line">  <span class="comment">//最终结果 nNumb,nNumA值没有任何变化</span></span><br><span class="line">  <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220321163503789.png" alt="image-20220321163503789"></p>
<p>所有函数都是平行的，即在定义函数时是分别进行的，是相互独立的。一个函数并不从属另一个函数，即函数不能嵌套定义，函数间可以相互调用，但不能调用main函数，main函数是系统调用的 </p>
<p>从用户使用的角度看，函数有两种，<br>（1）标准函数即库函数，它是由系统提供的，用户不必自己定义而直接使用他们<br>（2）用户自己定义的函数，它是用以解决用户专门需要的函数<br>从函数的形式看，函数分两类<br>（1）无参函数，在调用无参函数时，主调函数不向被调函数传递数据，无参函数一般用来执行指定的一组操作<br>无参函数可以带回或不带回函数值，但一般以不带回返回值的居多<br>（2）有参函数，在调用函数时，主调函数在调用被调函数时，通过参数向被调函数传递数据，一般情况下，执行被调函数时会得到一个函数值，供主调函数使用</p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p><strong>局部变量</strong></p>
<p>局部变量定义在函数内部，只对当前函数有效，如“{}”内定义的局部变量与外面重名，则以内部为准 </p>
<p><strong>全局变量</strong></p>
<p>全局变量需要定义在函数外部，对所有函数有效，全局变量的作用范围是从定义变量的位置开始到源程序结束，即全局变量可以被在其定义位置之后的其他函数所共享，全局变量主要用于函数之间数据的传递 </p>
<p><strong>静态局部变量</strong></p>
<p>静态变量的作用类似于全局变量，所有的全局变量均为静态变量，而局部变量只有定义时加上类型下修饰符static，才为局部静态变量 </p>
<p>静态变量的特点是在程序的整个执行过程中始终存在，但是它作用域之外不能使用，静态变量的生存期就是整个程序的运行期，函数体内如果在定义静态变量的同时进行了初始化，则以后程序不再进行初始化操作 </p>
<p><strong>extern与static在全局变量中的应用</strong></p>
<p>如果组成这一个程序的几个文件需要用到同一个全局变量，只要在其它引用该全局变量的源程序文件中说明该全局变量为extern即可 </p>
<p>如果一个源程序文件中的全局变量仅限于该文件使用，只要在该全局变量定义时的类型说明前加static即可 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern int nNum;//nNum已经在其他位置定义 </span><br></pre></td></tr></table></figure>

<p>如果一个源程序文件中的全局变量仅限于该文件使用，只要在该全局变量定义时的类型说明前加static即可 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int nNum;//仅限于本文件使用</span><br></pre></td></tr></table></figure>

<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>编译预处理主要用于在程序正式编译前进行一些预加工操作，编译预处理共分为以下几种：</p>
<ul>
<li>宏定义 </li>
<li>文件包含 </li>
<li>条件编译 </li>
<li>所有的编译预处理命令均以”#”开头 </li>
<li>宏</li>
</ul>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>宏定义的作用就是在程序中某段代码的一个别名，宏定义主要为程序调试，移植等提供便利，是一个非常使用的功能。所有宏命令都以符号“#define”开头，并且结尾不用分号。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define PI 3.14 </span><br></pre></td></tr></table></figure>

<p>宏定义的作用是在编译预处理时，将源程序中所有标识符替换成语句序列。。宏定义分别为有参宏和无参宏 </p>
<p>需要注意的是宏名一般用大写字母，以便与变量名的区别，在编译预处理时宏名与字符串进行替换时，不做语法检查，只是简单的字符替换，只有在编译时才对已经展开红名的源程序进行语法检查。宏明的有效范围是从定义位置到文件结束，如果需要终止宏定义的作用域，可以用<code>#undef</code>命令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define PI 3.14 </span><br><span class="line">........ </span><br><span class="line">#undef PI </span><br></pre></td></tr></table></figure>

<h3 id="无参宏"><a href="#无参宏" class="headerlink" title="无参宏"></a>无参宏</h3><p>无参宏指的是执行单一替换功能的宏定义，在使用无参宏时要注意以下两个问题，<br>1，宏定义时可以应用已经定义的宏名，如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\#define R 2.0 </span><br><span class="line">\#define PI 3.14 </span><br><span class="line">\#define L 2*PI*R </span><br></pre></td></tr></table></figure>

<p>2，对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作 </p>
<h3 id="有参宏"><a href="#有参宏" class="headerlink" title="有参宏"></a>有参宏</h3><p>可以让我们在定义宏时，还可以带参数扩大宏的应用范围，有参宏的格式</p>
<p><code>#define </code>标识符（参数列表） 字符串 </p>
<p>它的作用是在编译预处理时，将源程序中所有标识符替换成字符串，并且将字符串中的参数用实际使用的参数替换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define S(a,b) (ab)/2 </span><br></pre></td></tr></table></figure>

<p>需要注意的是，在宏定义时，宏名和参数之间不能有空格，否则空格后面的所有字符序列都作为替换的字符串。带参数的宏展开时，只作简单的字符和参数的替换，不进行任何计算操作，所以一般在定义宏时，字符串中的形式参数外面加一个小括号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define L(r) 2*PI*r </span><br></pre></td></tr></table></figure>

<p>如果源程序有L(2+3),则编译预处理后变为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">23.141592+3 不是 23.141595 </span><br></pre></td></tr></table></figure>

<p>解决办法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define L(r) 2PI*(r) </span><br></pre></td></tr></table></figure>

<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>文件包含的功能是将指定的文件内容嵌入到一个源文件中，文件包含共用以下两种格式 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\#include //标准方式 </span><br></pre></td></tr></table></figure>

<p>只按照标准方式在C语言编译器的C函数库头文件中查找要包含的文件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\#include &quot;xxxx.x&quot; //通用方式 </span><br></pre></td></tr></table></figure>

<p>先在源文件所在的目录中查找要包含的文件，若未能找到，则在按照标准方式查找</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h3><p>计算机内存是以字节为单位的存储空间，内存的每一个字节都有一个唯一的编号，这个编号就称为地址，当C程序中定义一个变量时，系统就分配一个带有一个唯一地址的存储单元来存储这个变量，程序对变量的读取操作(即变量的引用)，实际上是对变量所在存储空间进行写入或取出数据 </p>
<p>通常我们引用变量时是通过变量名直接引用变量，例如赋值运算b&#x3D;66，系统自动将变量名转换成变量的存储位置(即地址)，然后再将数据66放入变量b的存储空间中，这种引用变量的方式称为变量的“直接引用”方式 </p>
<p>此外，C语言中还有另一种称“间接引用”的方式，它首先将变量A的地址存放再一个变量B(存放地址的变量成为指针变量)中，然后通过存放变量地址的这个变量B来引用变量A<br>一个变量的地址称为该变量的指针，用来存放一个变量地址的变量名称为指针变量，当指针变量p的值为某变量的地址时，可以说指针变量p指向该变量</p>
<blockquote>
<p>定义变量的本质：开辟出一块空间，并用变量名代表那一片空间<br>内存空间的最小单位是字节，每一个字节都有一个编号，这个编号我们称之为地址。<br>有一种特殊的变量，专门存储地址，这种变量叫做指针变量，一般我们也简称为指针</p>
</blockquote>
<h3 id="基本使用方式"><a href="#基本使用方式" class="headerlink" title="基本使用方式"></a>基本使用方式</h3><p>指针的使用一般分为三步： </p>
<ol>
<li>定义指针变量</li>
<li>给指针变量赋值</li>
<li>指针解引用</li>
</ol>
<p>在这个过程中你需要使用到两个运算符：&amp;和* 定义指针变量</p>
<p>指针变量定义的一般形式为：<br>类型名<code>*</code> 指针变量名<br><code>int* pNums </code></p>
<p>注意：<br>（1）变量名前面的<code>*</code>是一个说明符，用来说明该变量是指针变量，这个<code>*</code>是不能省略的，但是			它不是变量名的一部分<br>（2）类型名表示指针变量所指向的变量的类型，而且只能指向这种类型的变量 </p>
<p>指针变量允许在定义时进行初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int nNumA, nNumB </span><br><span class="line">int *pA=&amp;nNumA，*pB=&amp;nNumB</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322112304615.png" alt="image-20220322112304615"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表示：定义了两个指向int型变量的指针变量pA和pB，pA的初值为变量nNumA的地址&amp;nNumA，pB的初值为变量nNumB的地址&amp;nNumB，不是表示*pA的初值为&amp;nNumA,*pB的初值为&amp;nNumB </span><br></pre></td></tr></table></figure>

<h3 id="给指针变量赋值"><a href="#给指针变量赋值" class="headerlink" title="给指针变量赋值"></a>给指针变量赋值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  nNum=<span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> *p1;</span><br><span class="line">   p1=&amp;nNum;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针变量的引用"><a href="#指针变量的引用" class="headerlink" title="指针变量的引用"></a>指针变量的引用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">	<span class="type">int</span>* p = <span class="number">0</span>;</span><br><span class="line">	p = &amp;a;</span><br><span class="line">	<span class="type">int</span> temp = *p;</span><br><span class="line">	*p = <span class="number">200</span>;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322112828709.png" alt="image-20220322112828709"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;a表示变量a的地址 </span><br><span class="line">*p表示指针变量p指向的变量* </span><br></pre></td></tr></table></figure>

<p>指针变量是用来存放地址的，不要给指针变量赋常量值，例如：<br><code>int* p</code>&#x3D;100; </p>
<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322113328807.png" alt="image-20220322113328807"></p>
<p>指针变量没有指向确定地址前，不要对它所指的对象赋值，例如：<br><code>int nNum=5, *p=nNum</code>; &#x2F;&#x2F;类型不匹配 </p>
<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322113519948.png" alt="image-20220322113519948"></p>
<h3 id="指针与函数传参"><a href="#指针与函数传参" class="headerlink" title="指针与函数传参"></a>指针与函数传参</h3><p>指针是间接引用，可以利用这一特性进行参数传递，使得函数内值的变化能够影响到函数外部</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* px, <span class="type">int</span>* py)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *px;</span><br><span class="line">	*px = *py;</span><br><span class="line">	*py = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">11</span>;</span><br><span class="line">	<span class="type">int</span> b=<span class="number">22</span>;</span><br><span class="line">	swap(&amp;a, &amp;b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322114011810.png" alt="image-20220322114011810"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">11</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">22</span>;</span><br><span class="line">	swap(a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322114155187.png" alt="image-20220322114155187"></p>
<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322114220820.png" alt="image-20220322114220820"></p>
<h3 id="指针与一维数组"><a href="#指针与一维数组" class="headerlink" title="指针与一维数组"></a>指针与一维数组</h3><p>指针是可以有数学运算的但是指针的运算和它的类型昔昔相关</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span>* p1 = &amp;a;</span><br><span class="line">    p1 + <span class="number">1</span>;<span class="comment">//它并非会将地址+1，而是将地址加到下一个Int型的位置</span></span><br><span class="line">    p1++; <span class="comment">//实际上地址值会自增4</span></span><br><span class="line">    <span class="type">short</span>  b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">short</span>* p2 = &amp;b;</span><br><span class="line">    p2 + <span class="number">1</span>;<span class="comment">//同样的，它是将地址加到下一个short型的位置</span></span><br><span class="line">    p2++; <span class="comment">//实际上地址值会自增2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322114936268.png" alt="image-20220322114936268"></p>
<p>一维数组名其实是地址，并且一维数组名这个地址，她也是有类型的，就是一级指针类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  Array[<span class="number">5</span>] = &#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	<span class="type">int</span>* p = Array;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">0</span>]);<span class="comment">//和打印Array[0]，*(p+0)一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322115135402.png" alt="image-20220322115135402"></p>
<h2 id="结构体与联合体"><a href="#结构体与联合体" class="headerlink" title="结构体与联合体"></a>结构体与联合体</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体就是把具有内在联系的多个不同类型的数据结合成一个整体，使他们关联起来 </p>
<p>结构体类型定义的初级形式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strcut </span><br><span class="line">&#123; </span><br><span class="line">类型<span class="number">1</span> 成员名<span class="number">1</span>； </span><br><span class="line">。。。。 </span><br><span class="line">类型名n 成员名n </span><br><span class="line">&#125;结构体变量名=&#123;初始化元素<span class="number">1</span>，初始化元素<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  strcut&#123;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> score;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;People1;</span><br><span class="line"> <span class="comment">//1,使用结构体成员，通过&quot;.&quot;符号</span></span><br><span class="line"> <span class="comment">//2,使用的时候，就和普通变量一样</span></span><br><span class="line">People.age = <span class="number">18</span>;</span><br><span class="line">People.score = <span class="number">95</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简便模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  结构体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  类型名<span class="number">1</span>  成员名<span class="number">1</span>；</span><br><span class="line">  .....</span><br><span class="line">  类型名n  成员名n</span><br><span class="line">&#125;;</span><br><span class="line">这么写并非为了定义一个结构体变量，而是产生了一个结构体类型，如果需要，可以用这个类型定义无数的变量</span><br><span class="line">例如：</span><br><span class="line"><span class="number">1</span>，定义结构体类型定义</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  _<span class="title">PERSON</span>&#123;</span></span><br><span class="line"> <span class="type">char</span>  name[<span class="number">20</span>];</span><br><span class="line"> <span class="type">char</span>  sex;</span><br><span class="line">  <span class="type">int</span>  age;</span><br><span class="line">  <span class="type">float</span>  height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">2</span>，定义结构体变量</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  _<span class="title">PERSON</span>  <span class="title">abc</span></span></span><br><span class="line"><span class="class">1，表示定义了一个结构体类型<span class="keyword">struct</span> <span class="title">person</span>，它由<span class="title">name</span>,<span class="title">sex</span>,<span class="title">age</span>和<span class="title">height</span>四个成员组成</span></span><br><span class="line"><span class="class">2，表示定义一个结构体类型的变量</span></span><br></pre></td></tr></table></figure>

<p>中间模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">也可以在给结构体起名的同时定义一个变量，这也不常用</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PERSON</span>&#123;</span></span><br><span class="line"> <span class="type">char</span>  name[<span class="number">20</span>];</span><br><span class="line"> <span class="type">char</span>  sex;</span><br><span class="line"> <span class="type">int</span>  age;</span><br><span class="line"> <span class="type">float</span>  height;</span><br><span class="line">&#125;per1;</span><br><span class="line">per1就是_PERSON类型的变量c</span><br></pre></td></tr></table></figure>

<p>结构体嵌套</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  _<span class="title">PERSON</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> score;</span><br><span class="line">  <span class="type">char</span>  name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="comment">//定义一个结构体变量，初始化结构体变量，放在&#123;&#125;中</span></span><br><span class="line"> _PEOPLE  stcPeople = &#123;<span class="number">18</span>,<span class="number">100</span>,<span class="string">&quot;xiaoming&quot;</span>&#125;;</span><br><span class="line"> <span class="comment">//使用结构体变量</span></span><br><span class="line"> strPeople.age=<span class="number">18</span>;</span><br><span class="line"> stcPeople.score=<span class="number">95</span>;</span><br><span class="line"> strcpy_s(stcPeople.name,<span class="number">20</span>,<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">注意：不能嵌套自己本身，但能够嵌套自己类型的指针</span><br></pre></td></tr></table></figure>

<h3 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h3><p>将结构体变量各成员的初值顺序地放在一对大括号中，并用逗号分隔； </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span> </span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>]; </span><br><span class="line"><span class="type">char</span> sex; </span><br><span class="line"><span class="type">int</span> age; </span><br><span class="line"><span class="type">float</span> height; </span><br><span class="line">&#125;per=&#123;<span class="string">&quot;Li Ping&quot;</span>,<span class="string">&quot;M&quot;</span>,<span class="number">20</span>,<span class="number">175.5</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="结构体变量的引用"><a href="#结构体变量的引用" class="headerlink" title="结构体变量的引用"></a>结构体变量的引用</h3><p>结构体变量的引用必须在定义结构体变量后进行，对结构体变量的引用可以分为对结构体变量中成员的引用和对整个结构体变量的引用。引用结构体成员的一般形式为：<br>结构体变量名.成员名<br>“.”时成员运算符，它在所有运算符中优先级最高<br>如果某个成员本身又是结构体变量，则必须连续使用成员运算符，直到最低一级成员才能进行运算，结构体变量的每个成员都属于某种数据类型，因此都可以像普通变量一样进行其类型允许的各种操作</p>
<h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><p>定义结构体数组的方法和定义结构体变量的方法一样，定义结构体变量的三种方法都可以用来定义结构体数组<br>定义结构体数组不常用这种方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strcut  person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span>  name[<span class="number">20</span>];</span><br><span class="line">  <span class="type">char</span>  sex;</span><br><span class="line">  <span class="type">int</span>  age;</span><br><span class="line">  <span class="type">float</span>  height;</span><br><span class="line">&#125;per[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>常用方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strcut  person</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  name[<span class="number">20</span>];</span><br><span class="line">   <span class="type">char</span>  sex;</span><br><span class="line">   <span class="type">int</span>  age;</span><br><span class="line">   <span class="type">float</span>  height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">person</span> <span class="title">per</span>[3];</span></span><br></pre></td></tr></table></figure>

<h3 id="联合体类型"><a href="#联合体类型" class="headerlink" title="联合体类型"></a>联合体类型</h3><p>联合体的基本语法<br>联合体有时也被称为共用体，其基本使用语法，和结构体一样。只有关键字是(union)。<br>定义形式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>  联合体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  类型名<span class="number">1</span>  成员名<span class="number">1</span>；</span><br><span class="line">  ......</span><br><span class="line">  类型名n  成员名n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联合体与结构体的区别"><a href="#联合体与结构体的区别" class="headerlink" title="联合体与结构体的区别"></a>联合体与结构体的区别</h3><p>结构体，每一个成员单独占用内存空间<br>联合体，所有的成员共享一块空间<br>联合体的应用</p>
<p>通常来说有两种用途<br>1，同一个数据需要多种表现形式<br>2，在互斥情况之下的节省空间</p>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>定义新类型名的一般形式<br>typedef 类型名 表示符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span>  INT;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> * PINT</span><br><span class="line"> <span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">   INT num2 =<span class="number">20</span>;</span><br><span class="line">   PINT  pInt = <span class="literal">NULL</span>;</span><br><span class="line">   pInt=&amp;num;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*pInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了类型定义之后，就可以用新的名字代替原来的名字定义变量</p>
<p>使用typedef语句不是创造新类型，而是为已经存在的类型增加了一个名字，目前来看，最为常用的使用方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  _<span class="title">PEOPLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span>  nAge;</span><br><span class="line">  <span class="type">int</span> nScore;</span><br><span class="line">  <span class="type">char</span>  szName[<span class="number">20</span>];</span><br><span class="line">&#125;PEOPLE,*PPEOPLE  <span class="comment">//给结构体类型起一个新的名字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  _<span class="title">PEOPLE</span>  <span class="title">stcPeople1</span> =</span> &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="string">&quot;xiaoming&quot;</span>&#125;;</span><br><span class="line">  PEOPLE stcPeople = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="string">&quot;xiaoming&quot;</span>&#125;; <span class="comment">//这里使用新名字定义变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个C语言的遗留问题，在C语言中，定义结构体变量，必须使用上述代码斜体的方式。<br>为了省略一个struct，所以重定义类型名，这种用法一直用到了现在。并且遗留带来C++中。但是我们知道C++中定义结构体变量本身也不需要加struct。这不算尴尬，尴尬的是大家现在都知道C++定义结构体或者联合体变量不需要加struct，很多地方依然保留C语言的习惯，尤其在windows开发中。</p>
<h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><h3 id="堆内存的动态分配"><a href="#堆内存的动态分配" class="headerlink" title="堆内存的动态分配"></a>堆内存的动态分配</h3><p>在程序设计中，对于要处理的批量数据，我们往往是选用数组作为存放这些数据的数据结构，然而，数组有一个明显的缺点，就是在定义数组时，其长度必须时常值，无法根据需要动态地定义。这样，在很多情况下不是定义的数组长度不够，就是定义太长以至于浪费。</p>
<p>采用动态分配可以客服这一缺点，并且可以随时释放</p>
<p>动态分配内存空间的步骤 </p>
<ol>
<li>定义一个指针变量： </li>
<li>申请一片内存空间，并将其首地址赋给指针变量，此时便可通过指针变量访问这片内存</li>
<li>用完后释放这片内存空间<br>在这里主要涉及两个函数，即malloc-申请空间，free-释放空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//malloc这个函数，参数要申请的大小(字节)</span></span><br><span class="line">  <span class="comment">//返回值，就是申请成功之后，申请出空间的起始地址</span></span><br><span class="line">  p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  *p = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br><span class="line">  <span class="comment">//释放掉申请出的空间</span></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322160824495.png" alt="image-20220322160824495"></p>
<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322160847563.png" alt="image-20220322160847563"></p>
<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322160921824.png" alt="image-20220322160921824"></p>
<h3 id="使用堆和使用数组的差别"><a href="#使用堆和使用数组的差别" class="headerlink" title="使用堆和使用数组的差别"></a>使用堆和使用数组的差别</h3><ul>
<li>数组长度只能是常量，堆大小可以是变量</li>
<li>堆，需要自己释放，假如不释放，或者忘记释放，就会造成内存泄漏。数组，不需要自己释放。</li>
</ul>
<h3 id="关于悬空指针与野指针"><a href="#关于悬空指针与野指针" class="headerlink" title="关于悬空指针与野指针"></a>关于悬空指针与野指针</h3><h4 id="悬空指针"><a href="#悬空指针" class="headerlink" title="悬空指针"></a>悬空指针</h4><p>我们释放了内存之后，指针，应该被及时的赋值为NULL，不赋值为NULL的话，称为悬空指针 </p>
<h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><p>指针变量被定义之后，没有被初始化，这种指针被称为野指针<br>总结：指针变量，要么指向有意义的地方(变量，数组，堆)，要么就指向NULL(0);</p>
<h2 id="一个程序的内存划分"><a href="#一个程序的内存划分" class="headerlink" title="一个程序的内存划分"></a>一个程序的内存划分</h2><p>通常来说，一个运行当中的程序，内存会划分为5各个区域 </p>
<p>代码区，常量区，栈区，堆区，全局数据区<br>常量区：字符串<br>栈区 ：局部变量<br>堆区 ：malloc出来的区域<br>全局数据区：全局变量，static局部变量</p>
<p><strong>其他内存操作函数</strong></p>
<h3 id="内存初始化函数memset"><a href="#内存初始化函数memset" class="headerlink" title="内存初始化函数memset"></a><strong>内存初始化函数memset</strong></h3><p>其原型为： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void memset（起始地址，要设置的值，要设置多大区域）</span><br></pre></td></tr></table></figure>

<p>一般用于给刚申请出的内存，设置一个初始值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">	p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="built_in">memset</span>(           <span class="comment">//通常我们使用这个函数给申请地空间初始化为0</span></span><br><span class="line">		p,            <span class="comment">//起始地址</span></span><br><span class="line">		<span class="number">1</span>,            <span class="comment">//设置地值</span></span><br><span class="line">		<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)  <span class="comment">//大小</span></span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322162249087.png" alt="image-20220322162249087"></p>
<h3 id="内存拷贝函数memcpy"><a href="#内存拷贝函数memcpy" class="headerlink" title="内存拷贝函数memcpy"></a>内存拷贝函数memcpy</h3><p>其原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void memcpy(目标地址，源数据地址，要拷贝多大区域) </span><br></pre></td></tr></table></figure>

<p>一般用于要把内存中的数据考到另一块内存中</p>
<p>使用堆，实际上就大量的会使用指针，记住以下原则 </p>
<ul>
<li>刚刚分配的动态内存的初始值是不确定的 </li>
<li>不能对同一指针(地址)连续两次进行free操作 </li>
<li>不能对指向静态内存区（全局变量）或栈内存区（局部变量）的指针应用free（但可以对空指针NULL应用free），对一个指针应用free之后，它的值不会改变，但它指向了一个无效的内存区，这个也就是上面讲的“悬空指针” </li>
<li>如果没有及时释放某块动态内存，并且将指向它的指针指向了别处，就会造成“内存泄漏”，执行malloc和free函数有一定代价，所以对于较小的数据量不应该放在动态内储中，并且尽量避免频繁地分配和释放内存</li>
</ul>
<p>进行内存区域地申请时，主要需注意避免发生以下错误：</p>
<ul>
<li>内存分配未成功，却用了它 </li>
<li>内存分配虽然成功，但是尚未初始化就引用它。(误认为初始值为0) </li>
<li>内存分配成功并且已经初始化，但操作超过了内存地边界 </li>
<li>忘记了释放内存，造成内存泄漏 </li>
<li>释放了内存却继续使用它</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一级指针地使用方式和数组类似</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">  p[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">p=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//此时释放地就是后面申请，前面申请地地址丢失了，也就无法释放了</span></span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//此时使用了悬空指针</span></span><br><span class="line"><span class="comment">//p=&amp;Num;</span></span><br><span class="line"><span class="comment">//free(p);不能释放除了堆空间之外地内存</span></span><br><span class="line"><span class="comment">//free(p);错误对同一块堆空间，不能释放两次</span></span><br><span class="line"><span class="comment">//p=NULL;及时置为空，配合下main地代码，就会避免悬空指针地使用</span></span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//一般我们使用指针之前，检测一下是不是空指针是一个好习惯 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针进阶"><a href="#指针进阶" class="headerlink" title="指针进阶"></a>指针进阶</h2><h3 id="指针算术运算"><a href="#指针算术运算" class="headerlink" title="指针算术运算"></a>指针算术运算</h3><p>指针能够支持一些算术运算，不过含义和普通地数据地算数运算非常不同<br>首先指针只能进行加法和减法运算： </p>
<p>并且只有两种形式： </p>
<ol>
<li>指针+(-)整数 </li>
<li>指针-指针</li>
</ol>
<p>指针加或者减一个整数地话，得到地数据类型还是一个指针。得到地数据值是+(-)整数sizeof(整数类型)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a[] = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">	<span class="type">int</span>* ptr = (<span class="type">int</span>*)a;</span><br><span class="line">	<span class="type">char</span>* cp = a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">	<span class="keyword">while</span> (*ptr != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *ptr);</span><br><span class="line">		ptr++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//while(*cp!=&#x27;\0&#x27;)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	printf(&quot;%c\n&quot;,*cp);	</span></span><br><span class="line">	<span class="comment">//	cp++;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针-指针得到地是这两个地址间能够存放多少个这种类型地数据 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* p1 = &amp;a;</span><br><span class="line">    <span class="type">int</span>* p2 = &amp;b;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = p1 - p2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1= %x\n&quot;</span>, p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2= %x\n&quot;</span>, p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num的地址=%x, num=%d\n&quot;</span>, &amp;num, num);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322164223393.png" alt="image-20220322164223393"></p>
<h3 id="指针与一维数组-1"><a href="#指针与一维数组-1" class="headerlink" title="指针与一维数组"></a><strong>指针与一维数组</strong></h3><p>数组名就是数组地起始地址，也就是第一个元素地地址，数组名是个常量指针</p>
<p>类型地变化规律</p>
<ul>
<li>对变量取地址，得到地是地址，类型为一级指针类型 </li>
<li>数组名，也是一级指针类型 </li>
<li>对一级指针解引用，得到的是相应的数据类型 </li>
<li>对一级指针类型用下标运算符，得到的是相应数据类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span>* p = a; <span class="comment">//这里数组名a,可以看成整形指针类型</span></span><br><span class="line">	<span class="type">int</span> *m = a + <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> *m1 = &amp;a[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> *m2 = p + <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> *m3 = &amp;p[<span class="number">2</span>];<span class="comment">// 表示同一个一级指针类型的同一地址</span></span><br><span class="line">	<span class="type">int</span> n = *(a + <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> n1 = *&amp;a[<span class="number">2</span>];c</span><br><span class="line">	<span class="type">int</span> n2 = *(p + <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> n3 = *&amp;p[<span class="number">2</span>]; <span class="comment">// 都表示Int型，数据是a[2];</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/21/C%EF%BC%88%E4%B8%89%EF%BC%89/image-20220322164812275.png" alt="image-20220322164812275"></p>
<h3 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h3><p>二维数组名也是一个指针类型，叫做一维数组指针类型 </p>
<p>我们自己定义一维数组指针：类型名（*变量名）[数组长度] </p>
<p>注意：<br>对于数组指针，应该给出所指向数组的长度 </p>
<p>类型变化规律:</p>
<ol>
<li>对一维数组指针解引用就会降维，变成一级指针 </li>
<li>对一维数组指针使用下标运算符也会降维，变成一级指针 </li>
<li>对于一维数组指针+1，会得到下一排起始地址，类型还是数组指针 </li>
<li>对于一维数组名取地址，会变为二维数组指针，数值不变</li>
</ol>
<h3 id="指针与多维数组"><a href="#指针与多维数组" class="headerlink" title="指针与多维数组"></a>指针与多维数组</h3><p>多维数组指的是一维以上的数组，其数组名为多维数组指针类型 </p>
<p>转换规律</p>
<ol>
<li>对多维数组指针解引用会降维，变成降一维的数组指针，直到降成一级指针 </li>
<li>对数组指针使用下标运算符也会降维，直到降维成一级指针 </li>
<li>对于数组指针+1，会得到下一个数组的起始地址，类型不变 </li>
<li>对多维数组名取地址，会变为更高维度的数组指针，数值不变</li>
</ol>
<h3 id="指针数组与数组指针"><a href="#指针数组与数组指针" class="headerlink" title="指针数组与数组指针"></a>指针数组与数组指针</h3><ul>
<li>指针数组：指针数组可以说成是”指针的数组”，首先这个变量是一个数组，其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型，在32位系统中，指针占四个字节。</li>
<li>数组指针：数组指针可以说成是”数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。<br>根据上面的解释，可以了解到指针数组和数组指针的区别，因为二者根本就是种类型的变量。</li>
</ul>
<p><strong>指针数组</strong><br>指针数组就是其元素为指针的数组<br>每一个元素都是指针变量<br>说明指针数组的语法格式为<br>数据类型 * 指针数组名[常量表达式]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *arr[4] = &#123;&quot;hello&quot;, &quot;world&quot;, &quot;shannxi&quot;, &quot;xian&quot;&#125;;</span><br><span class="line">//arr就是我定义的一个指针数组，它有四个元素，每个元素是一个char *类型的指针，这些指针存放着其对应字符串的首地址。</span><br></pre></td></tr></table></figure>

<p><strong>数组指针</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char (*pa)[4];</span><br></pre></td></tr></table></figure>

<p>如果指针数组和数组指针这俩个变量名称一样就会是这样：char *pa[4]和char (*pa)[4]，原来指针数组和数组指针的形成的根本原因就是运算符的优先级问题</p>
<p>注意指针数组与数组指针的区别 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *p[5];//一级指针数组 </span><br><span class="line">int **p[5]; //二级指针数组 </span><br><span class="line">int (*p2[5])[10]; //数组指针数组 </span><br></pre></td></tr></table></figure>


<p>指针数组存储的是指针，二维数组存储的是数据</p>
<h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><p>一般称为数据流，也有叫做字节流，比特流的，还有很具体的文件流，视频流，音频流等</p>
<p>文件是指存储在计算机外部存储中的数据的集合。计算机根据文件的名字，完成对文件的操作，C语言将文件看作是字符构成的序列，即字符流，其基本的存储单位是字节，C语言中的文件，按照它的ASCII代码存放，称为ASCII文件或文本(text)文件，按照数据值的二进制代码存放，称为二进制中 </p>
<p>ASCII文件中的字节与实例字符一一对应，方便字符处理和用户阅读，但占用存储空间较大，而二进制文件节省存储空间，也无需ASCII代码和二进制形式之间的转换时间，但是无法直接输出，一般用于程序与程序之间或者程序与设备之间数据的传递</p>
<p>在C语言中，文件可以是磁盘文件，终端显示器或打印机等等，程序通过打开操作把流与设备联系起来，文件打开后，可以在程序和文件之间交换数据，程序通过关闭操作断开流与文件的联系，所有流的性质都一样，因为流与设备无关，所以能写入磁盘文件的同意函数也能写入另一设备，如控制终端等，但文件的能力则可能不同，例如，磁盘文件可以支持随机存取，而键盘则不行，数据必须按照存入的类型读出，才能回归其本来面貌</p>
<h3 id="文件访问的基本模式"><a href="#文件访问的基本模式" class="headerlink" title="文件访问的基本模式"></a>文件访问的基本模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; open：打开文件，获得对此文件的指针，引用和句柄等，以证明可以使用此文件</span><br><span class="line">&gt; read：读文件，参数一般指明要读多少字节，读到哪块内存，每次调用此功能，都是接着上次调用的结束位置读。（所以是个输入流）</span><br><span class="line">&gt; write：写文件，参数一般指明把哪块内存的内容写入文件，要写多少字节，每次调用此功能，都是接着上次调用的结束位置写。（所以是个输出流）</span><br><span class="line">&gt; close：关闭文件，表明操作结束，不再使用此文件，文件使用完毕必须关闭，否则影响系统性能</span><br><span class="line">&gt; seek：随机控制流的当前位置，文件定位</span><br></pre></td></tr></table></figure>

<p><strong>定义一个指向文件结构体类型的指针变量的形式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FILE * 指针变量名</span><br><span class="line">FILE *fpFile</span><br></pre></td></tr></table></figure>

<p>则fpFile是可以指向一个FILE文件结构体的指针变量，文件指针变量的赋值操作是由打开文件函数fopen()实现的</p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>fopen()函数的原型是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FILE *fopen(char *filename,char *mode)</span><br><span class="line"></span><br><span class="line">FILE *fpFile=fopen(C:\\File.txt&quot;,&quot;r);</span><br></pre></td></tr></table></figure>

<p><strong>C语言的文件打开模式一览</strong></p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>处理方式</th>
<th>文件不存在</th>
<th>文件存在</th>
<th>向文件输入</th>
<th>从文件输出</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读取</td>
<td>出错</td>
<td>打开文件</td>
<td>不能</td>
<td>可以</td>
</tr>
<tr>
<td>w</td>
<td>写入</td>
<td>建立新文件</td>
<td>覆盖原文件</td>
<td>可以</td>
<td>不能</td>
</tr>
<tr>
<td>a</td>
<td>追加</td>
<td>建立新文件</td>
<td>在源文件后追加</td>
<td>可以</td>
<td>不能</td>
</tr>
<tr>
<td>r+</td>
<td>读取&#x2F;写入</td>
<td>出错</td>
<td>打开文件</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>w+</td>
<td>写入&#x2F;读取</td>
<td>建立新文件</td>
<td>覆盖源文件</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>a+</td>
<td>读取&#x2F;追加</td>
<td>建立新文件</td>
<td>在源文件后追加</td>
<td>可以</td>
<td>可以</td>
</tr>
</tbody></table>
<p>如果是二进制文件，在使用时只要在模式后添加字符b即可，如“rb”,”rb+”分别表示读取二进制文件和以读取&#x2F;写入模式打开二进制文件，如果由于文件不存在等原因造成不能打开文件，则调用fopen()后将返回一个空指针NULL,我们可以用如下代码检查文件是否打开成功</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((fpFIle=fopen(<span class="string">&quot;c:\\File.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Cannot open the file.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般exit(0)表示程序正常退出，exit(非零值)表示程序出错后退出</p>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>当C语言文件使用完后，应该立即关闭文件，防止由于误操作等原因破坏已经打开的文件。文件 的关闭通过stdio.h中的fclose()函数实现，具体用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fclose(文件指针)；</span><br><span class="line">fclose(fpFIle);</span><br></pre></td></tr></table></figure>

<p>程序将文件类型指针fpFile所指向的文件关闭，fpFile不再指向该文件</p>
<h3 id="文件的读写操作"><a href="#文件的读写操作" class="headerlink" title="文件的读写操作"></a>文件的读写操作</h3><p>C语言提供多种对文件的读取和写入的函数，四种常用的文件的读写操作函数,他们都在头文件stdio.h定义的</p>
<ol>
<li>按字符读写的函数fgetc(), fputc()</li>
<li>按字符串读写的函数fgets(), fputs()</li>
<li>按格式要求读写的函数fprint() , fscanf()</li>
<li>按数据块读写的函数fread(), fwrite()</li>
</ol>
<p>函数fputc()的作用是向文件写入一个字符，其调用形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(字符，文件型指针变量);</span><br><span class="line">fputc(<span class="string">&#x27;A&#x27;</span>,fpFile);</span><br></pre></td></tr></table></figure>

<p>fpFile为一个文件类型指针变量，上式将字符常量’A’（也可以是字符型变量）写入文件当前位置，并且使文件位置指针下移一个字节，如果写入操作成功，返回值是该字符，否则返回EOF</p>
<p>函数fgetc()的作用使从一个文件中读取一个字符。其调用形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fgetc(文件型指针变量)</span><br><span class="line"><span class="type">char</span>  cChar = fgetc(fpFile);</span><br></pre></td></tr></table></figure>

<p>fpFile为一个文件类型指针变量，函数fgetc(fpFile)不仅返回文件当前位置的字符，并且使文件位置指针下移一个字符，如果遇到文件结束，则返回值为文件结束标志EOF。</p>
<p>函数fputs()的作用使向文件写入一个字符串，其调用形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fputs(字符串，文件型指针变量)；</span><br></pre></td></tr></table></figure>

<p>其中字符串可以是字符串常量，指向字符串的指针变量，存放字符串数组的数组名，写入文件成功，函数返回值为0，否则为EOF。</p>
<p>注意：字符串的结束标志‘\0’不写入，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fputs(&quot;Hello&quot;,fpFile);</span><br></pre></td></tr></table></figure>

<p>fpFile为一个文件类型指针变量，上式将字符串的字符H,e,l,l,o写入文件指针的当前位置</p>
<p>函数fprintf()的作用与printf()相似，只是输出对象不是标准输出设备而是文件，即按照格式要求将数据写入文件。它调用的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(文件型指针变量，格式控制，输出列表);</span><br><span class="line"><span class="built_in">fprintf</span>(fpFile,<span class="string">&quot;%ld,%s&quot;</span>,num,name);</span><br></pre></td></tr></table></figure>

<p>它的作用使将变量num，name按照%ld，%s的格式写入fp指向的文件的当前位置。函数scanf()从通过标准输入设备读取数据，</p>
<p>同样函数fscanf()按照格式要求从文件中读取数据，它调用的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fscanf</span>(文件指针变量，格式控制，输入列表)</span><br><span class="line"><span class="built_in">fscanf</span>(fpFile,<span class="string">&quot;%ld,%s&quot;</span>,&amp;num,name)</span><br></pre></td></tr></table></figure>

<p>它的作用是从fpFile指向的文件的当前位置开始，按照%ld，%s的格式取出数据，赋给变量Num,name,fscanf()主要用于数据文件的读写，即可以使用ASCII文件也可以使用二进制文件。</p>
<p>函数fwrite()的作用是将成批的数据块写入文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fwrite(存放地址，数据块个数，文件型指针变量)</span><br></pre></td></tr></table></figure>

<p>如果函数fwirte()操作成功，则返回值为实际写入文件的数据块的个数。</p>
<p>例如，已知struct  student类型数组stu[20],则语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fwrite(&amp;stu[1],sizeof(struct  student),2,fp);</span><br></pre></td></tr></table></figure>

<p>从结构体数组元素stu[1]存放的地址开始，以一个结构体struct  student类型变量所占字节数为一个数据块，共写入文件类型指针fp指向的文件2个数据块，即stu[1],stu[2]的内容写入文件，如果操作成功，函数的返回值为2</p>
<h3 id="其他常用的文件操作函数"><a href="#其他常用的文件操作函数" class="headerlink" title="其他常用的文件操作函数"></a>其他常用的文件操作函数</h3><p>函数feof()用来检测一个指向文件的指针是否已经指到了文件最后的结束标志EOF，调用的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feof(文件型指针变量)；</span><br><span class="line">bool  bIsEnd = !feof(fpFile);</span><br></pre></td></tr></table></figure>

<p>如果文件型指针指向的文件的当前位置为结束标志EOF，则函数返回一个非零值，否则返回0值</p>
<p>函数rewind()将指向文件的指针重新指向文件的开始位置，函数无返回值，其调用形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rewind(文件型指针变量)；</span><br><span class="line">rewind(fpFile);</span><br></pre></td></tr></table></figure>

<p>fpFile是一个指向文件的指针，执行该语句后，fpFile指向文件的开始位置，即文件的第一个数据</p>
<p>函数fseek()可以将使得指向文件的指针变量指向文件的任何一个位置，实现随机读写文件，它调用的形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fseek(文件型指针变量，偏移量，起始位置)；</span><br><span class="line">fseek(fpFile,<span class="number">0x123</span>,SEEK_SET);</span><br></pre></td></tr></table></figure>

<p>函数fseek()将以文件的起始位置为基准，根据偏移量往前或往后移动指针。其中偏移量是一个长整形数，表示从起始位置移动的字节数，正数表示指针往后移，负数表示指针往前移。起始位置用宏SEEK_SET，SEEK_END代表文件开始，文件当前位置和文件结束位置，如果指针设置成功，返回值为0，否则为非0值</p>
<p>函数ftell()用于测试指向文件的指针的当前位置。它的调用方式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ftell(文件型指针变量)</span><br><span class="line"><span class="type">int</span> nOffset=ftell(fpFile);</span><br></pre></td></tr></table></figure>

<p>函数的返回值是一个常整形数，如果测试成功，则返回指向文件的指针当前指向的位置距离文件开头的字节数，否则返回-1L.</p>
<h2 id="源文件组织原则"><a href="#源文件组织原则" class="headerlink" title="源文件组织原则"></a>源文件组织原则</h2><p>同一类型或同意功能的代码，用一个.c文件与一个.h文件保存，头文件中不能有可执行代码，也不能有数据的定义，只能有宏，类型(typedef,struct,union,menu)，数据和函数的声明</p>
<p>头文件中不能包本地数据（即模块自己使用的数据或函数）。只有模块自己使用的函数，数据，不要用extern在头文件里声明，只有模块自己使用的宏，常量，类型也不要在头文件里声明，应该在自己的*.文件里声明，防止重复包含，使用宏“#pragma  once”防止一个头文件被重复包含</p>
<p>文件名和实现模块的c文件相同，例如“abc.c”对应的头文件应该是”abc.h”。不要包含那些只有在本模块中才使用的头文件，这些头文件应该在*c文件中包含。接口文件要有面向用户的充足的注释，接口文件在发布后尽量避免修改，即使修改也要保证不影响用户程序</p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>N5X刷Android_10</title>
    <url>/2022/03/14/N5X%E5%88%B7Android-10/</url>
    <content><![CDATA[<p>N5X刷入Android10</p>
<span id="more"></span>

<h2 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h2><p>1：offline</p>
<p><img src="/2022/03/14/N5X%E5%88%B7Android-10/image-20220313074826944.png" alt="image-20220313074826944"></p>
<p>拔掉数据线从新插入</p>
<p>2：failed to read copy response</p>
<p><img src="/2022/03/14/N5X%E5%88%B7Android-10/image-20220313074908930.png" alt="image-20220313074908930"></p>
<p>重启</p>
<p>3：</p>
<p><img src="/2022/03/14/N5X%E5%88%B7Android-10/image-20220313110910328.png" alt="image-20220313110910328"></p>
<p>fastboot版本问题</p>
<h2 id="刷机："><a href="#刷机：" class="headerlink" title="刷机："></a>刷机：</h2><p>1，刷入twrp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash recovery 下载的twrp版本</span><br></pre></td></tr></table></figure>

<p>2，twrp下刷入install 压缩包</p>
<h2 id="修改System权限"><a href="#修改System权限" class="headerlink" title="修改System权限"></a>修改System权限</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o rw,remount /system</span><br><span class="line">mount -o rw,remount /</span><br></pre></td></tr></table></figure>

<p>或者使用MT管理器移动</p>
<h2 id="证书相关："><a href="#证书相关：" class="headerlink" title="证书相关："></a>证书相关：</h2><p>移动到系统目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv /sdcard/xxxxxxx.0 /etc/security/cacerts/ 移动文件到系统</span><br><span class="line">chown root:root /etc/security/cacerts/fc365f9d.0 修改用户组</span><br><span class="line">chmod 644 /system/etc/security/cacerts/xxxxxxx.0 修改权限</span><br></pre></td></tr></table></figure>

<p>导出证书转换为pem：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform DER -in cacert.der -out cacert.pem</span><br></pre></td></tr></table></figure>

<p>查看pem证书的hash值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform PEM -subject_hash_old -in cacert.pem</span><br></pre></td></tr></table></figure>

<p>修改pem证书改名为”hash值.0“</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title>抓包（二）</title>
    <url>/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>工作中发现，有些APP抓不到包，或者打开直接闪退，之前也有抓过包，一段时间没做后，有些方法用起来有些生疏，这里总结一下。</p>
<p>首先APP一般都会连网，没连网测着也没啥意思，说明功能也不杂多，既然会闪退就会有检测或者双向认证（后面说），抓不到包的情况要么检测代理要么vpn要么双向认证。。。。</p>
<span id="more"></span>

<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/02.png" alt="02" style="zoom:25%;">

<h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><h1 id="抓包工具："><a href="#抓包工具：" class="headerlink" title="抓包工具："></a>抓包工具：</h1><p>BurpSuite, Charles, Fildder, mitmproxy，R0cmptuter（需要frida）</p>
<h2 id="添加证书到系统目录"><a href="#添加证书到系统目录" class="headerlink" title="添加证书到系统目录"></a>添加证书到系统目录</h2><p>没装证书时的样子</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315214953630.png" alt="image-20220315214953630"></p>
<p>首先导出证书</p>
<p>打开chales找到help选择ssl proxying点击名字最长的那个</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315211235678.png" alt="image-20220315211235678"></p>
<p>在手机中配置上图所示IP，端口</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01.png" alt="01" style="zoom:25%;">

<p>可以看到“链接”是灰色的，这是因为手机跟电脑没在一个网段，下面就改回来了</p>
<p>连接好之后在浏览器中输入<code>chls.pro/ssl</code>，然后电脑端会显示是否允许远程链接，选择是，会下载证书。下载后安装就行，这时会把证书安装到用户目录。可以使用Magisk模块<code>move certificates</code>移动到系统目录。（步骤就是首先有模块，安装完用户证书后，手机关机重启就行）</p>
<h2 id="手动安装证书到系统目录"><a href="#手动安装证书到系统目录" class="headerlink" title="手动安装证书到系统目录"></a>手动安装证书到系统目录</h2><p>首先把证书导来，charles可以导出pem格式，其他工具虽然导不出pem格式，可以使用openssl转换</p>
<p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform DER -in burp.der -out burp.pem</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315215723332.png"></p>
<p>charles</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315215240068.png" alt="image-20220315215240068"></p>
<p>查看pem证书的hash值并记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -subject_hash_old -in charles.pem</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315220058741.png" alt="image-20220315220058741"></p>
<p>将证书名修改为：红色标记的值.0（因为系统证书目录里的证书是这样命名的<code>证书Hash.数字</code>，数字可以可以设置为别的，防止命名冲突）</p>
<p>下一步将证书移动到手机里使用如下命令或者其他方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push ec936cb1.0 /sdcard</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315221016089.png" alt="image-20220315221016089"></p>
<p>修改系统目录权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o rw,remount /system</span><br><span class="line">mount -o rw,remount /</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315221328562.png" alt="image-20220315221328562"></p>
<p>移动证书到系统目录</p>
<p>系统证书目录：<code>/system/etc/security/cacerts/</code>,修改权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv sdcard/ec936cb1.0 /system/etc/security/cacerts/ 移动</span><br><span class="line">chmod 644 /system/etc/security/cacerts/ec936cb1.0 修改权限</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315221819946.png" alt="image-20220315221819946"></p>
<p>PS: 如果觉得上面的操作比较复杂，推荐一款软件<code>MT管理器</code>直接移动证书到系统证书目录，记得还是要修改权限</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16473543764381.png" alt="01-16473543764381" style="zoom:25%;">

<p>重启手机验证。</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220315224800107.png" alt="image-20220315224800107"></p>
<h1 id="Magisk模块"><a href="#Magisk模块" class="headerlink" title="Magisk模块"></a>Magisk模块</h1><p><code>move certificates</code>：移动用户目录证书到系统证书目录</p>
<h1 id="xposed模块"><a href="#xposed模块" class="headerlink" title="xposed模块"></a>xposed模块</h1><p><code>SSLUnpinning</code>：在SSL类中创建了几个钩子来绕过特定应用程序的证书验证</p>
<p>PS: 就是客户端并不会默认信任系统根证书目录中的证书，而是在代码里再加一层校验，这就是证书绑定机制——<code>SSL pinning</code>，如果这段代码的校验过不了，那么客户端还是会报证书错误</p>
<h1 id="VPN工具："><a href="#VPN工具：" class="headerlink" title="VPN工具："></a>VPN工具：</h1><h2 id="Postern"><a href="#Postern" class="headerlink" title="Postern:"></a>Postern:</h2><p>网络流量可以通过配置的代理服务器重定向。不需要为每个应用程序配置代理，不支持代理的应用程序也将遵循代理配置。需要做的就是将你的代理服务器放在Postern 中，并指定应该通过代理访问哪些主机&#x2F;目的地。Postern 支持所有流行的代理服务器</p>
<p>第一步: 打开配置代理，配置如下</p>
<p>名称：随便</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16473567161993.png" alt="01-16473567161993" style="zoom:25%;">

<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16473566520102.png" alt="01-16473566520102" style="zoom:25%;">

<p>第二部：配置规则如下</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16473568107464.png" alt="01-16473568107464" style="zoom:25%;">

<h2 id="Proxydroid"><a href="#Proxydroid" class="headerlink" title="Proxydroid:"></a><strong>Proxydroid:</strong></h2><p>在安卓设备上设置代理（http&#x2F;https &#x2F; socks4 &#x2F; socks5）的应用程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">** 功能 **</span><br><span class="line">1. 支持 HTTP / HTTPS / SOCKS4 / SOCKS5 代理</span><br><span class="line">2. 支持基本 / NTLM / NTLMv2 身份验证方法</span><br><span class="line">3. 仅一个或多个应用程序的单独代理</span><br><span class="line">4. 支持多个配置文件</span><br><span class="line">5. 绑定配置到 WIFI 的 SSID / 移动网络 (2G / 3G)</span><br><span class="line">6. 用于快速打开/关闭代理的小部件</span><br><span class="line">7. 低电池和内存消耗（用 C 编写并编译为本地二进制文件）</span><br><span class="line">8. 绕过自定义 IP 地址</span><br><span class="line">9. 防火墙后面的人的 DNS 代理，不允许解析外部地址</span><br><span class="line">10. PAC 文件支持（仅基本支持）</span><br></pre></td></tr></table></figure>

<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-1647395429928.png" alt="01-1647395429928" style="zoom:25%;">

<p>Proxy Type可以选中代理类型</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/02-1647395438752.png" alt="02-1647395438752" style="zoom:25%;">



<h2 id="Httpcannary："><a href="#Httpcannary：" class="headerlink" title="Httpcannary："></a>Httpcannary：</h2><p>一款功能强大的 HTTP&#x2F;HTTPS&#x2F;HTTP2&#x2F;WebSocket&#x2F;TCP&#x2F;UDP 数据包捕获和分析应用程序，专为 Android 平台设计。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 内容概览</span><br><span class="line">HttpCanary 显示多维会话概览。包括 URL、http 协议、http 方法、响应码、服务器主机、服务器 ip 和端口、内容类型、keep-alive、时序、数据大小等。</span><br><span class="line"></span><br><span class="line">* 数据包过滤和搜索</span><br><span class="line">HttpCanary多维过滤器，可以按app、host、protocol、method、ip、port、关键字过滤数据包。此外，您可以在数据包的内容中搜索关键字。</span><br><span class="line"></span><br><span class="line">* 阻止设置</span><br><span class="line">您可以选择阻止请求和响应，很容易调试您的 REST API。</span><br><span class="line"></span><br><span class="line">* 插件</span><br><span class="line">HttpCanary 支持许多插件，包括实验插件和扩展插件。现在，应用程序中集成了一些实验性插件，例如 HostBlock、Mime-TypeBlock、Downloader 和 OverviewStatistics。未来，我们将为开发者发布扩展插件-sdk，并支持扩展插件。</span><br></pre></td></tr></table></figure>

<p>傻瓜式安装，按照提示安装就行</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/02-1647574743715.png" alt="02" style="zoom:25%;">

<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-1647574758775.png" alt="01" style="zoom:25%;">

<h2 id="Drony："><a href="#Drony：" class="headerlink" title="Drony："></a>Drony：</h2><p>绕过SSLPinning检测</p>
<p>繁体版：</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-1647397020211.png" alt="01-1647397020211" style="zoom:25%;">



<p>英文版：</p>
<p>使用步骤：</p>
<p>1、打开Drony看到LOG页，右滑到SETTING页，选择Networks 下：Wi-Fi，点击当前在用的wifi名，进入Network details设置页</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220316105249660.png" alt="image-20220316105249660" style="zoom: 50%;">

<p>2、点击Hostname，输入当前电脑的局域网IP和端口( Proxy type页面会变成 Manual 手动模式)</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/02-1647399191677.png" alt="02-1647399191677" style="zoom:25%;">

<p>3、点击Filter default value，选择Direct all<br>（这步如果没加，log页面会看到很多信息）</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/03.png" alt="03" style="zoom:25%;">



<p>4、点击Rules，进入Rules详情页，点击右上角的加号，进入Add filter rule，action选择Local proxy chain，Application选择需要抓包的应用，然后保存，返回主页</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220316105602353.png" alt="image-20220316105602353" style="zoom: 50%;">

<p>5、左滑到LOG标签页，点击底部到OFF按钮，启用Drony</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/06.png" alt="06" style="zoom:25%;">



<h1 id="双向认证："><a href="#双向认证：" class="headerlink" title="双向认证："></a>双向认证：</h1><p>双向认证，顾名思义，客户端和服务器端都需要验证对方的身份，在建立HTTPS连接的过程中，握手的流程比单向认证多了几步。单向认证的过程，客户端从服务器端下载服务器端公钥证书进行验证，然后建立安全通信通道。双向通信流程，客户端除了需要从服务器端下载服务器的公钥证书进行验证外，还需要把客户端的公钥证书上传到服务器端给服务器端进行验证，等双方都认证通过了，才开始建立安全通信通道进行数据传输。</p>
<p>单一通信已经分裂成两个互相独立的通信，这时候与服务器进行通信的已经不是<code>app</code>、而是<code>中间工具</code>了，所以我们要将<code>app</code>中内置的证书导入到<code>中间工具</code>中去。</p>
<p>双向认证解决办法就是找证书密码</p>
<p>手工找：</p>
<p>找证书文件，</p>
<p>找证书密码</p>
<p>步骤：</p>
<p>解压apk文件，找<code>后缀.p12</code>文件，有的apk会隐藏，得慢慢找，密码在源代码里搜索</p>
<p>演示：略</p>
<p>fridaHook：</p>
<h2 id="HOOK代码："><a href="#HOOK代码：" class="headerlink" title="HOOK代码："></a>HOOK代码：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Enter!&quot;</span>)</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">storeP12</span>(<span class="params">pri, p7, p12Path, p12Password</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;X509!&quot;</span>)</span><br><span class="line">            <span class="keyword">var</span> X509Certificate = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.cert.X509Certificate&quot;</span>)</span><br><span class="line">            <span class="keyword">var</span> p7X509 = <span class="title class_">Java</span>.<span class="title function_">cast</span>(p7, X509Certificate);</span><br><span class="line">            <span class="keyword">var</span> chain = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&quot;java.security.cert.X509Certificate&quot;</span>, [p7X509])</span><br><span class="line">            <span class="keyword">var</span> ks = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.KeyStore&quot;</span>).<span class="title function_">getInstance</span>(<span class="string">&quot;PKCS12&quot;</span>, <span class="string">&quot;BC&quot;</span>);</span><br><span class="line">            ks.<span class="title function_">load</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            ks.<span class="title function_">setKeyEntry</span>(<span class="string">&quot;client&quot;</span>, pri, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).$new(p12Password).<span class="title function_">toCharArray</span>(), chain);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">var</span> out = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.FileOutputStream&quot;</span>).$new(p12Path);</span><br><span class="line">              ks.<span class="title function_">store</span>(out, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).$new(p12Password).<span class="title function_">toCharArray</span>())</span><br><span class="line">            &#125; <span class="keyword">catch</span> (exp) &#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(exp)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//在服务器校验客户端的情形下，帮助dump客户端证书，并保存为p12的格式，证书密码为a1ili</span></span><br><span class="line">          <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.KeyStore$PrivateKeyEntry&quot;</span>).<span class="property">getPrivateKey</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">getPrivateKey</span>()</span><br><span class="line">            <span class="keyword">var</span> packageName = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.app.ActivityThread&quot;</span>).<span class="title function_">currentApplication</span>().<span class="title function_">getApplicationContext</span>().<span class="title function_">getPackageName</span>();</span><br><span class="line">            <span class="title function_">storeP12</span>(<span class="variable language_">this</span>.<span class="title function_">getPrivateKey</span>(), <span class="variable language_">this</span>.<span class="title function_">getCertificate</span>(), <span class="string">&#x27;/sdcard/Download/&#x27;</span> + packageName + <span class="string">&#x27;.p12&#x27;</span>, <span class="string">&#x27;a1ili&#x27;</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dumpClinetCertificate=&gt;&quot;</span> + <span class="string">&#x27;/sdcard/Download/&#x27;</span> + packageName + <span class="string">&#x27;.p12&#x27;</span> + <span class="string">&#x27;   pwd: a1ili&#x27;</span>);            </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.KeyStore$PrivateKeyEntry&quot;</span>).<span class="property">getCertificateChain</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">getCertificateChain</span>()</span><br><span class="line">            <span class="keyword">var</span> packageName = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.app.ActivityThread&quot;</span>).<span class="title function_">currentApplication</span>().<span class="title function_">getApplicationContext</span>().<span class="title function_">getPackageName</span>();</span><br><span class="line">            <span class="title function_">storeP12</span>(<span class="variable language_">this</span>.<span class="title function_">getPrivateKey</span>(), <span class="variable language_">this</span>.<span class="title function_">getCertificate</span>(), <span class="string">&#x27;/sdcard/Download/&#x27;</span> + packageName + <span class="string">&#x27;.p12&#x27;</span>, <span class="string">&#x27;a1ili&#x27;</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dumpClinetCertificate=&gt;&quot;</span> + <span class="string">&#x27;/sdcard/Download/&#x27;</span> + packageName + <span class="string">&#x27;.p12&#x27;</span> + <span class="string">&#x27;   pwd: a1ili&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure>

<p>Android10源代码中获取privateKey函数</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220319164234742.png" alt="image-20220319164234742"></p>
<p>通过hook这个函数，得到密码</p>
<p><strong>把dump下来的证书，拿到keyStore转换</strong></p>
<p>输入密码脚本上的密码查看</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220319164641522.png" alt="image-20220319164641522"></p>
<p>导出你需要的格式的证书</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220319165521114.png" alt="image-20220319165521114"></p>
<p>然后在你使用的工具上导入证书</p>
<p>在<code>Charles</code>中是位于<code>Proxy</code>→<code>SSL Proxy Settings</code>→<code>Client Certificates</code>→<code>Add</code>添加新的证书</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220319165808731.png" alt="image-20220319165808731"></p>
<h1 id="NetHunter"><a href="#NetHunter" class="headerlink" title="NetHunter:"></a>NetHunter:</h1><p>首先手机刷入nethunter</p>
<p>刷入后手机界面如下所示：</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16474425217752.png" alt="01-16474425217752" style="zoom:25%;">

<p>使用：</p>
<p>1，首先打开<code>netHunter</code>点击<code>kali Chroot Manager</code> 然后点击<code>start kali chroot</code>进行初始化，初始化后如下</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16474427115523.png" alt="01-16474427115523" style="zoom:25%;">

<p>2，点击<code>kex Manager</code>打开如下界面</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16474428709006.png" alt="01-16474428709006" style="zoom:25%;">

<p>3，把<code>Localhost only</code>的钩去掉，先点击 setup local server点击<code>start server</code>设置密码，设置好后点击<code>Kex Server Status</code>旁边得到刷新按钮由<code>stop</code>变为<code>RUNING</code></p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16474430660657.png" alt="01-16474430660657" style="zoom:25%;">

<p>4，打开<code>NetHunter Kex</code> 输入密码，点击<code>Connect</code>进行链接，手机就会出现kali界面</p>
<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16474432561229.png" alt="01-16474432561229" style="zoom:25%;">

<img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/01-16474431774788.png" alt="01-16474431774788" style="zoom:25%;">

<p>此时就和电脑上的kali一样</p>
<p>4，手机上操作毕竟不方便，键盘太小，使用<code>VNC Viewer</code>在电脑端操作，IP:端口，端口默认是5901，然后你输入你设置的密码</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220316231051095.png" alt="image-20220316231051095"></p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220316232238328.png" alt="image-20220316232238328"></p>
<p>至此，手机就是移动版的<code>kali</code> ，渗透测试人员推荐使用<code>andrax</code></p>
<p>wlan0就是你手机的IP</p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220316234558516.png" alt="image-20220316234558516"></p>
<p><img src="/2022/03/18/%E6%8A%93%E5%8C%85%EF%BC%88%E4%BA%8C%EF%BC%89/image-20220316234502250.png" alt="image-20220316234502250"></p>
<h1 id="网卡抓包："><a href="#网卡抓包：" class="headerlink" title="网卡抓包："></a>网卡抓包：</h1><p>需要使用网卡，wifi共享大师等第三方软件（电脑端），发射出来wifi，手机连这个wifi，然后抓这个wifi的包，由于我的网卡只支持windows系统就不演示了，没在kali上演示好看</p>
<h1 id="证书："><a href="#证书：" class="headerlink" title="证书："></a>证书：</h1><h2 id="证书标准："><a href="#证书标准：" class="headerlink" title="证书标准："></a>证书标准：</h2><ol>
<li><p>X.509</p>
<p>这是一种证书标准，主要定义了证书中应该包含哪些内容。其详情可以参考 <code>RFC5280</code>，SSL 使用的就是这种证书标准。</p>
<p>同样的 <a href="https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/X.509">X.509</a> 证书，可能有不同的编码格式。最常见的就是 PEM 和 DER 两种格式。但是有个比较误导人的地方，这两种格式的文件，扩展名不一定就是 <code>.pem</code> 或 <code>.der</code>，还有其他一些常见格式。它们除了编码格式可能不同之外，内容也有差别。但是大多数都能相互转换编码格式。</p>
</li>
<li><p>作为文件形式存在的证书一般有这几种格式：</p>
<ul>
<li>带有私钥的证书（P12）<br>由 Public Key Cryptography Standards #12，PKCS#12 标准定义，包含了公钥和私钥的二进制格式的证书形式，以 pfx 作为证书文件后缀名。</li>
<li>二进制编码的证书（DER）<br>证书中没有私钥，DER 编码二进制格式的证书文件，以 <code>.cer</code> 作为证书文件后缀名。</li>
<li>Base64 编码的证书（PEM）<br>证书中没有私钥，Base64 编码格式的证书文件，也是以 <code>.cer</code> 作为证书文件后缀名。</li>
</ul>
</li>
</ol>
<h2 id="证书特点："><a href="#证书特点：" class="headerlink" title="证书特点："></a>证书特点：</h2><ol>
<li><p>PEM </p>
<ul>
<li>Base64 编码的 ASCII 文件</li>
<li>具备诸如 <code>.pem, .crt, .cer, .key</code> 这样的扩展名</li>
<li>Apache 和类似的服务器使用 PEM 格式的证书</li>
</ul>
<p>查看 PEM 格式证书的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in certificate.pem -text -noout</span><br></pre></td></tr></table></figure>
</li>
<li><p>DER</p>
<ul>
<li>二进制文件</li>
<li>扩展名为 <code>.cer</code> 和 <code>.der</code></li>
<li>DER 被典型地于 Java 平台</li>
</ul>
<p>查看 DER 格式证书的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in certificate.der -inform der -text -noout</span><br></pre></td></tr></table></figure>


</li>
<li><p>P7B&#x2F;PKCS#7</p>
<ul>
<li>Base64 编码的 ASCII 文件</li>
<li>扩展名为 <code>.p7b, .p7c</code></li>
<li>多平台支持。如：Windows OS、Java Tomcat</li>
</ul>
</li>
<li><p>PFX&#x2F;PKCS#12</p>
<ul>
<li>二进制文件</li>
<li>扩展名为 <code>.pfx, .p12</code></li>
<li>典型用于 Windows OS 导入导出证书和私钥</li>
</ul>
</li>
</ol>
<h2 id="证书间的转换："><a href="#证书间的转换：" class="headerlink" title="证书间的转换："></a>证书间的转换：</h2><p>PEM 转为 DER</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -outform der -in certificate.pem -out certificate.der</span><br></pre></td></tr></table></figure>

<p>PEM 转为 P7B</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl crl2pkcs7 -nocrl -certfile certificate.cer -out certificate.p7b -certfile CAcert.cer</span><br></pre></td></tr></table></figure>

<p>DER 转为 PEM</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform der -in certificate.cer -out certificate.pem</span><br></pre></td></tr></table></figure>

<p><code>PKCS#12</code> 与 <code>PEM</code> 的相互转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从 cert.p12 中提取 私钥，不包含证书，私钥不加密，输出为 PEM 格式</span><br><span class="line">$ openssl pkcs12 -nocerts -nodes -in cert.p12 -out privatekey.pem</span><br><span class="line"></span><br><span class="line"># 从 cert.p12 中，只输出 client 证书，不输出私钥，输出为 PEM 格式</span><br><span class="line">$ openssl pkcs12 -clcerts -nokeys -in cert.p12 -out cert.pem</span><br><span class="line"></span><br><span class="line"># 将密钥与证书合成为 cert.p12</span><br><span class="line">$ openssl pkcs12 -export -in cert.pem -out cert.p12 -inkey key.pem</span><br></pre></td></tr></table></figure>

<p>从 <code>PFX</code> 格式文件中提取<code>私钥</code>格式文件（<code>.key</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -in mycert.pfx -nocerts -nodes -out mycert.key</span><br></pre></td></tr></table></figure>

<p>BKS</p>
<p>Android中，需要 BKS 格式证书。一般做法是将 P12 转为 BKS：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先使用 openssl 把 crt 和 key 转换为 p12 证书</span><br><span class="line">$ openssl pkcs12 -export -in client.crt -inkey client.key -out client.p12</span><br><span class="line"></span><br><span class="line"># 使用 keytool 把 p12 转换为 bks 证书</span><br><span class="line">$ keytool -importkeystore -srckeystore client.p12 -srcstoretype pkcs12 -destkeystore client.bks -deststoretype bks -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath bcprov-ext-jdk15on-158.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>抓包实战</tag>
      </tags>
  </entry>
</search>
